var store = [{
        "title": "Edge Case: Nested and Mixed Lists",
        "excerpt":"Nested and mixed lists are an interesting beast. It’s a corner case to make sure that      Lists within lists do not break the ordered list numbering order   Your list styles go deep enough.   Ordered – Unordered – Ordered      ordered item   ordered item            unordered       unordered                 ordered item       ordered item           ordered item   ordered item   Ordered – Unordered – Unordered      ordered item   ordered item            unordered       unordered                 unordered item       unordered item           ordered item   ordered item   Unordered – Ordered – Unordered      unordered item   unordered item            ordered       ordered                    unordered item           unordered item                           unordered item   unordered item   Unordered – Unordered – Ordered      unordered item   unordered item            unordered       unordered                    ordered item           ordered item                           unordered item   unordered item   Task Lists      Finish my changes   Push my commits to GitHub   Open a pull request            Follow discussions       Push new commits          ","categories": ["Edge Case"],
        "tags": ["content","css","edge case","lists","markup"],
        "url": "/edge%20case/edge-case-nested-and-mixed-lists/",
        "teaser": null
      },{
        "title": "Edge Case: Many Tags",
        "excerpt":"This post has many tags.  ","categories": ["Edge Case"],
        "tags": ["8BIT","alignment","Articles","captions","categories","chat","comments","content","css","dowork","edge case","embeds","excerpt","Fail","featured image","FTW","Fun","gallery","html","image","Jekyll","layout","link","Love","markup","Mothership","Must Read","Nailed It","Pictures","Post Formats","quote","standard","Success","Swagger","Tags","template","title","twitter","Unseen","video","YouTube","U:R:COOL","C#"],
        "url": "/edge%20case/edge-case-many-tags/",
        "teaser": null
      },{
        "title": "Edge Case: Many Categories",
        "excerpt":"This post has many categories.  ","categories": ["aciform","antiquarianism","arrangement","asmodeus","broder","buying","championship","chastening","disinclination","disinfection","dispatch","echappee","enphagy"],
        "tags": ["categories","edge case"],
        "url": "/aciform/antiquarianism/arrangement/asmodeus/broder/buying/championship/chastening/disinclination/disinfection/dispatch/echappee/enphagy/edge-case-many-categories/",
        "teaser": null
      },{
        "title": "Edge Case: No Body Content",
        "excerpt":" ","categories": ["Edge Case"],
        "tags": ["content","edge case","layout"],
        "url": "/edge%20case/edge-case-no-body-content/",
        "teaser": null
      },{
        "title": "Markup: Image Alignment",
        "excerpt":"한글 포스트  ","categories": ["Markup"],
        "tags": ["alignment","captions","content","css","image","markup"],
        "url": "/markup/markup-image-alignment/",
        "teaser": null
      },{
    "title": "BindCommand Class",
    "excerpt":"the main structure   Property Relationships   The Bindcommand object contains MetaView with valid, bind, and output properties. The ‘output’ property refers to the property ‘output1’ of the object in ‘_outputs’ (MetaViewCollection). You can add a view through the newOutput(name?) method, “output + sequential” to “_outputs” The collection is added as a name.   Class diagram      an inheritance relationship   You can either inherit and extend Bindcommand or override Bindcommand to customize it.      Components   Properties                  Item       Description                       config       same as axios config                 url       url path                 _outputs       ‘_outputs’ MetaView collection property                 _model       ‘_model’ BindModel object                 valid       MetaView for inspection                 bind       bind MetaView                 output       default output MetaView.See  _outputs[0] object                 Output Option       Output option. (Default = 0) - 0: No view -1: Import all columns and rows - 2: Import the rows of existing columns - 3: Import the rows of existing columns, set to value in the nth letter                 cbBegin       execute() start callback. ‘callback(bindComand)’                 cbValid       execute() valid 검사 전 콜백 입니다. callback(validView, bindComamnd)                 cbBind       execute() bind  전 콜백 입니다. callback(validView, bindComamnd, config)                 cbResult       execute() 회신  콜백 입니다. callback(data, bindComamnd, response)                 cbOutput       execute() output View 매칭 후  콜백 입니다. callback(views, bindComamnd, response)                 cbEnd       execute() 종료 콜백 입니다. callback(status, bindComamnd, response)                 _guid       Unique identifier of the object (GUID). Uniquely identifies the object.           Method                  Item       Description                       execute(): Promise       순서 :  _execBegin() » _execValid() » _execBind() » _execResult() » _execOutput() » _execEnd()                 addColumn(column, views, bTable?)       Add a column, add it to the specified table, and register the reference of the column to the valid, bind, output MetaView in Bindcommand.                 addColumnValue (name, value, views, bTable?)       Add a column and value with the specified name, and register the reference of the column with the value, bind, output MetaView in Bindcommand.                 setColumn (names, views, bTable?)       Sets the column of the meta table to the specified MetaView                 release(names)       Remove the specified column from the destination MetView                 add MetaView to the newOutput(name?)       ‘_output’ MetaViewCollection. * - default name = ‘output’ + _out.count                 removeOutput(name)       _output MetaViewCollection 에 MetaView 을 제거합니다.                 getObject(): object       Get object of the guid type of the current object                 setObject(obj, origin)       Initialize the current object, and set it using the object of the specified guid type                 equal(target)       Compare the current object with the specified object.                 getTypes()       Returns the constructors of the current object and all the constructors of the prototype chain to the array.                 instanceOf(target)       Verify that the current object is an instance of the specified type (with _UNION)           Events                  Item       Description                               onExecute       common event before execution                         OnExecuted       common event after execution       inspect()           Detailed description   Key Properties   config      This is the setting for the AJAX request. Same format as ‘config’ in axios.    type config = object;   url      Set the URL for the AJAX request.    type url = string;   _outputs      Collection that stores output results.    type _outputs = MetaViewCollection;   _model      Bind model object.    type _model = BindModel;   valid      MetaView object to be inspected.    type valid = MetaView;   bind      Bind target MetaView object.    type bind = MetaView;   bind (MetaView) is a list of columns that are sent to the server. The column name and column value in the bind.column collection are sent (requested) to the server.   Internal operating structure  var bm = new BindModel(); bm.url = '/user' bm.addCommand('test'); bm.cmd['test'].addColumnValue('user_name', 'Neo'); bm.cmd['test'].addColumnValue('passwd', '1234'); bm.cmd['test'].execute();  ///// Send to internal var axiosConfig = { \turl: '/user', \tdata: { \t\tuser_name: 'Neo', \t\tpasswd: '1234' \t} }   output     Dynamic added output MetaView object.    type output = MetaView;   outputOption     Output attribute options.         0: Except     1: Import rows of all columns     2: Import only rows of existing columns     3: Import only rows of existing curums, set value      type outputOption = object;   outOpt   Alias for &gt; outputOptions.   type outOpt = object;   cbBegin      This is the callback function that is called at the start of execution.    type cbBegin = (cmd: BindCommand) =&gt; void;     cmd - This is the current bind command object.   cbValid      Callback function called before valid.    type cbValid = (valid: MetaView, command: BindCommand) =&gt; boolean;     valid : object ‘MetaView’ to be inspected.   command : The current bind command object.   return : A boolean value representing the result of the examination.   cbBind      This is the callback function that is called before bind.    type cbBaseBind = ( \tbind: MetaView,  \tcommand: BindCommand,  \tconfig: object ) =&gt; void;     bind : object ‘MetaView’ to bind.   command : The current bind command object.   config : This is the setting object.   cbResult      This is a callback function that handles binding results. Mainly used for processing result data.    type cbResult = ( \tdata: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     data : Bind result data object.   cmd : This is the current bind command object.   response —Response object.   return : Processed result data.     cbOutput          This is a callback function that outputs binding results. Mainly used for the output of lists.    type cbOutput = ( \toutputs: MetaViewCollection,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     outputs : Metabiew collection.   command : The current bind command object.   response —Response object.   return —Returns the processed result object.     cbEnd          This is a callback function that is called after processing is finished.    type cbBaseEnd = ( \tstatus: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; void;     status : The object containing status information.   command : The current bind command object.   response —Response object.   _guid      Unique identifier of the object (GUID). Uniquely identifies the object.    type _guid = string;   _type      The generator function of the object, which was used when the object was created.    type _type = Function;   Key Methods   execute()      Run the bind command. Performs the entire execution process, including validation, binding, result processing, success, and error callback.    type execute = () =&gt; Promise&lt;void&gt;;     return : This is the ‘Promise’ object representing the execution result.   var bm = new BindModel();  bm.addCommand('test1'); bm.addCommand('test2'); ...  bm.cmd['test1'].execute(); bm.cmd['test2'].execute();   addColumn()      Add a column and map it to the specified view.    type addColumn = ( \tcolumn: string | MetaColumn,  \tviews: string | string[],  \tbTable: string | MetaTable ) =&gt; void;     column : column object to be registered; it could be a string or ‘MetaColumn’ object.   views : The name of the view entity to be added; it can be a string or array of strings.   bTable : (Optional) Default table object or table name to be mapped.     addColumnValue()          Add columns and values and map them to the specified view.    type addColumnValue = ( \tname: string,  \tvalue: any,  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; void;     name : The name of the column.   value : The value of the column.   views —(Optional) Name of the view entity to be added.   bTable : (Optional) Default table object or table name to be mapped.   setColumn()      Set the column.    type setColumn = (name: string | string[], views: string | string[]) =&gt; void;     name —Column name or array of names.   views —The name or array of views to set.   release()      Release the column from the target entity.    type release = (name: string | string[], views: string | string[]) =&gt; void;     name —Column name or array of names to release.   views —The name or array of view entities to be disabled.   newOutput()      Add a view entity to use for the output. The default name is ‘output’ + _outputs.count.    type newOutput = (name?: string) =&gt; void;     name —(Optional) The name of the view to be referenced additionally.   removeOutput()      Delete the output view.    type removeOutput = (name: string) =&gt; boolean;     name — The name of the view to be deleted.   getObject()      Obtain the current object as a guide type object. (Circular references are replaced by $ref values.)    type getObject = (vOpt?: number, owned?: object | Array&lt;object&gt;) =&gt; object;     vOpt : Import option; default is 0.            opt=0: Reference structure (_guid:Yes, $ref:Yes)       opt=1: Redundant structure (_guid:Yes, $ref:Yes)       opt=2 : Non-tidal structure (_guid: No, $ref: No)           aged : The parent objects that currently own the object. The default is an empty object.   return —Returns serialized objects.   a.getObject(2) == b.getObject(2)   setObject()      Set the Guid type object to the current object. (The object will be reset.)    type setObject = (oGuid: object, origin?: object) =&gt; void;     oGuid : Object of the guid type to serialize.   origin : This is the original object that sets the current object. The default is oGuid.   equal()      Compare the current object with the specified object.    type equal = (target: object) =&gt; boolean;     return —Returns whether the two objects are identical.   getTypes()      Returns the creators of the current object and all the creators of the prototype chain to the array.    type getTypes = () =&gt; Array&lt;Function&gt;;     return : Returns the array of generator functions.   const types = obj.getTypes(); console.log(types); // [Function: MetaObject]   instanceOf()      Verify that the current object is an instance of the specified type (including _UNION)    type instanceOf = (target: object | string) =&gt; boolean;     target : The type of object to be checked (object or string).   return —Returns whether this is an instance of the specified type.   Key Events   onExecute      Events that are called before the command is executed.    type onExecute = (cmd: BindCommand) =&gt; void;     cmd : Command object to be executed.   onExecuted      An event that is called after the command is executed.    type onExecuted = (cmd: BindCommand, result: object) =&gt; void;     cmd : Command object executed.   result : The result object of the command execution.   ","url": "http://localhost:4000/docs/api-bind-command-ajax/"
  },{
    "title": "BindModel Class",
    "excerpt":"the main structure  Property Relationships   Create a BindModel object and create a Bind Command object in the addCommmand() method. The generated ‘command[‘identifier’]’ has MetaView with valid, bind, and output attribute values. Ajax communication uses the ‘axios’ module internally.   Class diagram      an inheritance relationship   You can either inherit and extend the BindModel or override the BindModel to customize it.   Class diagram      Components   Properties                  Item       Description                       baseConfig       Set binding default config                 url       Set binding default config.url                 _tables       Meta-table collection. Manage multiple meta-tables.                 [[52. BindModel Class-B#_columnType|_columnType]       Set item type.                 items       Item collection                 fn       collection of bound model functions. (Internal function + Exposure function)                 command       collection of binding commands                 columns       Collection of columns. Represents the columns of the _baseTable.                 first       The first dynamically generated meta table                 cbFail       Callback function called upon failure in inspection (valid)                 cbError       Callback function called in case of error                 cbBaseBegin       Default callback function before startup.   (used without cbBegin callback function)                 cbBaseValid       Default callback function at inspection (valid)   (used without cbValid callback function)                 cbBaseBind       Default callback function when bound.   (used without cbBind callback function)                 cbBaseResult       Default callback function on the receipt of bind results.   (used without cbResult callback function)                 cbBaseOutput       Output Default callback function.  (used without cbOutput callback function)                 cbBaseEnd       Default callback function at execution completion.   (used without cbEnd callback function)                 preRegister       callback function initially called upon init() call                 PreCheck       callback function that returns boolean on init() call.           Method                  Item       Description                               Check Selector (collection?)       Examine the selector                         getSelector()       Get a list of destination selectors                         addcommand (name, opt? , baseTable?)       add command                         setService(svc, chkType)       Set up a service                         Init()       Perform the initialization operation. Internally call ‘preRegister()’ -&gt; ‘preCheck()’ -&gt; ‘preReady()’                         addTable(name)       Register the table                         addColumn (column, cmds? , views? , bTable?)       Add columns and map them with commands                         addColumnValue (name, value, cmds? , views? , bTable?)       Add columns and values, add them to the specified table, and register the reference to the column in the value, bind, output MetaView in Bindcommand.                         setMapping (mapping: collection \\       object, bTable?)       Map columns                 getObject(): object       Gets the current object as a guid type object. (Circular reference is replaced by $ref value.)                         setObject(obj, origin)       Set the serialization (guid type) object to the current object. (The object is initialized.)                         equal(target)       Compare the current object with the specified object.                         getTypes()       Returns the constructors of the current object and all the constructors of the prototype chain to the array.                         instanceOf(target)       Verify that the current object is an instance of the specified type (with _UNION)                   Events  | Item | Description | | ———- | ———————- | | OnExecute | expecte() pre-execution event | OnExecuted | expecte() post-execution event   Detailed description   Key Properties   baseConfig      Set the binding default config.    type baseConfig = object;   url      Set the binding default config.url.    type url = string;   _tables      This is the meta table collection. Manage multiple meta tables.    type _tables = MetaTableCollection;   _columnType      Set the column type.    type _columnType = MetaColumn;   items      It’s an item collection.    type items = PropertyCollection;  fn      A collection of bound model functions. (Internal function + Exposure function)    type fn = PropertyCollection;   command      A collection of binding commands.    type command = PropertyCollection;   cmd      It’s an alias for command.    type cmd = PropertyCollection;   columns      It’s a column collection. Indicates the column in &gt; _baseTable.    type columns = MetaTableColumnCollection;   first      This is the first dynamically generated meta table. Reference value for &gt; _tables[0].    type first = MetaTable;   cbFail      This is the callback function that is called upon failure by valid.    type cbFail = (result: object, column: MetaColumn) =&gt; void;     result : The object containing the result of the examination.   column : ‘MetaColumn’ object used in the inspection.     cbError          This is the callback function that is called when an error occurs.    type cbError = (msg: string, status: object, response: object) =&gt; void;     msg : Error message.   status : The object containing status information.   response —Response object.     cbBaseBegin             Default callback function before startup (used when cbBegin callback function is not present)            type cbBaseBegin = (command: BindCommand) =&gt; void;     command : The current bind command object.     cbBaseValid          Default callback function at valid (used without cbValid callback function)    type cbBaseValid = (valid: MetaView, command: BindCommand) =&gt; boolean;     valid : object ‘MetaView’ to be inspected.   command : The current bind command object.   return : A boolean value representing the result of the examination.   cbBaseBind      Default callback function when bound (used without cbBind callback function)    type cbBaseBind = ( \tbind: MetaView,  \tcommand: BindCommand,  \tconfig: object ) =&gt; void;     bind : object ‘MetaView’ to bind.   command : The current bind command object.   config : This is the setting object.   cbBaseResult      Default callback function when receiving bind results. (Used when cbResult callback function is not available)    type cbBaseResult = ( \tdata: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     data : Bind result data object.   command : The current bind command object.   response —Response object.   return —Returns the processed result object.   cbBaseOutput      Output default callback function (used when cbOutput callback function is not present)    type cbBaseOutput = ( \toutputs: MetaViewCollection,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     outputs : Metabiew collection.   command : The current bind command object.   response —Response object.   return —Returns the processed result object.   cbBaseEnd      Default callback function at execution completion (used when cbEnd callback function is not present)    type cbBaseEnd = ( \tstatus: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; void;     status : The object containing status information.   command : The current bind command object.   response —Response object.   preRegister      This is the callback function that is initially called upon init().    type preRegister = (model: BindModel) =&gt; void;     model : The current bound model object.   preCheck      Callback function that returns boolean on init() call.    type (model: BindModel)=&gt;boolean;     model : The current bound model object.   return : A boolean value representing the result of the examination.   preReady      Callback function called when preCheck callback function result is true when invoking &gt; init().    type preReady = (model: BindModel) =&gt; void;     model : The current bound model object.   _baseTable      Define the default entity.    type _baseTable = MetaTable;   _guid      Unique identifier of the object (GUID). Uniquely identifies the object.    type _guid = string;   _type      The generator function of the object, which was used when the object was created.    type _type = Function;   Key Methods   checkSelector()      Examine the selector.    type checkSelector = (collection: BaseColumnCollection) =&gt; boolean;     collection —Column collection to examine.   return : A boolean value representing the result of the examination.   getSelector()      Obtain a list of destination selectors.    type getSelector = (collection: PropertyCollection) =&gt; object[];     collection : A collection of properties to be examined; the default is items.   return : An object array representing a list of selectors.   addCommand()      Add a command.    type addCommand = ( \tname: string,  \toption: number,  \tbaseTable: MetaTable ) =&gt; BindCommand;     name : The name of the command.   option : Output option.   baseTable : (Optional) Default table object.   return —Added bind command object.   setService()      Set up the service.    type setService = (service: IServiceAjax, passTypeChk: boolean) =&gt; void;     service : service object.   PassTypeChk : Whether the service object type inspection has passed or not. (Default: false)   init()      Perform the initialization operation. Internally, call ‘preRegister()’ -&gt; ‘preCheck()’ -&gt; ‘preReady()’.    type init = () =&gt; void;   addTable()      Register the table.    type addTable = (name: string) =&gt; MetaTable;     name : The name of the table to be registered.   return : Returns the registered meta table object.   addColumn()      Add columns and map them to commands.    type addColumn = ( \tcolumn: MetaColumn,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; void;     column: column object to be registered. It could be a string or ‘MetaColumn’ object.   cmds : (Optional) Command to specify the location of the view; it can be a string or an array of strings.   views —(Optional) Name of the view entity to be added; it can be a string or an array of strings.   bTable : (Optional) Default table object or table name to be mapped.   addColumnValue()      Add columns and values, add them to the specified table, and register the reference to the column in the value, bind, and output MetaView in the Bindcommand.    type addColumnValue = ( \tname: string,  \tvalue: any,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; void;     name : The name of the column.   value : The value of the column.   cmds : Command to specify the location of the view; it can be a string or an array of strings.   views : The name of the view entity to be added; it can be a string or array of strings.   bTable : (Optional) Default table object or table name to be mapped.   setMapping()      Map columns.    type setMapping = ( \tmapping: PropertyCollection | object,  \tbaseTable?: string | MetaTable ) =&gt; void;     mapping —Object or collection to map to MetaColumn   baseTable —(Optional) Default table object or table name to be mapped.   getObject()      Obtain the current object as a guide type object. (Circular references are replaced by $ref values.)    type getObject = (vOpt?: number, owned?: object | Array&lt;object&gt;) =&gt; object;     vOpt : Import option; default is 0.            opt=0: Reference structure (_guid:Yes, $ref:Yes)       opt=1: Redundant structure (_guid:Yes, $ref:Yes)       opt=2 : Non-tidal structure (_guid: No, $ref: No)           aged : The parent objects that currently own the object. The default is an empty object.   return —Returns serialized objects.   a.getObject(2) == b.getObject(2)   setObject()      Set the Guid type object to the current object. (The object will be reset.)    type setObject = (oGuid: object, origin?: object) =&gt; void;     oGuid : Object of the guid type to serialize.   origin : This is the original object that sets the current object. The default is oGuid.   equal()      Compare the current object with the specified object.    type equal = (target: object) =&gt; boolean;     return —Returns whether the two objects are identical.   getTypes()      Returns the creators of the current object and all the creators of the prototype chain to the array.    type getTypes = () =&gt; Array&lt;Function&gt;;     return : Returns the array of generator functions.   const types = obj.getTypes(); console.log(types); // [Function: MetaObject]  instanceOf()      Verify that the current object is an instance of the specified type (including _UNION)    type instanceOf = (target: object | string) =&gt; boolean;     target : The type of object to be checked (object or string).   return —Returns whether this is an instance of the specified type.   Key Events   onExecute      Events that are called before the command is executed.    type onExecute = (cmd: BindCommand) =&gt; void;     cmd : Command object to be executed.   onExecuted      An event that is called after the command is executed.    type onExecuted = (cmd: BindCommand, result: object) =&gt; void;     cmd : Command object executed.   result : The result object of the command execution.   ","url": "http://localhost:4000/docs/api-bind-model-ajax/"
  },{
    "title": "HTMLColum Class",
    "excerpt":"HTML Column is the key to binding If you directly control the internal implementation method without using a special indicator, you can apply it to various conditions when you get used to it. It is advantageous for debugging and application during development, and developer tools alone are sufficient.   We focused on recycling and minimizing duplication of code while maintaining a classic coding method.   the main structure   an inheritance relationship   Class diagram    a key element   Properties                  Item       Description                       DomType       Defines the item DOM type                 isReadOnly       Indicates whether read-only                 isHide       Indicates whether it is hidden or not                 element       represents the DOM element                 Selector       Defines a selector                 getFilter       Function to filter value                 setFilter       Function to filter value                 value       Sets or imports the value of the item                 Required       Sets whether the column value is required: ‘true’ if the value must exist, or ‘false’ if not                 Constraints       Set the constraints for the column. Constraints can be set in the form of objects or functions.                 getter       getter function of column value                 setter       setter function of column value                 columnName       Indicates the name of the column. Same as ‘_name’                 Alias       Sets or imports aliases for columns. Alias are used to transfer data and set low values                 default       Set the default value for the column                 Caption       Provides a description of the column                 _valueTypes       Defines the value type for the column. This property is used to set the value type for the column.                 _entity       Indicates the entity to which this column belongs. It is an object of type ‘BaseEntity’                 _guid       Unique identifier of the object (GUID). Uniquely identifies the object.                 _type       The generator function of the object. The function used when the object was created.                                     Method                  Item       Description                       clone(entity)       Replicates the DOM of the current item                 addConstraint (regex, msg, code, condition)       Add constraints                 Valid(value)       Checks that the value of the property is valid. Validates based on ‘required’ and ‘constructions’                 getObject(vOpt, up)       Gets the current object as a serialized object. The cyclic reference is replaced by the value ‘$ref’                 setObject(oGuid, origin)       Sets serialized object to current object.  The object is initialized.                 equal(target)       Compare the current object with the specified object.                 getTypes()       Returns the constructors of the current object and all the constructors of the prototype chain to the array.                 instanceOf(target)       Verify that the current object is an instance of the specified type (with _UNION)                                     Events                  Item       Location       Description                       OnChanged       MetaColumn       An event that occurs when the column value changes                                             Detailed description   Key Properties   domType      Define the item DOM type.    type domType = object;   isReadOnly      Indicates whether it is read-only.    type isReadOnly = boolean;   isHide      Indicates whether it is hidden or not.    type isHide = boolean;   element      Indicates the DOM element.    type element = HTMLElement;   selector      Define the selector. type         ‘value’ or ‘value’: Value property value of element     ‘text’: Text value of element     ‘html’: HTML value of element     ‘css. quick name’: property value of CSS (object)     ‘prop. fast name’: Attribute name value of element (based on initial state)     ‘Attr. fast name’: Attribute name value of element (current state)     ‘none’: No action, purpose of expression 예시: ‘value’, ‘text’, ‘css.color’, ‘prop.disabled’      type selector = { key: string, type: string };   getFilter      This function filters the value.    type getFilter = (sVal: any) =&gt; any;     sVal : This is the value obtained from selector when selector exists.   return —Filtered value.   setFilter      This function filters the value.    type setFilter = (val: any) =&gt; any | undefined;     val : The value to be applied as a filter.   return : If there is a filtering result value, set the selector value.            Do not set selector values on undefined returns.         value                      Sets or imports the value of the item.    type value = string | number | boolean;   required      Sets whether column values are required. If the value must exist, it is ‘true’, otherwise it is ‘false’.    type required = boolean;   constraints      Set the constraints for the column. Constraints can be set in the form of objects or functions.    type constraints = (object | Function)[];   getter      Getter function of column value.    type getter = () =&gt; string | number | boolean;     return : The current value of the column.   setter      Setter function of column value.    type setter = (value: string | number | boolean) =&gt; void;     value : This is the value to set.   columnName      Indicates the name of the column. Same as ‘_name’.    type columnName = string;   alias   Set or import aliases for &gt; columns, which are used to transfer data and set low values.     Where to use (default = columnName)\\         Bind-command-ajax._execBind(): When transferring data     BaseBind.setValue(row): When setting a low value to an entity     getValue(): Used for row      type alias = string;   default      Set the default value for the column.    type default = string | number | boolean;   caption      Provides a description of the column.    type caption = string;   _valueTypes      Defines the value type for the column, which is used to set the value type for the column.    type _valueTypes = any;   _entity      Indicates the entity to which this column belongs, an object of type ‘BaseEntity’.    type _entity = BaseEntity;   _guid      Unique identifier of the object (GUID). Uniquely identifies the object.    type _guid: string;  _type      The generator function of the object, which was used when the object was created.    type _type = Function;   Key Methods   clone()      Replicates the current column.    type clone = (entity: BaseEntity) =&gt; this;     entity : The entity to be replicated.   return : This is a replica of the current instance.   addConstraint()      Add constraints.    type addConstraint = ( \tregex: RegExp,  \tmsg: string,  \tcode?: string,  \tcondition?: boolean ) =&gt; void;     regex : Regular expression to apply.   msg —Message to display when regular expression fails.   code : Code for failure of regular expression. (Optional)   condition : A condition that determines whether a constraint is successful/failed. Default is ‘false’.     valid()          Check that the value of the property is valid. Validates based on ‘required’ and ‘constructions’.    type valid = (value: ValueType): object | undefined;     value : The value to be inspected.   return : Returns the object if invalid, and returns ‘undefined’ if valid.   getObject()      Obtain the current object as a guide type object. (Circular references are replaced by $ref values.)    type getObject = (vOpt?: number, owned?: object | Array&lt;object&gt;) =&gt; object;     vOpt : Import option; default is 0.            opt=0: Reference structure (_guid:Yes, $ref:Yes)       opt=1: Redundant structure (_guid:Yes, $ref:Yes)       opt=2 : Non-tidal structure (_guid: No, $ref: No)           aged : The parent objects that currently own the object. The default is an empty object.   return —Returns serialized objects.   a.getObject(2) == b.getObject(2)   setObject()      Set the Guid type object to the current object. (The object will be reset.)    type setObject = (oGuid: object, origin?: object) =&gt; void;     oGuid : Object of the guid type to serialize.   origin : This is the original object that sets the current object. The default is oGuid.   equal()      Compare the current object with the specified object.    type equal (target: object) =&gt; boolean;     return —Returns whether the two objects are identical.   getTypes()      Returns the creators of the current object and all the creators of the prototype chain to the array.    type getTypes = () =&gt; Array&lt;Function&gt;;     return : Returns the array of generator functions.   const types = obj.getTypes(); console.log(types); // [Function: MetaObject]   instanceOf()      Verify that the current object is an instance of the specified type (including _UNION)    type instanceOf = (target: object | string) =&gt; boolean;     target : The type of object to be checked (object or string).   return —Returns whether this is an instance of the specified type.   Key Events   ###      An event that occurs when the column value changes.    type onChanged = (newVal: ValueType, oldVal: ValueType, _this: this) =&gt; void;     newVal : New value.   oldVal : This is the previous value.   _this : The object that caused the event.   column.onChanged = function(newVal, oldVal, _this) { \tconsole.log('Value changed'); };   Get the value of column   우선순위 : 1. getter &gt; 2. getFilter &gt; 3. selector &gt; 4. inner value &gt; 5.default Reply the selected value according to the priority of the property (getter, getFilter, selector) setting when obtaining the column value.  getter internal structure      setting value for column   설정 순서 : 1. setter &gt; 2. inner value &gt; 3. setFilter &gt; 4. selector Set sequentially when setting the column value.   setter internal structure        If setter exists, call the setter function.   Save the setter’s return value to the inner value. If there is no return, save the input.   If setFilter is present, call the setFilter function.   If you have a selector, set the value according to the type. (Use jquery) type : value, text, html, prop, attr, css (jquey사용) (excluding type = ‘none’)     frequency of use       It analyzes the frequency of use when designing HTMLComun     Minimize duplicate code   It can be applied to various cases   Intuitive code structure It was designed with consideration.   The ‘selector’ is also a checkSelector() method used to determine the presence of an element for the html page.                  빈도       setter       setFilter       selector       getFilter       getter       설명                       89%                               ‘Use’               - Direct DOM  - For single elements  - Tag p, text, select, css                 3%       ‘Use’               ‘Use’       - When pointing to an external object  - Example&gt; page_count                                 3%       ‘Use’       ‘Use’       ‘Use’       - When using DOM with external objects  - Example&gt; page_size = page display line (select box)                                 3%               ‘Use’       ‘none’       ‘Use’       - When referring to a composite DOM object  - Selector is used for inspection only  - Example&gt; radio                         1%       ‘Use’       ‘Use’       - Show  - Example&gt; Amount (number + comma) when used in one direction                                         1%                       ‘none’       ‘use’       -  - Example&gt; Code value conversion, list selection value                    (shopping mall website, based on DB Table 36EA)  Example Code  a. When using selector   Use to select the HTML element’s property value as value. The ‘type’ of the selector is html, text, value, prop.*, attr.*, and css.*. Selector can also be used for validation in addition to value lookup/setting. Use the checkSelector() method of the BindModel object to validate the DOM.   &lt;div id=\"p-nm\"&gt;&lt;p style=\"color:red;\"&gt;10&lt;/p&gt;&lt;/div&gt; &lt;input id=\"p-title\" type=\"text\" value=\"AA\" &gt; &lt;input id=\"p-check\" type=\"checkbox\" checked /&gt; &lt;a href=\"#\"&gt;google.com&lt;/a&gt;   var c1 = new HTMLColumn('c1'); var c2 = new HTMLColumn('c2'); var c3 = new HTMLColumn('c3'); var c4 = new HTMLColumn('c4'); var c5 = new HTMLColumn('c5'); var c6 = new HTMLColumn('c6');  c1.selector = { key: '#area-nm',  type: 'html' }; c2.selector = { key: '#area-nm',  type: 'text' }; c3.selector = { key: '#p-title',  type: 'value' }; c4.selector = { key: 'p-check',   type: 'prop.checked' }; c5.selector = { key: 'a',         type: 'attr.href' }; c6.selector = { key: 'p',         type: 'css.color' };  c1.value; // &lt;p&gt;10&lt;/p&gt; c2.value; // 10 c3.value; // \"AA\" c4.value; // true c5.value; // \"google.com\" c6.value; // \"red\"   b. When using setter, getter   Use to use the external value as the value of the HTML Column.  To use unidirectional external values read-only, specify only the getter function.   var PAGE_SIZE = 10; varc1 = new HTML Column ('c1'); // see external value  c1.getter = function(){ return PAGE_SIZE }; c1.setter = function(){ PAGE_SIZE = newVal };  c1.value; // 10  c. If the selector and setter/getter are used together   Use the external value as the value of the HTML Column, and specify when you need to express it in html. Depending on where the original data is located, it can be configured in various ways.   &lt;select id=\"page-size\"&gt;     &lt;option value=\"10\"&gt;10EA&lt;/option&gt;     &lt;option value=\"20\"&gt;20EA&lt;/option&gt;     &lt;option value=\"30\"&gt;30EA&lt;/option&gt; &lt;/select&gt;   var PAGE_SIZE = 10; var c1 = new HTMLColumn('c1');  c1.selector = { key: '#page-size',  type: 'value' }; c1.getter = function(){ return PAGE_SIZE }; c1.setter = function(newVal){ PAGE_SIZE = newVal };  c1.value; // 10 $(\"#page-size\") .val(\"20\"); // select change value c2.value; // 20 PAGE_SIZE // 20   d. When using setFilter/getFilter   The difference from setter/getter is used when the html expression is different from the value used internally. Mainly used to control multiple html elements.   &lt;input type=\"radio\" name=\"gender\" value=\"female\" /&gt; &lt;input type=\"radio\" name=\"gender\" value=\"male\" /&gt;   var c1 = new HTMLColumn('c1');  c1.selector = {  \tkey: 'input[name=gender][type=radio]',  type: 'value'  }; c1.getFilter = function(){ \t return $('input[name=gender]:checked').val(); }; c1.setFilter = function(newVal){ \t$('input[name=gender][value='+ newVal + ']').prop('checked', true); };  c1.value; // '' $(\"#gender\").val(\"female\"); // radio 값 변경 c2.value; // 'female'   Set service objects   var bm = new BindModel({ \t// If using selector only \tarea_page:     { selector: { key: '#area-page',   type: 'html' } }, \ttxt_sumCnt:    { selector: { key: '#sumCnt',      type: 'text' } }, \t \t// If you used setter/getter \tpage_count: { /* See page object outside */ \t\tgetter: ()=&gt; page.page_count, \t    setter: (val)=&gt; page.page_count = val; \t}, \t \t// If selector &amp; setter/getter is used \tpage_size: { \t  selector: { key: 'select[name=m-page_size]',     type: 'value' }, \t  getter: ()=&gt;{ return page.page_size; }, \t  setter: (val)=&gt;{ page.page_size = val; } \t}, \t \t// If you used selector['none'] &amp; setFilter/getFilter \tactive_yn: {  \t\tselector: { key: 'input[name=m-active_yn][type=radio]',  type: 'none' }, \t    setFilter: (val)=&gt;{  \t\t    $('input[name=active_yn][value='+ val + ']').prop('checked', true); \t\t}, \t    getFilter: (val)=&gt;{  \t\t    return $('input[name=active_yn]:checked').val(); \t\t} \t  }, \t \t// If selector &amp; setfilter is used (for comma application), one-way \tpoint: {     selector: { key: '#point_view',         type: 'text' },     setFilter: function(val) { return numberWithCommas(val); }     default: 0, // Set initial value \t}, \t \t// When using selector &amp; getFilter (when converting code values), one-way \tpoint: { \t\tselector: { key: '#codeValue',           type: 'value' }, \t    getFilter: function(val) { return val == '' ? 'CODE1' : 'CODE2'; } \t}, });  ","url": "http://localhost:4000/docs/api-html-column/"
  },{
    "title": "MetaTable Class",
    "excerpt":"the main structure   Property Relationships   Class diagram    ‘MetaTable’ is similar to the structure and usage of the ‘DataTable’ class in the .NET framework   an inheritance relationship   Class diagram    a key element   Properties                  Item       Description                       tableName       This property represents the name of the table                 columns       contains all columns in the item (attribute) collection table for this entity                 rows       Data (low) collection of entities                 _metaSet       MetaSet to which the entity belongs.                 _guid       Unique identifier of the object (GUID). Uniquely identifies the object.                 _type       The generator function of the object. The function used when the object was created.                                     Method                  Item       Description                       clone()       Create and return a deep copy of the current object                 copy(filter, args)       Copy the destination column                 acceptChanges()       Commit all changes to the current object. Allow changes: commit                 rejectChanges()       Rollback all changes to the current object. Cancel changes: rollback                 getChanges()       Returns a list of changes to the current object                 transformSchema()       Converts a given serialization object to a schema object                 Clear()       Initializes all data in the entity                 reset()       Initializes the entity’s columns and data                 NewRow()       Returns a new row that matches the column structure                 getValue()       Returns the value of the column as a MetaRow type object                 setValue(row)       Set the MetaRow value to the value of the column                 merge (target, optoin, matchType)       merge the given entity with the current entity                 select(filter, args)       query the row according to the given callback function                 load(obj, path)       Gets the given object into the current entity. Initializes the existing data and loads the new data                 output (Vopt, stringify, space)       Outputs the current entity as a serialized string                 read(obj, option)       Reads the given object as an entity. Follow JSON schema rules.                 readSchema (obj, createRow)       Reads the given schema object as the current entity                 readData(obj)       Reads only rows that exist on a given object                 write(vOpt)       Returns the current entity by converting it to an object of schema type                 writeSchema(vOpt)       Returns the schema of the current entity by converting it to an object of schema type                 writeData(vOpt)       Returns data from the current entity by converting it into schema-type objects.           Detailed description   Key Properties   tableName      Indicates the name of the table.    type tableName = string;   columns      Collection of columns in the table.    type columns = MetaTableColumnCollection;   rows      Data (low) collection of tables.    type rows = MetaRowCollection;   _metaSet      This is the meta set to which the table belongs.    type _metaSet = MetaSet;   _guid      Unique identifier of the object (GUID). Uniquely identifies the object.    type _guid = string;   _type      The generator function of the object, which was used when the object was created.    type _type = Function;  Key Methods   clone()      Create and return a deep copy of the current object.    type clone = () =&gt; MetaTable;     return : This is a replica of the current object.   copy()      Copy the target column.    type copy = ( \tfilter: (row, idx, entity) =&gt; boolean | string[], arguments&lt;string&gt;,  \tcols?: string[] | arguments&lt;string&gt; ) =&gt; MetaTable;     filter :            Function type is the callback function that selects the column.       Type string[] is the name of the column to copy.           cols : The name of the column to copy, valid only if the filter is a Function type.   Example: Using filter, cols  var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t(row, idx, entity) =&gt; { return (idx % 2) &gt; 0; }, \t['aa', 'bb'] );     Temp is copied only if the row indexes of the columns ‘aa’ and ‘bbb’ are odd.   Example: Using cols only  var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t['aa', 'bb'] );     Temp copies the entire row of columns ‘aa’ and ‘bbb’.   acceptChanges()      Commit all changes to the current object. Allow changes: commit    type acceptChanges = () =&gt; void;   rejectChanges()      Rolls back all changes to the current object. Cancel changes: rollback    type rejectChanges = () =&gt; void;   getChanges()      Returns a list of changes to the current object.    type getChanges = () =&gt; object[];     return : This is the changed list.     transformSchema()          Converts a given serialization object to a schema object.    type transformSchema = (oGuid: object) =&gt; object; // static     oGuid : object obtained by getObject().   clear()      Initializes all data in the entity.    type clear = () =&gt; void;   reset()      Initializes the entity’s columns and data.    type reset = () =&gt; void;   newRow()      Create and return a new row that matches the column structure.    type newRow = () =&gt; MetaRow;     return : This is the MetaRow object created.     getValue()       Returns the value of the &gt; column as a MetaRow type object.   type getValue = () =&gt; MetaRow;     return : MetaRow object with the value of the column set.   setValue()      Set the MetaRow value to the value in the column.    type setValue = (row: MetaRow) =&gt; void;     row : MetaRow object to be set.   merge()      Merges the given entity with the current entity.    type merge = (target: BaseEntity, option: number, matchType?: boolean) =&gt; void;     target : The target entity to merge.   option : Merge option.   matchType : Whether or not a row validation exists. (Default: false)   select()      Look up the row according to the given callback function.    type select = ( \tfilter: (row, idx, entity) =&gt; boolean | string[], | arguments&lt;string&gt;, \tcols?: string[] | arguments&lt;string&gt; ) =&gt; MetaView;     filter :            Function type is the callback function that selects the column.       Type string[] is the name of the column to copy.           cols : The name of the column to copy, valid only if the filter is a Function type.   Example: Using filter, cols  var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows var temp = table.copy( \t(row, idx, entity) =&gt; { return (idx % 2) &gt; 0; }, \t['aa', 'bb'] );     The temp view is copied only if the row indexes of the columns ‘aa’, ‘bbb’ are odd.   Example: Using cols only  var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t['aa', 'bb'] );     The temp view copies the entire row of columns ‘aa’ and ‘bbb’.   load()      Imports the given object to the current entity, initializes the existing data and loads the new data.    type load = (obj: object | string, parse?: Function) =&gt; void;     obj : The object to be called.   pas : parser function. (Optional)   output()      Outputs the current entity as a serialized string.    type output = (vOpt: number, stringify?: Function, space?: string) =&gt; string;     vOpt : Optional (0, 1, 2)   stringify : This is a user-defined parser function. (Optional)   space : A blank string to be used in the output. (Optional)   read()      Reads the given object as an entity. Follow JSON schema rules.    type read = (obj: object, option: number) =&gt; void;     obj : object to be read.   option : Read option (default: 3)   var schema1 = {  \ttable: {  \t\tcolumns: {},  \t\trows: {}  \t} };  var schema1 = {  \tcolumns: {...},  \trows: {}  };  readSchema()      Reads the given schema object as the current entity.    type readSchema = (obj: object, createRow?: boolean) =&gt; void;     obj : Schema object to be read.   createRow : If true, add the column by row[0] (default: false)   readData()      Reads only rows that exist on a given object.    type readData = (obj: object) =&gt; void;     obj : The object to be read.   write()      Returns the current entity after converting it to an object of schema type.    type write = (vOpt?: number) =&gt; object;     vOpt : Optional (default: 0)   return : Object of schema type.   writeSchema()      Returns the schema of the current entity by converting it to an object of schema type.    type writeData = (vOpt?: number): object;     vOpt : Optional (default: 0)   return : Object of schema type.   writeData()      Returns the data of the current entity by converting it into an object of schema type.    type writeData = (vOpt?: number) =&gt; object;     vOpt : Optional (default: 0)   return : Object of schema type.   getObject()      Obtain the current object as a guide type object. (Circular references are replaced by $ref values.)    type getObject = (vOpt?: number, owned?: object | Array&lt;object&gt;) =&gt; object;     vOpt : Import option; default is 0.            opt=0: Reference structure (_guid:Yes, $ref:Yes)       opt=1: Redundant structure (_guid:Yes, $ref:Yes)       opt=2 : Non-tidal structure (_guid: No, $ref: No)           aged : The parent objects that currently own the object. The default is an empty object.   return —Returns serialized objects.   a.getObject(2) == b.getObject(2)   setObject()      Set the Guid type object to the current object. (The object will be reset.)    type setObject = (oGuid: object, origin?: object) =&gt; void;     oGuid : Object of the guid type to serialize.   origin : This is the original object that sets the current object. The default is oGuid.   equal()      Compare the current object with the specified object.    type equal = (target: object) =&gt; boolean;     return —Returns whether the two objects are identical.   getTypes()      Returns the creators of the current object and all the creators of the prototype chain to the array.    type getTypes = () =&gt; Array&lt;Function&gt;;     return : Returns the array of generator functions.   const types = obj.getTypes(); console.log(types); // [Function: MetaObject]   instanceOf()      Verify that the current object is an instance of the specified type (including _UNION)    type instanceOf = (target: object | string) =&gt; boolean;     target : The type of object to be checked (object or string).   return —Returns whether this is an instance of the specified type.  ","url": "http://localhost:4000/docs/api-meta-table/"
  },{
    "title": "MetaView Class",
    "excerpt":"the main structure   Property Relationships   MetaView operates the same as MetaTable.  The difference is that if _baseEntity is specified, if add(name) column is added, the ‘column’ registers a reference,  ‘MetaColumn’ is registered in ‘column’ of baseEntity. Add(name, collection?) If you specify ‘collection’ when adding a column, the reference is registered in ‘columns’, ‘MetaColumn’ is registered in the specified ‘collecton’.   Class diagram    an inheritance relationship   Class diagram    a key element   Properties                  Item       Description                       viewName       This is the name of the meta view                 Columns       Collection of columns in the view                 rows       Data (low) collection of entities                 _baseEntity       Default entity                 _metaSet       Metaset to which the entity belongs.                 _name       Name of the element, which acts as a unique identifier for the MetaElement                 _guid       Unique identifier of the object (GUID). Uniquely identifies the object.                 _type       The generator function of the object. The function used when the object was created.                                     Method                  Item       Description                       clone()       Create and return a deep copy of the current meta view                 copy(filter, args)       Copy the destination column                 transformSchema()       Converts a given serialization object to a schema object                 Clear()       Initializes all data in the entity                 reset()       Initializes the entity’s columns and data                 NewRow()       Returns a new row that matches the column structure                 getValue()       Returns the value of the column as a MetaRow type object                 setValue(row)       Set the MetaRow value to the value of the column                 merge (target, optoin, matchType)       merge the given entity with the current entity                 select(filter, args)       query the row according to the given callback function                 load(obj, path)       Gets the given object into the current entity. Initializes the existing data and loads the new data                 output (vOpt, stringify, space)       Outputs the current entity as a serialized string                 read(obj, option)       Reads the given object as an entity. Follow JSON schema rules.                 readSchema (obj, createRow)       Reads the given schema object as the current entity                 readData(obj)       Reads only rows that exist on a given object                 write(vOpt)       Returns the current entity by converting it to an object of schema type                 writeSchema(vOpt)       Returns the schema of the current entity by converting it to an object of schema type                 writeData(vOpt)       Returns data from the current entity by converting it into schema-type objects.           Detailed description   Key Properties   viewName      This is the name of the meta view.    type viewName = string;   columns      Collection of columns in the view.    type columns = MetaTableColumnCollection;   rows      Data (low) collection of tables.    type rows = MetaRowCollection;   _baseEntity      Default entity.    type _baseEntity = BaseEntity;   _metaSet      This is the meta set to which the table belongs.    type _metaSet = MetaSet;   _guid      Unique identifier of the object (GUID). Uniquely identifies the object.    type _guid: string;   _type      The generator function of the object, which was used when the object was created.    type _type: Function;   Key Methods   clone()      Create and return a deep copy of the current object.    type clone() =&gt; MetaTable;     return : This is a replica of the current object.   copy()      Copy the target column.    type copy = ( \tfilter: (row, idx, entity) =&gt; boolean | string[], arguments&lt;string&gt;,  \tcols?: string[] | arguments&lt;string&gt; ) =&gt; MetaView;     filter :            Function type is the callback function that selects the column.       Type string[] is the name of the column to copy.           cols : The name of the column to copy, valid only if the filter is a Function type.   Example: Using filter, cols  var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows var temp = table.copy( \t(row, idx, entity) =&gt; { return (idx % 2) &gt; 0; }, \t['aa', 'bb'] );     Temp is copied only if the row indexes of the columns ‘aa’ and ‘bbb’ are odd.   Example: Using cols only  var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t['aa', 'bb'] );     Temp copies the entire row of columns ‘aa’ and ‘bbb’.   transformSchema()      Converts a given serialization object to a schema object.    type transformSchema = (oGuid: object) =&gt; object; // static     oGuid : object obtained by getObject().   clear()      Initializes all data in the entity.    type clear = () =&gt; void;   reset()      Initializes the entity’s columns and data.    type reset = () =&gt; void;   newRow()      Create and return a new row that matches the column structure.    type newRow = () =&gt; MetaRow;     return : This is the MetaRow object created.     getValue()       Returns the value of the &gt; column as a MetaRow type object.   type getValue = () =&gt; MetaRow;     return : MetaRow object with the value of the column set.   setValue()      Set the MetaRow value to the value in the column.    type setValue = (row: MetaRow) =&gt; void;     row : MetaRow object to be set.   merge()      Merges the given entity with the current entity.    type merge = (target: BaseEntity, option: number, matchType?: boolean) =&gt; void;     target : The target entity to merge.   option : Merge option.   matchType : Whether or not a row validation exists. (Default: false)   select()      Look up the row according to the given callback function.    type select = ( \tfilter: (row, idx, entity) =&gt; boolean | string[], | arguments&lt;string&gt;, \tcols?: string[] | arguments&lt;string&gt; ) =&gt; MetaView;     filter :            Function type is the callback function that selects the column.       Type string[] is the name of the column to copy.           cols : The name of the column to copy, valid only if the filter is a Function type.   Example: Using filter, cols  var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t(row, idx, entity) =&gt; { return (idx % 2) &gt; 0; }, \t['aa', 'bb'] );     The temp view is copied only if the row indexes of the columns ‘aa’, ‘bbb’ are odd.   Example: Using cols only  var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t['aa', 'bb'] );     The temp view copies the entire row of columns ‘aa’ and ‘bbb’.   load()      Imports the given object to the current entity, initializes the existing data and loads the new data.    type load = (obj: object | string, parse?: Function) =&gt; void;     obj : The object to be called.   pas : parser function. (Optional)   output()      Outputs the current entity as a serialized string.    type output = (vOpt: number, stringify?: Function, space?: string) =&gt; string;     vOpt : Optional (0, 1, 2)   stringify : This is a user-defined parser function. (Optional)   space : A blank string to be used in the output. (Optional)   read()      Reads the given object as an entity. Follow JSON schema rules.    type read = (obj: object, option: number) =&gt; void;     obj : object to be read.   option : Read option (default: 3)   var schema1 = {  \ttable: {  \t\tcolumns: {},  \t\trows: {}  \t} };  var schema1 = {  \tcolumns: {...},  \trows: {}  };   readSchema()      Reads the given schema object as the current entity.    type readSchema = (obj: object, createRow?: boolean) =&gt; void;     obj : Schema object to be read.   createRow : If true, add the column by row[0] (default: false)   readData()      Reads only rows that exist on a given object.    type readData = (obj: object) =&gt; void;     obj : The object to be read.   write()      Returns the current entity after converting it to an object of schema type.    type write = (vOpt?: number) =&gt; object;     vOpt : Optional (default: 0)   return : Object of schema type.   writeSchema()      Returns the schema of the current entity by converting it to an object of schema type.    type writeData = (vOpt?: number): object;     vOpt : Optional (default: 0)   return : Object of schema type.   writeData()      Returns the data of the current entity by converting it into an object of schema type.    type writeData = (vOpt?: number) =&gt; object;     vOpt : Optional (default: 0)   return : Object of schema type.   getObject()      Obtain the current object as a guide type object. (Circular references are replaced by $ref values.)    type getObject = (vOpt?: number, owned?: object | Array&lt;object&gt;) =&gt; object;     vOpt : Import option; default is 0.            opt=0: Reference structure (_guid:Yes, $ref:Yes)       opt=1: Redundant structure (_guid:Yes, $ref:Yes)       opt=2 : Non-tidal structure (_guid: No, $ref: No)           aged : The parent objects that currently own the object. The default is an empty object.   return —Returns serialized objects.   a.getObject(2) == b.getObject(2)   setObject()      Set the Guid type object to the current object. (The object will be reset.)    type setObject = (oGuid: object, origin?: object) =&gt; void;     oGuid : Object of the guid type to serialize.   origin : This is the original object that sets the current object. The default is oGuid.   equal()      Compare the current object with the specified object.    type equal (target: object) =&gt; boolean;     return —Returns whether the two objects are identical.   getTypes()      Returns the creators of the current object and all the creators of the prototype chain to the array.    type getTypes = () =&gt; Array&lt;Function&gt;;     return : Returns the array of generator functions.   const types = obj.getTypes(); console.log(types); // [Function: MetaObject]   instanceOf()      Verify that the current object is an instance of the specified type (including _UNION)    type instanceOf = (target: object | string) =&gt; boolean;     target : The type of object to be checked (object or string).   return —Returns whether this is an instance of the specified type.   ","url": "http://localhost:4000/docs/api-meta-view/"
  },{
    "title": "PropertyCollection Class",
    "excerpt":"the main structure   an inheritance relationship   Class diagram    a key element   Properties                  Item       Description                       count       Number of collection elements                 _owner       is the owner of the collection.                 _elemTypes       Type constraints for collection elements                 _list       List of collection elements.                 _guid       Unique identifier of the object (GUID). Uniquely identifies the object.                 _type       The generator function of the object. The function used when the object was created.                                     Method                  Item                               add(key, element, desc)       Add an element to the property collection                 Clear()       Initializes the property collection                 keyOf(idx)       Returns the key corresponding to the index of the property collection                 Exist(key)       Verify that the specified key exists in the property collection                 remove(element)       Delete an element in the collection                 removeAt(pos)       Deletes elements in the specified location from the collection                 contains(element)       Verify that the element exists in the collection                 indexOf (target, isKey)       Returns the index of the key or element specified in the property collection.                 getObject(vOpt, up)       Returns properties collection objects as serialized objects                 setObject(oGuid, origin)       Initializes property collection objects using serialized objects                 equal(target)       Compare the current object with the specified object.                 getTypes()       Returns the constructors of the current object and all the constructors of the prototype chain to the array.                 instanceOf(target)       Verify that the current object is an instance of the specified type (with _UNION)                                     Events                  Item       Description                       onAdd       Events that occur before adding collection elements                 OnAdded       Events that occur after adding collection elements                 onRemove       Events that occur before deleting collection elements                 OnRemoved       Events that occur after the collection element is deleted                 onClear       Events that occur before the collection is initialized                 OnCleared       Events that occur after the collection is initialized                 onChanging       Events that occur before changing collection elements                 OnChanged       Events that occur after changing the collection element                                     Detailed description   Key Properties   count      Returns the number of elements in the current collection.    readonly type count = number;   _owner      This is the object owned by the collection.    type _owner = object;   _elemTypes      Define the type constraints for the collection element.    type _elemTypes = any[];   _list      Array that stores the list of elements in the collection, which contains the actual data of the collection.    readonly type _list = any[];   _guid      Unique identifier of the object (GUID). Uniquely identifies the object.    type _guid = string;   _type      The generator function of the object, which was used when the object was created.    type _type = Function;   Key Methods   add()      Add an element to the property collection.    type add = (key: string, elem: any, desc?: PropertyDescriptor) =&gt; number;     key : The key of the key element.   element : The element to be added.   desc : Property descriptor object for element. Select value.   return : Index of the added element.     clear()          Initialize the property collection. This method initializes the array ‘$elements’, ‘$descriptors’, and ‘$keys’. Events are not initialized.    type clear = () =&gt; void;   myCollection.clear(); console.log(myCollection.count); // 0  keyOf()      Returns the key corresponding to the index of the property collection.    type keyOf = (idx: number) =&gt; string;     idx : Index value to look up.   return : The key corresponding to the index. If the index is out of range, it can return ‘undefined’.   const key = myCollection.keyOf(0); console.log(key for index 0: ${key}');   exist()      Verify that the specified key exists in the property collection.    type exist = (key: string) =&gt; boolean;     key - This is the key to check.   return —Bulian value indicating the presence or absence of a key.   remove()      Delete an element in the collection.    type remove = (elem: any) =&gt; number;     element : The element to be deleted.   return : Index of the deleted element.   const removedIndex = myCollection.remove(someElement); console.log(`Index of deleted element: ${removedIndex}`);   removeAt()      Deletes elements in the specified location from the collection.    type removeAt = (pos: number) =&gt; boolean;     pos : Index of the element to be deleted.   return : Bullion value that indicates whether element deletion is successful.   const success = myCollection.removeAt(0); console.log(`Delete element successful: ${success}`);   contains()      Verify that the element exists in the collection.    type contains = (elem) =&gt; boolean;     element : The element to be checked.   return : A Boolean value indicating the presence or absence of an element.   const exists = myCollection.contains(someElement); console.log(`element exists: ${exists}`);   indexOf()      Returns the index of the key or element specified in the property collection.    type indexOf = (target: any | string, isKey?: boolean) =&gt; number;     target : A key or element to look up the target. A string can be passed when viewed with a key.   isKey : A bullion value that determines whether to look up with a key. Default is ‘false’.   return : Index of the element. Returns ‘-1’ if the element does not exist.   const index = myCollection.indexOf(\"key1\", true); console.log(`Index of key: ${index}`);  Key Events   onAdd      Events that occur before adding an element to a collection.    type onAdd = (idx: number, elem: any, _this: object) =&gt; void;     idx : Index of the element to be added.   element : The element to be added.   _this : current collection object.   myCollection.onAdd = function(idx, elem, _this) { \tconsole.log(`Before adding elements: index ${idx}, element ${elem}`); };   onAdded      Events that occur after adding an element to a collection.    type onAdded = (idx: number, elem: any, _this: object) =&gt; void;     idx : Index of the added element.   element : Added element.   _this : current collection object.   myCollection.onAdded = function(idx, elem, _this) { \tconsole.log ('After adding elements: index ${idx}, element ${elem}'); };   onRemove      An event that occurs before an element is deleted from the collection.    type onRemove = (idx: number, elem: any, _this: object) =&gt; void;     idx : Index of the element to be deleted.   element : The element to be deleted.   _this : current collection object.   myCollection.onRemove = function(idx, elem, _this) { \tconsole.log(`Before element deletion: index ${idx}, element ${elem}`); };   onRemoved      Events that occur after you delete an element from the collection.    type onRemoved = (idx: number, elem: any, _this: object) =&gt; void;     idx : Index of deleted elements.   element : Deleted element.   _this : current collection object.   myCollection.onRemoved = function(idx, elem, _this) { \tconsole.log(`After element deletion: index ${idx}, element ${elem}`); };   onClear      Events that occur before the collection is initialized.    type onClear = (_this: object) =&gt; {};     _this : current collection object.   myCollection.onClear = function(_this) { \tconsole.log ('Before collection initialization); };  onCleared      Events that occur after the collection is initialized.    type onCleared = (_this: object)=&gt; {};     _this : current collection object.   myCollection.onCleared = function(_this) { \tconsole.log ('After collection initialization'); };   onChanging      Events that occur before you change the elements in the collection.    type onChanging = (idx: number, elem: any, _this: object) =&gt; void;     idx : Index of the element to be changed.   element : The element to be changed.   _this : current collection object.   myCollection.onChanging = function(idx, elem, _this) { \tconsole.log(`Before element change: index ${idx}, element ${elem}`); };   onChanged      Events that occur after you change the elements of the collection.    type onChanged = (idx: number, elem: any, _this: object) =&gt; void;     idx : Index of the changed element.   element : Changed element.   _this : current collection object.   myCollection.onChanged = function(idx, elem, _this) { \tconsole.log ('After element change: index ${idx}, element ${elem}'); };  ","url": "http://localhost:4000/docs/api-property-collection/"
  },{
    "title": "API Documentation",
    "excerpt":" ","url": "http://localhost:4000/docs/api/"
  },{
    "title": "Archive Layout with Content",
    "excerpt":"A variety of common markup showing how the theme styles them.   Header one   Header two   Header three   Header four   Header five   Header six   Blockquotes   Single line blockquote:      Stay hungry. Stay foolish.    Multi line blockquote with a cite reference:      People think focus means saying yes to the thing you’ve got to focus on. But that’s not what it means at all. It means saying no to the hundred other good ideas that there are. You have to pick carefully. I’m actually as proud of the things we haven’t done as the things I have done. Innovation is saying no to 1,000 things.    Steve Jobs — Apple Worldwide Developers’ Conference, 1997   Tables                  Employee       Salary                               John Doe       $1       Because that’s all Steve Jobs needed for a salary.                 Jane Doe       $100K       For all the blogging she does.                 Fred Bloggs       $100M       Pictures are worth a thousand words, right? So Jane × 1,000.                 Jane Bloggs       $100B       With hair like that?! Enough said.                          Header1       Header2       Header3                       cell1       cell2       cell3                 cell4       cell5       cell6                       cell1       cell2       cell3                 cell4       cell5       cell6                       Foot1       Foot2       Foot3           Definition Lists      Definition List Title   Definition list division.   Startup   A startup company or startup is a company or temporary organization designed to search for a repeatable and scalable business model.   #dowork   Coined by Rob Dyrdek and his personal body guard Christopher “Big Black” Boykins, “Do Work” works as a self motivator, to motivating your friends.   Do It Live   I’ll let Bill O’Reilly explain this one.   Unordered Lists (Nested)      List item one            List item one                    List item one           List item two           List item three           List item four                       List item two       List item three       List item four           List item two   List item three   List item four   Ordered List (Nested)      List item one            List item one                    List item one           List item two           List item three           List item four                       List item two       List item three       List item four           List item two   List item three   List item four   Buttons   Make any link standout more when applying the .btn class.   &lt;a href=\"#\" class=\"btn--success\"&gt;Success Button&lt;/a&gt;   Primary Button Success Button Warning Button Danger Button Info Button Inverse Button Light Outline Button   [Primary Button Text](#link){: .btn} [Success Button Text](#link){: .btn .btn--success} [Warning Button Text](#link){: .btn .btn--warning} [Danger Button Text](#link){: .btn .btn--danger} [Info Button Text](#link){: .btn .btn--info} [Inverse Button](#link){: .btn .btn--inverse} [Light Outline Button](#link){: .btn .btn--light-outline}   X-Large Button Large Button Default Button Small Button   [X-Large Button](#link){: .btn .btn--x-large} [Large Button](#link){: .btn .btn--large} [Default Button](#link){: .btn} [Small Button](#link){: .btn .btn--small}   Notices   Watch out! You can also add notices by appending {: .notice} to a paragraph.   HTML Tags   Address Tag      1 Infinite Loop  Cupertino, CA 95014  United States   Anchor Tag (aka. Link)   This is an example of a link.   Abbreviation Tag   The abbreviation CSS stands for “Cascading Style Sheets”.   Cite Tag   “Code is poetry.” —Automattic   Code Tag   You will learn later on in these tests that word-wrap: break-word; will be your best friend.   Strike Tag   This tag will let you strikeout text.   Emphasize Tag   The emphasize tag should italicize text.   Insert Tag   This tag should denote inserted text.   Keyboard Tag   This scarcely known tag emulates keyboard text, which is usually styled like the &lt;code&gt; tag.   Preformatted Tag   This tag styles large blocks of code.    .post-title {   margin: 0 0 5px;   font-weight: bold;   font-size: 38px;   line-height: 1.2;   and here's a line of some really, really, really, really long text, just to see how the PRE tag handles it and to find out how it overflows; }   Quote Tag   Developers, developers, developers… –Steve Ballmer   Strong Tag   This tag shows bold text.   Subscript Tag   Getting our science styling on with H2O, which should push the “2” down.   Superscript Tag   Still sticking with science and Albert Einstein’s E = MC2, which should lift the 2 up.   Variable Tag   This allows you to denote variables.  ","url": "http://localhost:4000/archive-layout-with-content/"
  },{
    "title": "Basic usage",
    "excerpt":"Create BindModel   Creating ‘BindModel’ objects is the first step for data binding and server-to-server communication.  This object serves as the key to managing AJAX communication with the server.   [[52. BindModel Class-B| - Reference: BindModel Configuration] [25. Service Object Configuration-C|-Refer to: Service Object Configuration]   var bm = new BindModel();  bm.url = '/user';     The ‘/user’ path is set as the default path to handle API requests related to the user’s information.   You can also set “url” for each “command”.   Add command   To add a new command to a BindModel object, use the addcommand() method, which creates a Bindcommand object and registers it with the BindModel to manage data communication with the server.   The Bindcommand object contains MetaView objects that play three key roles in data communication with the server.     valid: serves to validate the data.   bind: serves to bind the client’s data before it is passed to the server.   output : It is responsible for fetching data received from the server.                  [53. Bind Command Class-B       - Reference: Bind Command Configuration]           bm.addCommand('newCmd', 3);  // bm.command['newCmd'] === bm.cmd['newCmd'] // bm.command['newCmd'] instanceof BindCommand // bm.cmd['newCmd'].vallid instanceof MetaView // bm.cmd['newCmd'].bind instanceof MetaView // bm.cmd['newCmd'].output instanceof MetaView     It operates differently depending on output options (range: 0, 1, 2, 3)   You can access the ‘Bindcommand’ object with ‘bm.command[‘name’]’.   ‘bm.cmd[‘name’]’ refers to the same object, of which shorter ‘bm.cmd’ can be used as an alias.                  [24. Bind Command Configuration - C# Type of Output Option       - Reference: Type of Output Option]           Add column   The addColumn() method provides the ability to add a column to a BindModel object and set the column to the MetaView for the specified Bindcommand object. Additionally, you can use the addColumnValue() method to set the initial value of the column.   Example: Adding an Empty Column  bm.addColumn('aa', 'newCmd', 'valid'); bm.addColumn('bb', 'newCmd', ['valid', 'bind']); bm.addColumn('cc', 'newCmd', '$all');     Add a column with the name ‘aa’ and set it to the valid (MetaView) in cmd[‘newCmd’].   Add a column with the name ‘bbb’ and set it to ‘valid’, ‘bind’ in cmd [‘newCmd’].   Add a column with the name ‘cc’ and set it to the whole of the cmd [‘newCmd’] (‘valid’, ‘bind’, ‘output’).   Example: Adding a column as an initial value  bm.addColumnValue('aa', 100, 'newCmd', 'valid'); bm.addColumnValue('bb', 'B', 'newCmd', ['valid', 'bind']); bm.addColumnValue('cc', true, 'newCmd', '$all');     Add a column with the ‘aa’ name as the initial value of ‘100’ and set it to ‘valid’ in cmd[‘newCmd’].   Add a column with the initial value of ‘B’ under the name ‘bbb’ and set it to ‘valid’, ‘bind’ in cmd[‘newCmd’].   Add a column with the initial value of ‘true’ under the name ‘cc’ and set it throughout cmd[‘newCmd’].   Execute   The execute() method of the Bindcommand object handles three main steps: validation, data request, and data reception. Each step can be controlled through the callback function, which lets you manage the flow of requests in detail.   bm.command['newCmd'].execute();     There are three main steps when calling the execute() method.            Validation : Perform a validation of the ‘valid’ column, and call a ‘cbFail’ callback if it fails.       Data Binding: Request ‘bind’ to server path same as column.       Data Receipt : Gets received data as ‘output’.          ","url": "http://localhost:4000/docs/basic/"
  },{
    "title": "Configure Command",
    "excerpt":"‘Bindcommand’ is a bundle of associated ‘MetaView’ and works as an execute() method.   Key Features      Flow control: Flow control can be performed with a step-by-step callback function.   Add column: Add ‘HTML Column’ object (column reference value)   Response Management : Binds the server response to ‘MetaView’.   Validation : Validates with column constraint settings.     Key Properties       ‘outputOption’ : This is a method of calling output (MetaView) depending on the option.   ‘url’ : The path ‘axios.url’.   ‘config’ : ‘axios’ config object.   ‘valid’ : This is a validation ‘MetaView’.   ‘bind’ : This is the ‘MetaView’ request from the server.   ‘output’ : This is the server’s response ‘MetaView’.   ‘_outputs’ : A collection that controls ‘MetaView’ associated with the output.   ‘_Model’ : Point to ‘BindModel’ object (owner)   Callback (Properties)      ‘cbBegin’ : This is the callback function before the start.   ‘cbValid’ : Validation callback function.   ‘cbBind’ : This is the server request callback function.   ‘cbResult’ : This is the server response callback function.   ‘cbOutput’ : Output callback function.   ‘cbEnd’ : This is the callback function before termination.   Events      ‘onExecute’ : Invoke for the first time when executing execute().   ‘onExecuted’ : Last call when executing execute().        Key Methods       execute(): Execute the ‘Bindcommand’ object.   addColumn(): Add ‘HTMLColumn’ object.   addColumnValue(): Add ‘HTMLColumn’ object and set ‘value’ value.   setColumn(): Register the specified column as a reference in ‘MetaView’.   release() : Unreferences to the specified MetaView.   newOutput(): Add the response output ‘MetaView’ (_outputs)   removeOptput(): Remove the output ‘MetaView’ (_outputs)   Setting up a per-command server request   Request path by command   ‘url’ is the url path you request from the server. If there is no value, it will be replaced by ‘baseUrl’.   var bm = new BindModel();  bm.addCommand('cmdA'); bm.addCommand('cmdB');  bb.command['cmdA'].url = '/user/1'; bb.command['cmdB'].url = '/list';     command ‘cmdA’ and ‘cmdB’ have different paths.   Set dynamic url   Sometimes it is necessary to dynamically change the request path (url) depending on a specific command. It can be easily set up through the callback function of the BindModel object.   var idx = 1;  bb.command['cmdA'].cbBegin = function(cmd) { \t cmd.url = `/user/${idx}`;  };  Request configuration (axios)   Set the config of the axios for http communication. #TODO   Setting up events by command   Command-by-command event setting is a feature that allows you to perform various tasks by calling specific events when you execute the execute() method.   타입 : onExecute, onExecuted  // Event Type type onExecute = (model: BindModel, cmd: BindCommand) =&gt; void;  type onExecuted = (model: BindModel, cmd: BindCommand) =&gt; void;      onExecute : Called the first time the execute() method is executed.   onExecuted —Last called after the execute() method is executed.   These event types take the BindModel and Bindcommand objects as factors, allowing you to perform a variety of tasks.   var bm = new BindModel();  bm.addCommand('read'); // Global Event Settings bm.onExecute = function() {      console.log('model 에서 onExecute 호출'); }; bm.onExecuted = function() {      console.log('model 에서 onExecuted 호출'); }; // Command Event Settings bm.command['read'].onExecute = function() {      console.log('command 에서 onExecute 호출'); }; bm.command['read'].onExecuted = function() {      console.log('command 에서 onExecuted 호출'); }; // Execute bm.command['read'].execute();  // Output results: // Call onExecute from model // Call onExecute from command // Call onExecuted from command // Call onExecuted in model   Setting global and command-specific events allows you to process a variety of tasks in sequence when the execute() method is executed, which is useful for defining the initialization or subsequent actions required when certain tasks are executed.   To control flow by command   When executing the execute() method, callback functions are called sequentially to control the flow.  [[41. Callback Lifecycle-B|Refer to: Callback Lifecycle]   Callback function’s call order     cbBegin : URL and config information settings   cbValid : Validation   cbBind : Call before server request   Performing a server request   cbResult : Call after server response   cbOutput : Response processed with _outputs collection   cbEnd : Call after completion of the entire process   1. Callback at start   The first callback to be called upon execution().   Type: cbBegin  type cbBegin = (cmd: BindCommand) =&gt; void;   The general application plan is     Utilized for setting up information in url and config.   var bm = new BindModel(); // Add Commands bm.addCommand('list'); // Callback Settings bm.command['list'].cbBegin = (command) =&gt; {      command.url = '/member/1';  };  2. Validation callback   Callback called before validation for ‘valid(MetaView)’ when executing execute().  If the return value is false, a cbFail callback is called and execution is terminated. Type: cbValid  type cbValid = (valid: MetaView, cmd: BindCommand) =&gt; boolean;   The general application plan is     Used for inspection before requesting a server.   It is used to check the processing results from the user.   var bm = new BindModel(); // Add Commands bm.addCommand('list'); // Callback Settings bm.command['list'].cbValid = function(view) {  \treturn view.colums.count &lt;= 0  }; bm.command['list'].cbValid = function() { \treturn confirm ('Do you want to delete?') };   3. Server Request Callback   Callback called before sending the ‘bind(MetaView)’ column value when executing execute().   Type: cbBind  type cbBind = (view: MetaView, cmd: BindCommand, config: object) =&gt; void;   The general application plan is     Used to set the transport type. (encttype)   Utilized for integrated login-related settings.   Used for password encryption.   4. Server Response Callback   Callback called after receiving a response from the server when executing execute(). Type: cbResult  type cbResult = (data: object, cmd: BindCommand, res: object) =&gt; object;   The general application plan is     It is used to customize the responded data into a schema in the form of ‘MetaView’.   // data = { aa: 1, bb: 2 } bm.command['list'].cbResult = function(data) { \treturn = { \t\trows: data \t}; };     Return value: ‘{aa: 1, bb:2}’     5. Output callback       Callback called after the response is read into the ‘_outputs’ collection.   Depending on the ‘Bindcommand’ output option, the way data is imported into the ‘_outputs’ collection is different. [24. Bind Command Configuration - B# Type of Output Option (output) | Reference: Type of Output Option]   Type: cbOutput  type cbOutput = ( \tviews: MetaViewColleciton,  \tcmd: BindCommand,  \tres: object ) =&gt; void;   The general application plan is     It is utilized for screen (html) binding using the ‘output(MetaView)’ responded.   { \t\"rows\": [ \t\t{ \"u_name\": \"Neo\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Jane\", \"gender\", \"W\" }, \t] }   bm.command['list'].cbOutput = function(views) { \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(1, row['u_name'], row['gender']); \t} }; // Output results: // 0  Neo  M // 1  Jane  W  ‘views[0]’ is the same as ‘output’ of ‘Bindcommand’.   6. Callback at the end of the day   The last callback to be called when execute().   Type: cbEnd  type cbEnd = (status: number, cmd: BindCommand, res: object) =&gt; void;    The general application plan is     Use it to deliver success messages.   Utilizes for path redirection.   Utilizes the execute() chain connection of other commands.   bm.command['list'].cbEnd = function(views) { \talert('Normal processed') }   Each callback function is used to coordinate the behavior of commands in certain situations, or to pre-process and post-process data. This provides detailed control over the execution flow of Bindcommand.   Setting Output Options   Additional ‘MetaView’ can be specified in addition to the ‘MetaView’ provided in ‘Bindcommand’.   타입 : outputOption  type outputOption = { option: number, index: number }`;      The initial value of the object type is ‘outputOption = {option: 0, index: 0}.   The ‘option’ attribute is a method of fetching data from ‘output(MetaView)’ depending on the value.   The ‘index’ property specifies the location of the rows index when setting the value of the column. (Option: Used if 3)   ‘outOpt’ is an alias for ‘outputOptions’.   Configuration via Creator   You can set the output option parameter by passing it when you create an object.   var bm = new BindModel();  var bc1 = new BindCommand(bm, 1); var bc2 = new BindCommand(bm, { option: 1, index: 1 });     The value of ‘bc1.outputOption’ is ‘{option:1, index: 0}.   The value of ‘bc2.outputOption’ is ‘{option:1, index:1}’.   setting in addcommand()   The addcommand() method of the ‘BindModel’ object can deliver ‘outputOptions’ as parameters when created.   var bm = new BindModel();  bm.addCommand('read', 2); bm.addCommand('view', { option: 2, index: 1 });     bm.command['read'].outputOption value {option:2, index: 0}   bm.command['view'].outputOption vaule {option:2, index: 1}   Set to Property   It can be set by changing the ‘outputOption’ property of the ‘Bindcommand’ object.   bm.command['read'].outputOption = 3; bm.command['view'].outputOption = { option: 3, index: 1 };     bm.command['read'].outputOption value {option:3, index: 0}   bm.command['view'].outputOption value {option:3, index: 1}     Setting Validation Targets (valid)       ‘valid(MetaView)’ must be configured for validation. First, add the inspection object to the ‘valid.column’ collection and set the ‘required’ and ‘constraits’ properties.   Type: constructs (HTML Column property)  type RegExpType = {reg: RegExp, msg: string, return: boolean = true}; type FuncType = (value: any)=&gt;boolean; type ContiditionType = RegExpType | FuncType; type ConstrainstType = ContiditionType[] | ContiditionType;  const constraints: ConstrainstType[] | ConstrainstType;     required : indicates whether required; if true, the value ‘value’ is ‘blank, null’ will fail.   constructs : Inspects for constraints if the value is not blank or null.   • reg : regular expression to be matched.   • msg : If return is false depending on whether it matches or not, it is a failure message.       • If return is true, this is an error message when matching fails.       • If return is false, it is an error message when matching is successful.   • return : This is the return result for reg matching. The default is true.   Constraints by frequency of use   | FREQUIRED | required | constraits | Explanation| | —— | ———— | ————— | ————————— | | 50% || || Select value | 30% | true | | required value | 15% | | | {…} | Select value, value constrained | | 5% | True | {…} | Required value, value has constraints |  (Shopping mall table: based on 20ea)   var bm = new BindModel();  bm.addCommand('test');  bm.cmd['test'].addColumn('user_name'); bm.cmd['test'].addColumn('passwd'); bm.cmd['test'].addColumn('user_id'); bm.cmd['test'].addColumn('email');  bm.columns['user_name'].required = true; bm.columns['passwd'].required = true; bm.columns['user_id'].required = true;  bm.columns['passwd'].constraints = { \tregex: /.{6}/, msg: \"Please enter at least 6 characters.\" }; bm.columns['user_id'].constraints = [ \t(val)=&gt;{ reutrn val.length &gt; 8 },  \t{regex: /\\D{8}/, msg: \"Please type in English\", return: false} ]; bm.columns['email'].constraints = { \tregex: /.{6}/, msg: \"Please enter at least 6 characters.\" };  bm.cmd['test'].execute();     user_name : Mandatory condition. Failed to enter blank space. ‘cbFail’ will be called.   passwd : Required condition, successful only if it matches the regular expression condition.   user_id : prerequisite, successful in the first functional condition, and successful only when non-matching in the second regular expression condition.   email : Selection condition; successful if blank; successful if you enter a value must be matched with the regular expression.   To add a column   Adding a column adds the column to the default table ‘_baseTable’ and registers the reference to the ‘MetaView’ specified in the bind command. Methods of adding a column include addColumn() and addColumnValue().   타입 : addColumn(), addColumnValue()  type addColumn = ( \tcolName: string,  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;  type addColumnValue = ( \tcolName: string,  \tvalue: any,  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;     If you use the ‘$all’ indicator in the views parameter, it is added to all ‘MetaView (valid, bind, output).   The bTable parameter specifies the table to which the column is added, and the default is ‘_baseTable’.   Adding and mapping columns   Add a column to the base table and register a reference to the specified ‘MetaView’. The addColumn() method adds an empty column, and the addColumnValue() method sets the ‘value’ value after adding the column.   var bm = new BindModel();  bm.addCommand('test');  bm.command['test'].addColumn('aa', 'valid'); bm.command['test'].addColumn('bb', ['bind', 'output']); bm.command['test'].addColumn('cc', '$all'); bm.command['test'].addColumn('dd');  // bm['first'].columns.count  == 4 ('aa', 'bb', 'cc', 'dd')  // bm.command['test'].valid.columns.count  == 3 ('aa', 'cc', 'dd') // bm.command['test'].bind.columns.count   == 3 ('bb', 'cc', 'dd') // bm.command['test'].output.columns.count == 3 ('bb', 'cc', 'dd')     Invoking the addColumn() method adds an empty column.   Calling the addColumnValue() method sets the ‘value’ value after adding the column.   The ‘aa’ column registers a reference to the specified ‘MetaView (valid).   The ‘bb’ column registers a reference to the specified ‘MetaView (bind, output).   The ‘cc’ column registers a reference to the entire ‘MetaView (valid, bind, output).   If you omit the parameter when adding the ‘dd’ column, register the reference in the entire ‘MetaView’.   Adding and mapping columns to an extension table   Add a column to the specified ‘MetaTable’ and register a reference to the specified ‘MetaView’.   var bm = new BindModel();  bm.addTable('second'); bm.addCommand('test');  bm.command['test'].addColumn('aa', 'valid', bm.second); bm.command['test'].addColumn('bb', '$all', 'second');  // bm['first'].columns.count  == 0 // bm['second'].columns.count == 2 ('aa', 'bb')  // bm.command['test'].valid.columns.count  == 1 ('aa', 'bb') // bm.command['test'].bind.columns.count   == 1 ('bb') // bm.command['test'].output.columns.count == 1 ('bb')     The ‘aa’ column is added to the ‘MetaTable(second)’ and registers a reference to the specified ‘MetaView(valid).   The ‘bb’ column is added to ‘MetaTable(second)’ and the reference is registered in the entire ‘MetaView’.   You can use the above methods to add tables and columns in a variety of ways, and map each column to the appropriate ‘MetaView’, which is useful for efficiently handling data validation, binding, and output.   Setting Up an Existing Column   You can register or release an already registered column as a reference to ‘MetaView’, which allows you to dynamically manage the column to meet various requirements such as validation, binding, and output of data.   Key Features Summary     Column Settings: You can set a specific table’s column to the desired MetaView to process data validation, binding, and output.   Uncolumn: You can dynamically manage column references by releasing the set column from the desired MetaView.   타입 : setColumn(), release()  type TableNameType : string; type ColumnType : string; type FullColumnType : TableNameType + '.'+ ColumnType; type ColumnDotType : FullColumnType | ColumnType; type ViewType : 'valid' | 'bind' | 'output' | '$all' | string;  type setColumn = ( \tcolName: ColumnDotType,  \tviews: ViewType | ViewType[],  \tbTable?: string | MetaTable ) =&gt; void;  type release = ( \tcolName: string,  \tviews?: ViewType | ViewType[] ) =&gt; void;   Setting up and releasing columns   When setting up columns, you can specify columns for a specific table using the ‘Table Name + . + Column Name’ notation.   var bm = new BindModel(); bm.addTable('second');  // Add a column to the default table, first bm.addColumn('aa'); bm.addColumn('bb');  // Adding a column to the extension table, second bm['second'].columns.add('cc'); bm['second'].columns.add('dd');  bm.addCommand('test');  // Column Settings bm.command['test'].setColumn('aa', 'valid'); bm.command['test'].setColumn(['bb', 'second.cc'], 'bind'); bm.command['test'].setColumn('second.dd', '$all');  // Number of columns in the base table // bm.first.columns.count == 2 ('aa', 'bb') // Number of columns in the extension table // bm.second.columns.count == 2 ('cc', 'dd') // Number of columns in MetaView // bm.command['test'].valid.columns.count == 2 ('aa', 'dd') // bm.command['test'].bind.columns.count == 2 ('bb', 'dd') // bm.command['test'].output.columns.count == 2 ('cc', 'dd')  // Release the column bm.command['test'].release('aa', 'valid'); bm.command['test'].release(['bb', 'cc'], 'bind'); bm.command['test'].release('dd', '$all');  // Number of columns in MetaView // bm.command['test'].valid.columns.count == 0 // bm.command['test'].bind.columns.count == 0 // bm.command['test'].output.columns.count == 0     Add the ‘aa’ column and register the reference to the specified ‘MetaView (valid).   Add a ‘bb’ column and register a reference to the specified ‘MetaView(bind).   Add ‘cc’ column ‘MetaTable(second)’ and register the reference to the specified ‘MetaView(bind).   Add ‘dd’ column ‘MetaTable(second)’ and register a reference to the entire ‘MetaView’.   The above methods allow you to dynamically set up or release existing columns in MetaView, providing flexibility for complex data processing requirements.   Type of output option (output)   If response data is multiple records, import the data in the order of the ‘_outputs’ collection. To import multiple records, you must add a collection of ‘_outputs’ as many records as possible.  Records greater than ‘_outputs’ collections are excluded. (option &gt; 0)   | Options | Description | | ———– | ————————————————————— | | 0 (default) | output bind 안함                                                  | | 1 | Gets the row of all columns | 2 | Gets the row of existing columns | | 3 | Gets the row of existing columns and sets the row of index locations to column value |  Ignore output: option = 0   Does not import data to ‘output(MetaView)’. It is mainly used to modify data, such as create, update, delete, and is suitable when response data is not needed.  This option is mainly used when performing data change operations, and increases efficiency by minimizing data returns.   var bm = new BindModel(); // Add 'create' command and set output option to 0 to not get data bm.addCommand('create', 0); // Set a value in column 'aa' bm.cmd['create'].addColumnValue('aa', -10); // Execute a command bm.cmd['create'].execute();  // bm.columns.count == 1 // bm.columns['aa'].value == -10 // bm.cmd['create'].output.rows.count == 0   Import all data: option = 1   Option value 1 is a way to load all response data into ‘output(MetaView)’, which is useful for simply outputting a column of all data received from a server or for checking the data structure.   { \t\"rows\": [ \t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t] }   var bm = new BindModel();  // Add 'list' command and set output option to 1 to get all data bm.addCommand('list', 1);  bm.cmd['list'].execute();  // bm.columns.count == 3 // bm.cmd['list'].output.rows.count == 2 // bm.cmd['list'].output.rows[0]['aa'] == 10 // bm.cmd['list'].output.rows[0]['bb'] == 20 // bm.cmd['list'].output.rows[0]['cc'] == 30 // bm.cmd['list'].output.rows[1]['aa'] == 11 // bm.cmd['list'].output.rows[2]['bb'] == 21 // bm.cmd['list'].output.rows[3]['cc'] == 31     Even if the column is not predefined, it is dynamically generated based on response data.   This option is useful for checking the full structure of data received from the server, or for loading basic data for display and subsequent processing operations.   Import only data from the specified column: option = 2   From the response data, only columns existing in ‘output(MetaView)’ are imported.   { \t\"rows\": [ \t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t] }   var bm = new BindModel(); bm.addCommand('list', 2); bm.cmd['list'].addColumnValue('aa', 0); bm.cmd['list'].addColumnValue('bb', 0); bm.cmd['list'].execute();  // bm.columns.count == 2 // bm.cmd['list'].output.rows.count == 2 // bm.cmd['list'].output.rows[0]['aa'] == 10 // bm.cmd['list'].output.rows[0]['bb'] == 20 // bm.cmd['list'].output.rows[1]['aa'] == 11 // bm.cmd['list'].output.rows[2]['bb'] == 21   Set data to column value (specified column): option = 3   From the response data, only the column that exists in ‘output(MetaView)’ is imported, and the specified data is set to the value of the column ‘value’.   { \t\"rows\": { \"aa\": 10, \"bb\", 20, \"cc\": 30 }, }   var bm = new BindModel(); bm.addCommand('read', 3); bm.cmd['read'].addColumnValue('aa', 0); bm.cmd['read'].addColumnValue('bb', 0); bm.cmd['read'].execute();  // bm.columns.count == 2 // bm.columns['aa'].value == 10 // bm.columns['bb'].value == 20   Single Indexing (option: 3)   Sets the specific ‘rows’ value of the response data to the column ‘value’.   { \t\"rows\": [ \t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t] }   var bm = new BindModel(); bm.addCommand('test', 3); bc.outputOption.index = 1;   // index set bm.cmd['test'].addColumnValue('aa', 0); bm.cmd['test'].addColumnValue('bb', 0); bm.cmd['test'].execute();  // bm.columns.count == 2 // bm.columns['aa'].value == 11 // bm.columns['bb'].value == 21     The value of the second (index = 1) ‘rows’ is set to the value of ‘value’.   Specifying composite index (option: 3)   Sets a specific ‘rows’ value for multiple response data to the column ‘value’.   [ \t{ \t\t\"rows\": [ \t\t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t\t] \t}, \t{ \t\t\"rows\": [ \t\t\t{ \"dd\": 40, \"ee\", 50 }, \t\t\t{ \"dd\": 41, \"ee\", 51 }, \t\t\t{ \"dd\": 42, \"ee\", 52 }, \t\t] \t}, ]   var bm = new BindModel(); bm.addCommand('test', 3); bc.outputOption.index = [0, 1];   // index set bm.cmd['test'].newOutput('two'); bm.cmd['test'].addColumnValue('aa', 0); bm.cmd['test'].addColumnValue('bb', 0); bm.cmd['test'].addColumnValue('dd', 0); bm.cmd['test'].execute();  // bm.columns.count == 3 // bm.columns['aa'].value == 10 // bm.columns['bb'].value == 20 // bm.columns['dd'].value == 41 // bm.cmd['test'].output.rows.count == 2 // bm.cmd['test'].two.rows.count == 3     The value of index = 0 in the first response record was set to the value of the column (‘aa’, ‘bb’).   The value of index = 1 in the second response record was set to the value of column (‘dd’).     {   \"rows\": { \"aa\": 10, \"bb\", 20, \"cc\": 30 }, }           var bm = new BindModel(); bm.addCommand('read', 3); bm.cmd['read'].addColumnValue('aa', 0); bm.cmd['read'].addColumnValue('bb', 0); bm.cmd['read'].execute();  // bm.columns.count == 2 // bm.columns['aa'].value == 10 // bm.columns['bb'].value == 20   Single Indexing (option: 3)   Sets the specific ‘rows’ value of the response data to the column ‘value’.   { \t\"rows\": [ \t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t] }   var bm = new BindModel(); bm.addCommand('test', 3); bc.outputOption.index = 1;   // index set bm.cmd['test'].addColumnValue('aa', 0); bm.cmd['test'].addColumnValue('bb', 0); bm.cmd['test'].execute();  // bm.columns.count == 2 // bm.columns['aa'].value == 11 // bm.columns['bb'].value == 21     The value of the second (index = 1) ‘rows’ is set to the value of ‘value’.   Specifying composite index (option: 3)   Sets a specific ‘rows’ value for multiple response data to the column ‘value’.   [ \t{ \t\t\"rows\": [ \t\t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t\t] \t}, \t{ \t\t\"rows\": [ \t\t\t{ \"dd\": 40, \"ee\", 50 }, \t\t\t{ \"dd\": 41, \"ee\", 51 }, \t\t\t{ \"dd\": 42, \"ee\", 52 }, \t\t] \t}, ]   var bm = new BindModel(); bm.addCommand('test', 3); bc.outputOption.index = [0, 1];   // index set bm.cmd['test'].newOutput('two'); bm.cmd['test'].addColumnValue('aa', 0); bm.cmd['test'].addColumnValue('bb', 0); bm.cmd['test'].addColumnValue('dd', 0); bm.cmd['test'].execute();  // bm.columns.count == 3 // bm.columns['aa'].value == 10 // bm.columns['bb'].value == 20 // bm.columns['dd'].value == 41 // bm.cmd['test'].output.rows.count == 2 // bm.cmd['test'].two.rows.count == 3     The value of index = 0 in the first response record was set to the value of the column (‘aa’, ‘bb’).   The value of index = 1 in the second response record was set to the value of column (‘dd’).  ","url": "http://localhost:4000/docs/bind-commnad-config/"
  },{
    "title": "Configure BindModel",
    "excerpt":"‘BindModel’ is the core class of the framework, and its main functions include adding commands, adding columns, adding tables, and injecting service objects.   Key Features      Add command: Add ‘Bindcommand’ object.   Add Column: Add ‘HTML Column’ object.   Add Table: Add ‘MetaTable’ object.   Provides basic callback function—Provides a step-by-step basic callback function.   Inject service object: To construct ‘BindModel’ object by injecting service object.   Key Properties      ‘baseConfig’ : the config setting object of the default axios.   ‘url’ : Path to ‘baseConfig.url’.   ‘column’ : A collection that controls ‘HTML Column’.   ‘command’ : This is a collection that controls ‘Bindcommand’ (aka cmd)   ‘fn’ : A collection that controls user functions.   ‘items’ : A collection that controls the items. (Primary properties of the column)   ‘_tables’ : A collection that controls ‘MetaTable’.   ‘_baseTable’: Default table. (‘column’ = _baseTable.column)   Events      ‘onExecute’ : Commonly called when executing execute() for the first time.   ‘onExecuted’ : Commonly called last when executing execute().   Callback (Properties)      ‘cbBaseBegin’ : This is the default pre-start callback function.   ‘cbBaseValid’ : This is the default validation callback function.   ‘cbBaseBind’ : This is the default server request callback function.   ‘cbBaseResult’ : This is the default server response callback function.   ‘cbBaseOutput’ : Default output callback function.   ‘cbBaseEnd’ : This is the callback function before the default termination.     Key Methods       addcommand(): Create ‘Bindcommand’ object.   addTable(): Add ‘MetaTable’ object.   setService(): Construct the ‘BindModel’ object by injecting the service object.   checkSelector(): DOM validation with ‘selector’ object.   getSelector(): Gets the list of ‘selector’ objects.   addColumn(): Add ‘HTMLColumn’ object.   addColumnValue(): Add ‘HTMLColumn’ object and set ‘value’ value.   setMapping(): Map ‘HTMLColumn’ to ‘MetaView’ object in ‘Bindcommand’   init(): Run ‘preRegister’, ‘preCheck’, and ‘preRedy’ callback functions sequentially.   ‘BindModel’ is a multi-purpose framework that provides the flexibility to add and manage a variety of commands, tables, and columns. This document helps you understand the key features of this class and callbacks and use them effectively.   Setting up a server request   Default Request Path   The url attribute sets the default URL path that requests from the server. If you set the url path for the Bindcommand object, the url path for the BindModel is ignored.   var bm = new BindModel();  bm.url  = '/user';   Set dynamic url   If you need to dynamically change the request path according to a specific command, you can easily set up URLs using the callback function of the BindModel object.    var idx = 1;  bm.cbBegin = function(cmd) { \tcmd._model.url = `/user/${idx}`;  };     ‘cmd._model’ refers to the BindModel with Bindcommand.   Default Request Environment Settings (axios)   You can configure the request environment through the default settings in axios for HTTP communication.   var bm = new BindModel(); // Axios Preference Example bm.baseConfig.baseURL = 'https://api.example.com'; bm.baseConfig.timeout = 10000; // 10초 bm.baseConfig.headers.common['Authorization'] = 'Bearer YOUR_TOKEN'; bm.baseConfig.headers.post['Content-Type'] = 'application/json';     baseURL —Set the default URL to be common to all requests.   timeout : Sets the maximum wait time for a request.   headers —Set the default header to use on request; for example, you can set the authentication token or specify the type of content.   Setting up the Run Event   Global event that is called upon execution() of all commands. 타입 : onExecute, onExecuted  type onExecute = (model: BindModel, cmd: BindCommand) =&gt; void;  type onExecuted = (model: BindModel, cmd: BindCommand) =&gt; void;      The ‘onExecute’ event is called for the first time on all exec() runs.   The ‘onExecuted’ event is last called at all exec() runs.   var bm = new BindModel(); bm.addCommand('read'); // Global Event Settings bm.onExecute = () =&gt; {  \tconsole.log('model 에서 onExecute 호출') }; bm.onExecuted = () =&gt; {  \tconsole.log('model 에서 onExecuted 호출') }; // Execute bm.command['read'].execute();  // Output results: // Call onExecute from model // Call onExecuted in model  Handling errors and failures   error handling   Callback called upon all errors and exceptions. Type: cbError  type cbError = (msg: string, status: number, response: object) =&gt; void;   The cbError occurrence time is     Called in case of an axios error or ajax error related to a server request.   Called in case of all errors and exceptions.   var bm = new BindModel();  bm.cbError = function(msg, status, res) {  \tconsole.error('Err: '+ msg);  };     The default value of ‘cbError’ is provided at the time of object creation.     Dealing with Failure       Processes logical failure messages (mainly used in the event of a validation failure) Type: cbFail  type cbFail = (msg: string, valid: MetaView) =&gt; void;   When “cbFail” occurred, the execute() method was executed     Called when the ‘valid(MetaView)’ validation fails.   Called when a false return is made from the ‘cbValid’ / ‘cbBaseValid’ callback function.   var bm = new BindModel();  bm.cbFail = function(msg, valid) {  \tconsole.warn ('Failed. Err:'+ msg);  };     The default value of ‘cbFail’ is provided at the time of object creation.   Flow control (hooking)   When execute(), the callback function can be called sequentially to control the flow.                  [[41. Callback Lifecycle-B       Refer to: Callback Lifecycle]           1. Callback at base start   The first callback to be called upon execution(). Target ‘cbBegin’ has higher priority than callback ‘cbBaseBegin’. Type: cbBase Begin  type cbBaseBegin = (cmd: BindCommand) =&gt; void;   The general application plan is     Utilized for setting common information in url and config.   var bm = new BindModel();  bm.cbBaseBegin = function(cmd) { \tcmd.url = '/member/1'; };  2. Basic Validation Callback   Callback called before validation for ‘valid(MetaView)’ when executing execute(). Destination ‘cbValid’ has higher priority than callback ‘cbBaseValid’. If the return value is false, the callback ‘cbFail’ is called and terminated. Type: cbBaseValid  type cbBaseValid = (valid: MetaView, cmd: BindCommand) =&gt; boolean;   The general application plan is     Used for inspection before requesting a server.   It is used to check the processing results from the user.   var bm = new BindModel();  bm.cbBaseValid = function(view, cmd) {  \treturn view.colums.count &lt;= 0; }; bm.cbBaseValid = function(view, cmd) { \treturn confirm ('Do you want to delete?'); };   3. Default Server Request Callback   Callback called before sending the ‘bind(MetaView)’ column value when executing execute(). Target ‘cbBind’ has higher priority than callback ‘cbBaseBind’.   Type: cbBaseBind  type cbBaseBind = (view: MetaView, cmd: BindCommand, config: object) =&gt; void;   The general application plan is     Used to set the transport type. (encttype)   Utilized for integrated login-related settings.   Used for password encryption.   4. Default Server Response Callback   Callback called after receiving a response from the server when executing execute(). Destination ‘cbResult’ has higher priority than callback ‘cbBaseResult’. 타입 : cbBaseResult  type cbBaseResult = (data: object, cmd: BindCommand, res: object) =&gt; object;   The general application plan is     It is used to change the responded data to a schema in the form of ‘MetaView’.   var bm = new BindModel(); // data = { aa: 1, bb: 2 } bm.cbBaseResult = function(data) { \treturn { \t\trows: data \t}; };     Return value: ‘{aa: 1, bb:2}’   5. Default Output Callback   Callback called after the response is read into the _outputs collection. Destination ‘cbOutput’ has higher priority than callback ‘cbBaseOutput’. Depending on the ‘Bindcommand’ output option, the data and the ‘_outputs’ collection are imported differently.                  [24. Bind Command Configuration - C# Type of Output Option (output)       Reference: Type of Output Option]           타입 : cbBaseOutput  type cbBaseOutput = (views: MetaViewColleciton, cmd: BindCommand, res: object) =&gt; void;    The general application plan is     It is utilized for screen (html) binding using the ‘output(MetaView)’ responded.   { \t\"rows\": [ \t\t{ \"u_name\": \"Hong Gildong\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Sungchunhyang\", \"gender\", \"W\" }, \t] }   var bm = new BindModel();  bm.cbBaseOutput = function(views) { \t// views[0] instanceof MetaView \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(i, row['u_name'], row['gender']); \t} } // 0 Hong Gil-dong M // 1. Sung Chunhyang W   [[42. Multi-view (output)-C | Reference: Multi-view (output)]  6. Callback at Default Termination   The last callback to be called when execute(). Target ‘cbEnd’ has higher priority than callback ‘cbBaseEnd’.   Type: cbBaseEnd  type cbBaseEnd = (status: number, cmd: BindCommand, res: object) =&gt; void;    The general application plan is     Use it to deliver success messages.   Utilizes for path redirection.   Use to link the execute() chain of other commands.   var bm = new BindModel();  bm.cbBaseEnd = function(views) { \talert('Normal Processed'); };   To add a command   Create a ‘Bindcommand’ object by invoking the addcommand() method. The ‘Bindcommand’ object is the processing unit of the bound model and contains the ‘MetaView’ of the ‘valid’, ‘bind’, and ‘output’ attributes.   Type: addcommand()  function addCommand(cmdName: string, outOpt?: number = 0, bTable?: string | MetaTable): BindCommand;     Specify the alias for ‘Bindcommand’ of ‘cmdName’ and add it as an output option. (Default outOpt = 0)   If bTable is specified, ‘_baseTable’ of the added ‘Bindcommand’ is set.   var bm = new BindModel();  bm.addCommand('create'); bm.addCommand('read', 3);  // bm.command['create'] instanceof BindCommand // bm.command['read'] instanceof BindCommand // bm.command['create'].outputOption == 0  // bm.command['read'].outputOption == 3      The default value for outOpt is ‘0’.   The ‘Bindcommand’ object you added can be accessed by the ‘command’ collection.   ‘command’ provides a ‘cmd’ alias.   Example: Specify the Default Table  var bm = new BindModel();  bm.addTable('second');  bm.addCommand('list', 1, 'second'); bm.addCommand('edit', 3, bm.second);  // bm.command['list']._baseTable === bm.second // bm.command['edit']._baseTable === bm.second     If ‘MetaTable’ is specified when ‘Bind Command’ is added, ‘baseTable’ is set for all ‘MetaView’.   To add a column   Add a column.   타입 : addColumn(), addColumnValue()  type addColumn = ( \tcolName: string,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;  type addColumnValue = ( \tcolName: string,  \tvalue: any,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;     omitting cmds, views adds columns to the base table.   If you specify cmds and views, the reference is registered in MetaView in ‘command’.   If you use the ‘$all’ indicator in the cmds parameter, it is added to all ‘command’.   ‘views[0]’ is the same as ‘output’ of ‘Bindcommand’.   Add Column   Add a column to the main table (_baseTable).   var bm = new BindModel(); // Add Column bm.addColumn('aa'); bm.addColumnValue('bb', 'man');  // bm.columns['aa'].value  == '' // bm.columns['bb'].value  == 'man' // bm._baseTable === bm._tables['first'] === bm._tables[0] === bm.first     A column named ‘aaa’ is added by invoking the addColumn() method.   The addColumnValue() method is called to add a column named ‘bbb’ and the value ‘man’ is set.   You can add ‘bTable’ to the specified ‘MetaTable’ column. (Default: ‘_baseTable’)     Adding and mapping columns       Add a column to the base table and map it to the target ‘Bindcommand’.   var bm = new BindModel(); // command generation  bm.addCommand('cmd1'); bm.addCommand('cmd2'); bm.addCommand('cmd3'); // Add Column bm.addColumn('aa', 'cmd1'); bm.addColumn('bb', ['cmd2', 'cmd3'], ['valid', 'bind']); bm.addColumn('cc', '$all', 'output');  // bm['first'].columns.count  == 3 ('aa', 'bb', 'cc')  // bm.command['cmd1'].valid.columns.count  == 1 ('aa') // bm.command['cmd1'].bind.columns.count   == 1 ('aa') // bm.command['cmd1'].output.columns.count == 2 ('aa', 'cc')  // bm.command['cmd2'].valid.columns.count  == 1 ('bb') // bm.command['cmd2'].bind.columns.count   == 1 ('bb') // bm.command['cmd2'].output.columns.count == 1 ('cc')  // bm.command['cmd3'].valid.columns.count  == 1 ('bb') // bm.command['cmd3'].bind.columns.count   == 1 ('bb') // bm.command['cmd3'].output.columns.count == 1 ('cc')     Add ‘Bindcommand’ with the name specified by the addcommand() method.   The column named ‘aaa’ is mapped to all ‘MetaView’ in the specified (cmd1).   The column named ‘bbb’ maps to the specified (cmd2, cmd3) ‘MetaView (valid, bind’   Columns named ‘cc’ are mapped to the ‘MetaView (output)’ of the whole (cmd1, cmd2, cmd3).   Adding and mapping columns to tables you have added   Add a column to the specified ‘MetaTable’ and map it to the target ‘Bind Command’.   var bm = new BindModel(); // Adding Tables and Commands bm.addTable('second'); bm.addCommand('cmd1'); // Adding and mapping columns bm.addColumn('aa', 'cmd1', 'valid'); bm.addColumn('bb', 'cmd1', 'bind', 'second');  // bm['first'].columns.count  == 1 ('aa') // bm['second'].columns.count == 1 ('bb')  // bm.command['cmd1'].valid.columns.count  == 1 ('aa') // bm.command['cmd1'].bind.columns.count   == 1 ('bb') // bm.command['cmd1'].output.columns.count == 0     As an addTable() method, add ‘MetaTable’ to the ‘_tables’ collection.   Add ‘Bindcommand’ with the name specified by the addcommand() method.   Columns named ‘aaa’ are added to the base table and mapped to the specified ‘MetaView (valid).   The column named ‘bbb’ is added to ‘second(MetaTable)’ and mapped to the specified ‘MetaView(bind).     Add Column       Add a column to the main table (_baseTable).   var bm = new BindModel(); // Add Column bm.addColumn('aa'); bm.addColumnValue('bb', 'man');  // bm.columns['aa'].value  == '' // bm.columns['bb'].value  == 'man' // bm._baseTable === bm._tables['first'] === bm._tables[0] === bm.first     A column named ‘aaa’ is added by invoking the addColumn() method.   The addColumnValue() method is called to add a column named ‘bbb’ and the value ‘man’ is set.   You can add ‘bTable’ to the specified ‘MetaTable’ column. (Default: ‘_baseTable’)     Adding and mapping columns       Add a column to the base table and map it to the target ‘Bindcommand’.   var bm = new BindModel(); // command generation  bm.addCommand('cmd1'); bm.addCommand('cmd2'); bm.addCommand('cmd3'); // Add Column bm.addColumn('aa', 'cmd1'); bm.addColumn('bb', ['cmd2', 'cmd3'], ['valid', 'bind']); bm.addColumn('cc', '$all', 'output');  // bm['first'].columns.count  == 3 ('aa', 'bb', 'cc')  // bm.command['cmd1'].valid.columns.count  == 1 ('aa') // bm.command['cmd1'].bind.columns.count   == 1 ('aa') // bm.command['cmd1'].output.columns.count == 2 ('aa', 'cc')  // bm.command['cmd2'].valid.columns.count  == 1 ('bb') // bm.command['cmd2'].bind.columns.count   == 1 ('bb') // bm.command['cmd2'].output.columns.count == 1 ('cc')  // bm.command['cmd3'].valid.columns.count  == 1 ('bb') // bm.command['cmd3'].bind.columns.count   == 1 ('bb') // bm.command['cmd3'].output.columns.count == 1 ('cc')     Add ‘Bindcommand’ with the name specified by the addcommand() method.   The column named ‘aaa’ is mapped to all ‘MetaView’ in the specified (cmd1).   The column named ‘bbb’ maps to the specified (cmd2, cmd3) ‘MetaView (valid, bind’   Columns named ‘cc’ are mapped to the ‘MetaView (output)’ of the whole (cmd1, cmd2, cmd3).   Adding and mapping columns to tables you have added   Add a column to the specified ‘MetaTable’ and map it to the target ‘Bind Command’.   var bm = new BindModel(); // Adding Tables and Commands bm.addTable('second'); bm.addCommand('cmd1'); // Adding and mapping columns bm.addColumn('aa', 'cmd1', 'valid'); bm.addColumn('bb', 'cmd1', 'bind', 'second');  // bm['first'].columns.count  == 1 ('aa') // bm['second'].columns.count == 1 ('bb')  // bm.command['cmd1'].valid.columns.count  == 1 ('aa') // bm.command['cmd1'].bind.columns.count   == 1 ('bb') // bm.command['cmd1'].output.columns.count == 0     As an addTable() method, add ‘MetaTable’ to the ‘_tables’ collection.   Add ‘Bindcommand’ with the name specified by the addcommand() method.   Columns named ‘aa’ are added to the base table and mapped to the specified ‘MetaView (valid).   The column named ‘bb’ is added to ‘second(MetaTable)’ and mapped to the specified ‘MetaView(bind).   To add a table   Add ‘MetaTable’ as an addTable() method.   Type: addTable()  type addTable (tableName: string) =&gt; MetaTable;   The general application plan is     Utilizes changes to the default table.   Use to create tables to change _baseTable.   Use when designating as a reference table for ‘MetaView’ in ‘command’.   var bm = new BindModel(); // step A bm.addTable('second'); bm.addTable('three'); // step B bm._baseTable = bm.second;  // baseTable 설정 bm.addColumn('aa'); // step C bm.addCommand('cmd1', 0, 'three'); bm.command['cmd1'].addColumn('bb');  // bm['first'] === bm._tables['first'] === bm._tables[0] // bm['second'] === bm._tables['second'] // bm['three'] === bm._tables['three']  // bm['first'].columns.count  == 0 // bm['second'].columns.count == 1 ('aa') // bm['three'].columns.count  == 1 ('bb')  // bm.command['cmd1']._baseTable === bm.second  // bm.command['cmd1'].valid.columns.count  == 1 ('bb') // bm.command['cmd1'].bind.columns.count   == 1 ('bb') // bm.command['cmd1'].output.columns.count == 1 ('bb')     A: ‘MetaTable’ is added to the ‘_tables’ collection and ‘BindModel’ objects in the addTable() method.   B: We changed the base table to ‘second(MetaTable)’ by specifying ‘_baseTable’.   C: The addcommand() method designated ‘_baseTable’ of ‘cmd1’ as ‘three’.   Setting global items (global column)   ‘items’ has raw information from the column.   The general application plan is     When injecting service objects into ‘BindModel’, it is used to manage the global information of the column.   Utilizes a column when it is shared across multiple tables.   It is a ‘selector’ attribute and is used for DOM validation.   Add Item   As a way to add items, you can add them from the items collection and from the service object.   [25. Service Object Configuration - C# Item Area Configuration | Refer to: Service Object Configuration] Type: items.add()  type ColumnType = { \tselector: SelectorType, \tgetter: ()=&gt;any, \tsetter: (val)=&gt;any, \tgetFilter: ()=&gt;any, \tsetFilter: (val)=&gt;any, \tdefault: stirng | number | boolean | null, // 기본값 \tvalue: any, \talias: string, \tcaption: string, \tconstraints: ConstrainstType,  // 제약조건 \trequired: boolean | false, // required }; type ValueType = string | number | boolean | ColumnType;  // items.add() type add = (itemName: string, iType: ValueType) =&gt; void;   var bm = new BindModel(); // Add Item bm.items.add('col1', 1); bm.items.add('col2', ''); bm.items.add('col3', { columnName: 'newCol3'}); bm.items.add('col4', {selector: { key:'#ID', type: 'value'}}); // Create as item column bm._readItem();     Add to the item named ‘col1’ and set the value ‘{value:1}’.   Add to the item named ‘col2’ and set the value ‘{value: ‘}’.   Add to the item named ‘col3’ and set the value ‘{columnName: ‘newCol3’}..   Add to the item named ‘col4’ and set the value ‘{selector: {key:’#ID’, type: ‘value’}’   Calling the _readItem() method creates an item as a column in the default table.   Item Validation   The checkSelector() method allows you to check whether the DOM of the selector property in the items collection is valid. 타입 : checkSelector()  type checkSelector = ( \tcollection?: PropertyCollection = this.items,  \tisLog: boolean = false ) =&gt; string[];     The default value of the ‘collection’ parameter is the collection of ‘this.items’.   ‘collection’ can be designated as items, columns, ‘[table name]’.column, ‘valid.column’, ‘bind.column’, and ‘output.column’.   If you set isLog = true, the ‘key’ value of the failed ‘selector’ is displayed in the console window.   var bm = new BindModel(); // Add Item bm.items.add('item1', {selector: { key:'#user_name', type: 'value'}}); bm.items.add('item2', {selector: { key:'.sub_name', type: 'text'}}); bm.items.add('item3', {selector: { key:'input[name=gender]', type: 'none'}}); // Selector Examination bm.checkSelector(); // Empty Array Check Successful     The checkSelector() method checks whether the ‘selector’ value of ‘items’ is valid.   The preCheck callback function automatically handles DOM validation when injecting service objects. [25. Service Object Configuration-C | Reference: Service Object Configuration]   var bm = new BindModel();  bm.columns.add('item1', {selector: { key:'#user_name', type: 'value'}}); bm.columns.add('item2', {selector: { key:'.sub_name', type: 'text'}}); bm.columns.add('item3', {selector: { key:'input[name=gender]', type: 'none'}});  bm.checkSelector (bm.column, true); // List of failed selector objects     Examine the DOM for the presence of the element. &lt; ... id=\"user_name\"&gt;, \\&lt; ... class=\"sub_name\"&gt;, \\&lt;input name=\"gender\"... &gt;   To look up the selector (selector)   Obtain a list of ‘selectors’ in the ‘items’ collection. Type: getSelector()  type KeyType = 'none' | 'value' | 'text' | 'html' | 'prop' | 'attr' | 'css'; type SelectorType = { key: string, type: KeyType };  type getSelector = ( \tcollection?: PropertyCollection = this.items ) =&gt; SelectorType[];     The default for the ‘collection’ parameter is this.items collection.   var bm = new BindModel();  bm.columns.add('item1', {selector: {key:'#ID1', type: 'value'}}); bm.columns.add('item2', {selector: {key:'#ID2', type: 'text'}});  bm.getSelector(); // [{key:'#ID1', type: 'value'}, {key:'#ID2', type: 'text'}]     You can obtain a list of ‘selectors’ for the specified collection.   ","url": "http://localhost:4000/docs/bind-model-config/"
  },{
    "title": "Callback Lifecycle",
    "excerpt":"execute() Lifecycle         The ‘onExecute’ event is the first event to be called when the execute() method is executed.   ‘cbBegin’ callback is called for the first time; it is used to set the initial value.   Callback ‘cbValid’ is called before validation for validation of valid (MetaView).  Utilization: Use for confirm() before deletion, user validation   Validates columns of validation (MetaView).column.valid(value)   The cbFail callback handles logical failures.   ‘cbBind’ callback controls the http transfer style for special processing (image, integrated login)   bind (MetaView) requests bind.columns from the http server.   The ‘cbResult’ callback is used for processing response results.   Binds data and values to output (MetaView) according to outputOptions.   The ‘cbOutput’ callback performs output-related processing, such as html, as a response result or output.   Callback ‘cbError’ is called when an error or exception occurs after cbBind.   Callback ‘cbEnd’ is called last. Utilization: redirect, success message, other command.example() chain connection   The ‘onExecuted’ event is the last event called when the execute() method is executed.  ","url": "http://localhost:4000/docs/callback-lifecycle/"
  },{
    "title": "Posts by Category",
    "excerpt":" ","url": "http://localhost:4000/categories/"
  },{
    "title": "Core concept",
    "excerpt":"The core of BindModel is a combination of MetaTable and MetaView, which are important components of BindModel’s functionality and are designed to minimize duplication and accommodate different cases in real-world projects.   MetaTable Class   The MetaTable class easily represents data in a table format and provides a variety of features. The class offers features similar to DataTable in .NET, which is familiar to .NET experiences. MetaTable has two main attributes (columns and rows) that manage columns and rows to efficiently process data.                  [55. MetaTable Class-B       - Reference: MetaTable Class]           MetaTable.column property (collection)   The ‘column’ collection of ‘MetaTable’ provides additional/removal of columns. This collection defines the table structure, and each column has its own key (column name) and index. This allows easy access to the column.   var table1 = new MetaTabe('t1');  table1.columns.add('age'); table1.columns.add('gender');  // Access to a column // table1.columns['age'] === table1.columns[0] // table1.columns['gender'] === table1.columns[1] // table1.colmmns.count === 2   Constraints  You cannot add or remove columns from the columns collection after MetaRow has been added to the rows collection in MetaTable. This is a constraint to maintain data consistency. The column definition must be completed before data can be inserted.   MetaTable.rows Properties (Collection)   Therows property of MetaTable is a collection that allows you to add or remove data (MetaRow). New rows are created through the newRow() method, and the created MetaRow objects can be added to therows collection.   var table1 = new MetaTabe('t1'); var row = table1.newRow();  row['age'] = 20; row['gender'] = 'man';  table1.rows.add(row);  // Access to data // row.count == 2 // table1.rows[0]['age'] == 20 // table1.rows[0]['gender'] == 'man' // table1.rows.count == 1     MetaRow, added to the rows collection, provides a continuous index.   MetaView Class   The MetaView class performs a similar role to MetaTable, but an important difference is that, instead of adding columns directly to MetaView’s columns collection, you can add them through references. This allows MetaView to define and leverage different views based on existing data structures.                  [56. MetaView Class-B       Reference       -Reference: MetaView Class]           Register a full column as a reference column   Once you have set the _baseEntity property for MetaView, the column is actually added to _baseEntity and only the reference value is registered for MetaView, which allows you to define and use separate views while still taking advantage of the structure of the existing table.   var table1 = new MetaTabe('t1'); var view1 = new MetaView('v1', table1);  view1.columns.add('age'); view1.columns.add('gender');  // table1.colmmns.count === 2 // view1.colmmns.count === 2 // view1.columns['age'] === table1.columns['age'] // view1.columns['gender'] === table1.columns['gender']     If a collection of existing column names exists when adding columns, register the reference value.   Register an individual column as a reference column   MetaView can register only certain columns as reference values in _baseEntity, which allows MetaView to selectively reference and use only certain data that is required.   var table1 = new MetaTabe('t1'); var view1 = new MetaView('v1');  view1.columns.add('age'); view1.columns.add('gender', table1);  // table1.colmmns.count === 1 // view1.colmmns.count === 2 // view1.columns['gender'] === table1.columns['gender']     If the target ‘_baseEntity’ is ‘MetaView’, it follows the cycle rule.   HTML Column Classes   HTMLColumn is a child class of MetaColumn that provides the ability to associate HTML elements with data. In particular, the value attribute allows you to manage the current value of the column, and various properties allow you to flexibly control the setting and query of values. HTMLColumn’s main properties include selector, setter/getter, and setFilter/getFilter.                  [54. HTML Column Class-B       - Reference: Column Configuration]           Set column value in MetaRow   You can use the setValue() method to import data from the MetaRow object and set it to the value in the column.   var table1 = new MetaTabe('t1'); var row = table1.newRow();  row['age'] = 30; row['gender'] = 'man';  tables.setValue(row);  // table1.columns['age'].value == 30 // table1.columns['gender'].value == 'man'   Import value of column to MetaRow   You can use the getValue() method to return the value value of the column to the MetaRow type.   var table1 = new MetaTabe('t1');  table1.columns['age'].value = 40; table1.columns['gender'].value = 'man';  var row = tables.getValue();  // row['age'].value == 40 // row['gender'].value == 'man'   Inquire the value of a column   When querying HTML Column’s value value, one value is selected and returned according to the set priority.   Priorities     getter return value: If getter is set, this value is returned to the highest priority.   getFilter return value: If getFilter is set, the selector value is passed to the parameter and the processed value is returned.   selector lookup value: The value is returned depending on the type set in the selector (text, value, attr, prop, html).   Internal value: If there are no getter, getFilter, or selector settings, the values stored inside will be returned.   default value: If none of the above settings are present and the initial value is Empty, the default is returned.  (Initial value is null or empty string)                  [54. HTML Column Class-B#getter Internal Structure       - Reference: getter Internal Structure]           Example: When setting getter  column.getter = function(sVal) { \treturn 'user value'; };  // column.value == 'user value'   Example: When setting up getFilter  column.getFilter = function(sVal) { \treturn $('input[name=type_cd]:checked').val(); // Blue };  // column.value == 'Blue'   Example: When setting up getFilter and selector  column.selector = { key: '#u_name', type: 'value' }; // Cat column.getFilter = function(sVal) { \treturn $('input[name=type_cd]:checked').val() +'-'+ sVal; // Blue };  // column.value == 'Blue-Cat'     The value of the selector is transmitted to the getFilter, and it is transmitted after processing in the getFilter.   Example: When setting up selector  column.selector = { key: '#u_name', type: 'value' };   Refer to  getter and getFilter play similar roles, but there is a difference. getter is used to return a single set, and getFilter is responsible for setting or processing values for several HTML elements based on internal values (original values).   Set value for column   When setting the value of HTML Column, save and pass the value in the order set. The setup procedure is as follows.   Setting Order     setter: The value you want to set is saved first.   Internal: If the setter has a return value, save the set value, and if there is no return value, store the set value internally.   setFilter: Set the value by passing the internal value as a parameter.   selector: Set the setFilter return value if there is no return value, and set the internal value if there is no return value.                  [54. HTML Column Class-B#setter Internal Structure       - Reference: setter Internal Structure]           Example: When setting only the setter  var temp;  column.setter = function(val) { \ttemp = val; };  column.value = 'user value'; // temp == 'user value' // column.$value == 'user value'   Example: Set up setter and setFilter  var temp;  column.setter = function(val) { \ttemp = val * 10; }; column.setFilter = function(val) { \t$('input[name=active_yn][value='+ val + ']').prop('checked', true); };  column.value = 2; // temp == 20 // &lt;input type=\"checkbox\" name=\"action_yn\" value=\"2\"/&gt; // column.$value == 2     The parameter in setFilter is setter carries a return value, and if there is no return value, it carries an internal value.   Example: When setting the setter and selector  column.setter = function(val) { \treturn temp = val * 10; }; column.selector = { key: '#u_name', type: 'value' }; // Cat  column.value = 2; // temp == 20 // &lt;input type=\"text\" name=\"u_name\" value=\"20\"/&gt; // column.$value == 20     The setter return value is stored in the internal value as the return value.   The selector’s value is set to an internal value.   Example: When setting selector only  column.selector = { key: '#u_name', type: 'value' };  column.value = 2; // &lt;input type=\"text\" name=\"u_name\" value=\"2\"/&gt; // column.$value == 2   Refer to  setter and setFilter play similar roles, but there is a difference. setter is used to set a single value, and setFilter is responsible for setting or processing the values of several HTML elements based on the internal value (original value). For example, when expressing a unit of currency, if the internal value is 1000, the screen outputs ‘1000’.   Understanding the BindModel Structure   BindModel automatically creates one MetaTable (name first), and each Bindcommand object added within this structure contains three MetaViews (valid, bind, and output).                  [[52. BindModel class-B#Main structure       - Reference: BindModel’s main structure]                 [53. Bind Command Class-B#Main Structure       - Reference: BindComand Main Structure]           Summary of BindModel’s Entities’ Structures   Here is the code that summarizes BindModel’s internal entity structure (MetaTable, MetaView):   function createCommand(baseTable) { \treturn { \t\tvalid: new MetaView('valid', baseTable), \t\tbind: new MetaView('bind', baseTable), \t\toutput: new MetaView('output', baseTable) \t}; }  var table1 = new MetaTabe('first'); var cmd1 = createCommand(table1);  cmd1.bind.columns.add('aa'); cmd1.output.columns.add('bb');  // table1.colmmns.count === 2 ('aa','bb') // table1.columns['aa'] === view2.columns['aa'] // table1.columns['bb'] === view3.columns['bb']  // view1.colmmns.count === 0 // view2.colmmns.count === 1 ('aa') // view3.colmmns.count === 1 ('bb')     When you add a column to a MetaView, it is added to the MetaTable specified in the MetaView as_baseEntity, where only the reference to the column is registered.   When you add a column directly to the MetaTable, it is added independently; unlike MetaView, it is not referenced by any other view.   When you create a BindModel, by default, a MetaTable named first is automatically created. Each Bind Command object automatically contains a MetaView named valid, bind, and output.   When you run the execute() method in BindModel, the column and data are set according to the structure of MetaTable and MetaView, which can be customized to meet a variety of user requirements.  ","url": "http://localhost:4000/docs/core/"
  },{
    "title": "How to create objects",
    "excerpt":"‘BindModel’ offers a number of creation methods to suit the needs of the user, understand the pros and cons of each method and choose the appropriate method as needed.   1. Creation by service objects   Service objects can be managed separately to increase productivity. Define the items and commands needed to create objects at once.   var bm = new BindModel({ \titems: { \t\taa: 10, \t\tbb: 20, \t\tcc: 30, \t\tdd: 40 \t}, \tcommand: { \t\tcreate: {}, \t\tread: { \t\t\toutputOption: 3 \t\t} \t}, \tmapping: { \t\taa: { create: 'valid'}, \t\tbb: { read: ['bind', 'output']}, \t\tcc: { $all: 'output'} \t} });  // Check it out // bm.command['create'].valid.columns.count   == 1 ('aa') // bm.command['create'].bind.columns.count    == 0 //  bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 2 ('bb','cc') // bm.columns.count  // 3 ('aa','bb','cc')   2. Map after adding to items   Specifies a commonly managed item, which is useful if columns are used for multiple commands.   var bm = new BindModel();  // Add command bm.addCommand('create'); bm.addCommand('read', 3);  // Add Item bm.items.add('aa', 10); bm.items.add('bb', 20); bm.items.add('cc', 30); bm.items.add('dd', 40);  // mapping bm.setMapping({ \taa: { create: 'valid' }, \tbb: { read: 'bind' }, \tcc: { $all: ['output'] }   // $all = all command });  // Check it out // bm.command['create'].valid.columns.count  == 1 ('aa') // bm.command['create'].bind.columns.count   == 0 // bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 1 ('cc')  // bm.columns.count  == 3 ('aa','bb')  // bm.columns['aa'].value; == 10 // bm.columns['bb'].value; == 20 // bm.columns['cc'].value; == 30  3. Setting commands when adding columns   This is how you specify the command at the time of column generation. It is effective when you gradually expand the functionality.   var bm = new BindModel();  // Add command bm.addCommand('create'); bm.addCommand('read', 3);  // Add Column and Set Commands bm.addColumn('aa', 'create', 'valid'); bm.addColumn('bb', 'read', 'bind'); bm.addColumn('cc', '$all', 'output');     // Check it out // bm.command['create'].valid.columns.count  == 1 ('aa') // bm.command['create'].bind.columns.count   == 0 // bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 1 ('cc')  // bm.columns.count  // 3 'aa','bb'   4. Set to command after adding column   It is a method of creating a column to be managed in advance and setting it up and using it in the necessary command. You can reduce code duplication by managing tables separately or generating common columns in advance.   var bm = new BindModel();  // Add command bm.addCommand('create'); bm.addCommand('read', 3);  // Add a column to the default columns bm.columns.addValue('aa', 10); bm.columns.addValue('bb', 20); bm.columns.addValue('cc', 30);  // Set to Command bm.command['create'].setColumn('aa', 'valid'); bm.command['create'].setColumn('cc', 'output'); bm.command['read'].setColumn('bb', ['bind']); bm.command['read'].setColumn('cc', ['output']);  // Check it out // bm.command['create'].valid.columns.count  == 1 ('aa') // bm.command['create'].bind.columns.count   == 0 // bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 1 ('cc')  // bm.columns.count  // 3 ('aa','bb')   5. Register column by command   It is a method of generating columns for each command, which is useful if you manage them as independent columns for each command.   var bm = new BindModel(); bm.addCommand('create'); bm.addCommand('read'); bm.command['create'].addColumn('aa', 'valid'); bm.command['read'].addColumn('bb', ['bind', 'output']);  // Check it out // bm.command['create'].valid.count  == 1 ('aa') // bm.command['create'].bind.count   == 0 // bm.command['create'].output.count == 0  // bm.command['read'].valid.count    == 0 // bm.command['read'].bind.count     == 1 ('bb') // bm.command['read'].output.count   == 1 ('bb')  // bm.columns.count  == 2 ('aa','bb')   This variety of object generation methods allow us to flexibly utilize BindModel, and it is important to consider the advantages and disadvantages of each method and choose the appropriate method.  ","url": "http://localhost:4000/docs/create-method/"
  },{
    "title": "CRUD + List Example",
    "excerpt":"CRUDL is a concept that adds List to the traditional data processing capabilities of Create, Read, Update, and Delete. It is useful for simplifying and efficiently managing database interactions. BindModel is a useful tool for interacting with databases, aiming to design from a CRUDL perspective.   Register (Create)   Create refers to the task of inserting new records into the database, and the REST API corresponds to a POST request.   var bm = new BindModel(); // Create url settings and commands bm.url = '/user' bm.addCommand('create'); // Add Column bm.addColumn('user_name', 'create', ['valid', 'bind']); bm.addColumn('tel', 'create', 'bind'); // Execute bm.command['create'].execute();     ‘bm.command[‘create’.valid.column’ : columns subject to validation            Validates the “user_name” column.           ‘bm.command[‘create’].bind.column’ : columns for HTTP transmission            The value of the “user_name, tel” column is sent to ‘/user’.           When sending a POST request, set ‘bm.baseConfig.method = ‘post’.   Read (Read)   Read refers to the task of querying a specific record in a database, and in REST API, it is a GET request.   var bm = new BindModel(); // Create command bm.addCommand('read', 3); // Add Column bm.addColumn('idx','read', ['valid', 'bind']); bm.addColumn('tel','read', 'output'); // Setting and executing commands bm.command['read'].url = '/user/1' bm.command['read'].execute();     ‘bm.command[‘read’].valid.column’ : columns subject to validation            Validates the “idx” column.           ‘bm.command[‘read’].bind.column’ : columns for HTTP transmission            The value of the “idx” column is sent to ‘/user’.           ‘bm.command[‘read’].output.column’: Columns to receive from HTTP response            Send the value of the “tel” column to ‘/user’.           URL modification of RESTful requests can be set in cbBegin callback.   Modified (Update)  Update refers to the task of modifying an existing record in a database, and the REST API corresponds to a PUT or PATCH request.   var bm = new BindModel(); // Create url settings and commands bm.url = '/user' bm.addCommand('update'); // Add Column bm.addColumn ('idx', 'update', ['valid', 'bind']); // Check Required Values bm.addColumn('tel', 'update', 'bind'); // Execute bm.command['update'].execute();     ‘bm.command[‘update’.valid.column’ : columns subject to validation            Validates the “idx” column.           ‘bm.command[‘update’].bind.column’: Columns to HTTP transmission            The value of the “idx, tel” column is sent to ‘/user’.           When sending a PATCH request, set ‘bm.baseConfig.method = ‘patch’.   Delete   Delete refers to the action of deleting a specific record in a database, and the REST API corresponds to a DELETE request.   var bm = new BindModel(); // Create url settings and commands bm.url = '/user'; bm.addCommand('delete'); // Add Column bm.addColumn ('idx', 'delete', ['valid', 'bind']); // Required value check // Execute bm.command['update'].execute();     ‘bm.command[‘update’.valid.column’ : columns subject to validation            Validates the “idx” column.           ‘bm.command[‘update’].bind.column’: Columns to HTTP transmission            The value of the “idx” column is sent to ‘/user’.           If sending a DELETE request, set ‘bm.baseConfig.method = ‘delete’.   Inquiry (List)   List refers to the task of querying multiple records in a database, and the REST API corresponds to a GET or POST request.   { \t\"rows\": [ \t\t{ \"u_name\": \"Hong Gildong\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Sungchunhyang\", \"gender\", \"W\" }, \t] }   var bm = new BindModel(); // Create url settings and commands bm.url = '/user/list' bm.addCommand('list', 2); // Add Column bm.addColumn('user_name', 'list', 'output'); bm.addColumn('gender', 'list', 'output'); // Output callback settings bm.command['list'].cbOutput = function(views){ \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(i, row['user_name'], row['gender']); \t\t// 0 Hong Gil-dong M \t\t// 1. Sung Chunhyang W \t} } // Execute bm.command['list'].execute();     ‘bm.command[‘update’.valid.column’ : columns subject to validation            Validates the “idx” column.           ‘bm.command[‘update’].bind.column’: Columns to HTTP transmission            The value of the “idx” column is sent to ‘/user’.           Create a screen output related task in the cbOutput callback.   As such, CRUDL provides more flexible and powerful data manipulation capabilities by adding a list to traditional CRUD capabilities. With BindModel, these CRUDL tasks are simple to perform.   Registration / Read / Correct / Delete / Lookup Example   The following example includes the complete examples of Create, Read, Update, Delete, and List.   Server data  { \t\"rows\": [ \t\t{ \"u_name\": \"Neo\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Seri\", \"gender\", \"W\" }, \t] }   The column was shared in the command, so you selected how to register and set the column.   Example: Method Call Method  var bm = new BindModel();  // setting url bm.url = '/user'  // command registration bm.addCommand('create'); bm.addCommand('read', 3); bm.addCommand('update'); bm.addCommand('delete'); bm.addCommand('list', 2);  // Register a column bm.addColumn('user_name'); bm.addColumn('tel'); bm.addColumn('idx'); bm.addColumn('gender');  // create command setting bm.command['create'].seColumn('user_name', ['valid', 'bind']); bm.command['create'].seColumn('tel', 'bind');  // read command setting bm.command['read'].seColumn('idx', ['valid', 'bind']); bm.command['read'].seColumn('tel', 'output'); bm.command['read'].url = '/user/1';  // update command setting bm.command['update'].seColumn('idx', ['valid', 'bind']); bm.command['update'].seColumn('tel', 'bind');  // delete command setting bm.command['delete'].seColumn('idx', ['valid', 'bind']);  // list command setting bm.command['list'].seColumn('user_name', 'output'); bm.command['list'].seColumn('gender', 'output');  bm.command['list'].url = '/user/list'; bm.command['list'].cbOutput = function(views){ \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(i, row['user_name'], row['gender']); \t\t// 0 Hong Gil-dong M \t\t// 1. Sung Chunhyang W \t} };  // Execute bm.command['create'].execute(); bm.command['read'].execute(); bm.command['update'].execute(); bm.command['delete'].execute(); bm.command['list'].execute();   Example: Service Object Injection Method  var bm = new BindModel({ \turl: '/user', \titems: { \t\tuser_name: '', \t\ttel: '', \t\tidx: '', \t\tgender: '', \t}, \tcommand: { \t\tcreate: {}, \t\tread: { \t\t\toutputOption: 3, \t\t\turl: '/user/1' \t\t}, \t\tupdate: {}, \t\tdelete: {}, \t\tlist: { \t\t\toutputOption: 2, \t\t\turl: '/user/list', \t\t\tcbOutput = function(views){ \t\t\t\tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\t\t\t\tvar row = views['first'].rows[i]; \t\t\t\t\tconsole.log(i, row['user_name'], row['gender']); \t\t\t\t\t// 0 Hong Gil-dong M \t\t\t\t\t// 1. Sung Chunhyang W \t\t\t\t} \t\t\t} \t\t}, \t}, \tmapping: { \t\tuser_name: {  \t\t\tcreate: ['valid', 'bind'],  \t\t\tlist: 'output'  \t\t}, \t\ttel: {  \t\t\tcreate: 'bind',  \t\t\tread: 'bind',  \t\t\tupdate: 'bind' \t\t}, \t\tidx: {  \t\t\tread: ['valid', 'bind'],  \t\t\tupdate: ['valid', 'bind'],  \t\t\tdelete: ['valid', 'bind'] }, \t\t}, \t\tgender: {  \t\t\tlist: 'output'  \t\t} \t} });  // Execute bm.command['create'].execute(); bm.command['read'].execute(); bm.command['update'].execute(); bm.command['delete'].execute(); bm.command['list'].execute();   These two examples illustrate how to perform CRUDL tasks efficiently. It explains how to set up and execute each command using the method call method and the service object injection method.  ","url": "http://localhost:4000/docs/crudl-example/"
  },{
    "title": "Main Features",
    "excerpt":"BindModel is both a framework and a library feature. It uses commands and entities that are not based on trendy UI components for higher productivity. Client-to-server communication can be easily implemented through the BindModel class.   Manage Entities   BindModel manages all data as an entity (MetaTable, MetaView) to support structured data processing, enabling consistent and efficient data management.   Transaction Support  MetaTable supports transactions to maintain data consistency and integrity.   Flexible Data Manipulation  MetaTable provides the ability to add, modify, delete, and query data to facilitate data manipulation.   Flexible UI Configuration  MetaView can easily work with a variety of UI elements to create a dynamic and flexible user interface.   MetaTable is an entity that manages data in a table format. It is designed with a structure that is very familiar to people who have used DotNet’s DataTable.   %% All data is managed by an entity (MetaTable, MetaView). Familiar to anyone who has used DotNet’s DataTable, and supports transactions.%   command-based processor   BindModel provides a command-based processor to support a consistent development pattern. This structure provides a systematic and easy-to-maintain approach to command processing and data management for applications.   a structural approach  Command-based processors help to clearly structure an application’s business logic. Each command is managed independently and can be easily modified or expanded as needed.  Reusable  Similar tasks can be handled in multiple locations by reusing commands, which reduce redundant code writing and maintain code consistency.   Simplicity and Productivity   BindModel increases the intuitive nature of code by minimizing specific grammar or indicators and eliminating unnecessary components. OOP-based design minimizes code duplication by utilizing inheritance and provides simplicity and high productivity to users by designing based on frequency of use in projects.   Minimize code duplication  It provides an efficient structure to avoid the need for repeated code writing, increasing maintenance and scalability.   User-friendly  It is designed to make it easy for beginners to learn, and users with experience in web development can create a website with two to three hours of learning.   Low design burden  There is less pressure on file and screen component division, so you don’t have to spend a lot of time designing the project’s initial design.   efficient development  With BindModel, you can significantly reduce the number of files, code lines, code complexity, and development time, so you can experience more than five times more productivity.   Independent View   BindModel serves as a controller of the MVC pattern and is completely separate from View, making it very easy to replace and manage the screen. This design allows developers to manage the logic of applications with minimal impact on UI changes.   Inject service objects   By supporting service object injection, BindModel can maximize the flexibility of the framework and increase the reuse of objects. Through service object injection, common functions of applications can be modularized and dependency management can be simplified.   object serialization   BindModel supports object serialization, allowing for efficient transfer and remote control of objects. Object serialization plays an important role in storing the state of an object or in communicating with other systems.   backward compatibility   BindModel is built in JavaScript ECMAScript 5 (ES5) grammar to ensure backward compatibility. It works reliably in a variety of environments and ensures compatibility with existing JavaScript code.   TypeScript support   BindModel provides TypeScript type information in development environments, helping developers write codes more safely and efficiently. TypeScript’s static type checks prevent code errors and greatly improve development productivity through code completion.   Promise Support   BindModel provides Promise per command, helping you to process asynchronous tasks more easily. Promise provides the methods needed to process the results of asynchronous tasks (then, catch, finally), greatly improving the readability and maintenance of code.   Integrated Library   It is a harmonious collection of libraries needed for web development, such as routing, form management, and client-server communication.   ","url": "http://localhost:4000/docs/feature/"
  },{
    "title": "Multi-Table",
    "excerpt":"By default, the BindModel object automatically generates and uses a MetaTable named 'first', which is useful if you have the same column name but different properties or special cases.  ## Add MetaTable  ### Add as addTable() Method  The addTable() method allows you to add MetaTable to the \\_tables collection, which automatically creates a reference key to access the table from the BindModel object.  ```js var bm = new BindModel();  bm.addTable('second');  // bm._tables[0] === bm._tables['first'] == bm.first // bm._tables[1] === bm._tables['second'] == bm.second // bm._tables.count == 2 ``` - Access to tables added as bm.second. ### \\_Add as a collection of tables  You can add MetaTable through the \\_tables.add() method, which adds tables to the \\_tables collection similarly, but does not automatically generate a table name reference key, unlike addTable().  ```js var bm = new BindModel();  bm._tables.add('second');  // bm._tables[1] === bm._tables['second'] // bm._tables.count == 2 ```   ## Change the default table  If you set the added MetaTable to the default table, the default table is set to the changed table when you use addColumn() or addcommand() later.  ```js var bm = new BindModel();  bm._tables.add('second');  // Default Table Settings bm._baseTable = bm['second'];    // Add Column bm.addColumnValue('aa', 10);  // bm.columns['aa'].value == 10 // bm._tables['first'].columns.count == 0 // bm._tables['second'].columns.count == 1 ``` - For the 'column' property, refer to columns of '_baseTable' (column === \\_tabeTable.column)  As such, MetaTable can be added and utilized in the BindModel object.   # Specify tables added by multiple methods  You can specify tables added by multiple methods. If you specify tables outside the \\_tables collection, the object serialization feature is not available.  ## BindModel Area  ### addcommand(): add command  You can specify a table when adding a command.  ```js var bm = new BindModel();  bm.addTable('second');  bm.addCommand('read', 3, 'second'); bm.addCommand('list', 3, bm.second);  // bm.command['read']._baseTable == bm.second // bm.command['list']._baseTable == bm.second ``` - The default table for the read command is specified as 'second'. - The default table for the list command is specified as 'second'. ### addColumn(): add column  You can specify a table when adding columns.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.addColumn('aa', 'read', 'valid', 'second'); bm.addColumn('bb', 'read', '$all', bm.second); ``` - The 'aa' column is registered in the 'second' table and a reference is registered in the valid of the read command. - The 'bb' column is registered in the 'second' table and a reference is registered in the entire MetaView of the read command.  ### addColumnValue(): add column  You can specify an initial value and set the table when adding columns.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.addColumn('aa', 'AA', 'read', 'valid', 'second'); bm.addColumn('bb', 'BB', 'read', '$all', bm.second); ``` - The initial value of the 'aa' column is 'AA' and is registered in the 'second' table and a reference is registered in the valid of the read command. - The initial value of the 'bb' column is 'BBB' and is registered in the 'second' table and a reference is registered in the entire MetaView of the read command.  ### setMapping():column mapping  You can specify a default table when mapping  ```js var bm = new BindModel(); bm.addTable('second'); bm.addCommand('read');  bm.items.add('aa', ''); bm.items.add('bb', '');  bm.setMapping({ \taa: { read: ['valid'] }, \tbb: { read: ['bind'] }, }, 'second');  // bm.second.columns.count == 2 // bm.first.columns.count == 0 ``` - Items are registered in the 'second' table and the reference value is registered in the MetaView of the read command.  ### Service Object  You can use it in combination with the table name in the items, mapping area.  ```js var bm1 = new BindModel({ \ttables: ['second', 'three'], \titems: {         'aa': '',         'second.bb': '',         'cc': '',     },     command: {         read: {} \t},     mapping: {         'aa': { read: ['valid'] },         'bb': { read: ['bind'] },         'three.cc': { read: ['output'] }     }, }); ``` - Items 'aa' are registered in the default table (first) and mapped to the target command. - The 'bbb' item is registered in the extra table (second) and mapped to the target command. - The 'cc' item is registered in the additional table and mapped to the target command.   ## Bind Command Area  ### addColumn(): add column  You can specify a table when adding columns.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.cmd['read'].addColumn('aa', 'valid', 'second'); bm.cmd['read'].addColumn('bb', '$all', bm.second); ``` - The 'aa' column is registered in the 'second' table and a reference is registered in the valid of the read command. - The 'bb' column is registered in the 'second' table and a reference is registered in the entire MetaView of the read command.  ### addColumnValue(): add column  When adding columns, you can set initial values and specify tables.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.cmd['read'].addColumn('aa', 'AA', 'read', 'valid', 'second'); bm.cmd['read'].addColumn('bb', 'BB', 'read', '$all', bm.second); ``` - The 'aa' column is registered in the 'second' table with an initial value of 'AA' and a reference is registered in the valid of the read command. - The 'bb' column is registered in the 'second' table with an initial value of 'AA' and a reference is registered in the entire MetaView of the read command. ### setColumn(): column settings  You can specify a table when setting the column.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bb.first.columns.add('aa'); bb.first.columns.add('bb'); bb.seoncd.columns.add('cc');  bm.command['read'].setColumn('aa', 'valid'); bm.command['read'].setColumn(['bb', 'second.cc'], 'bind'); ``` - The 'aa' column registered in the default table registers a reference in the valid of the read command. - The 'bbb' column registered in the default table is referenced in the bind of the read command. - The 'cc' column registered in the 'second' table is referenced in the bind of the read command. ","url": "http://localhost:4000/docs/multi-table/"
  },{
    "title": "Multi-View(output)",
    "excerpt":"Multi-view is used when data received from the server is more than one data. By default, the Bindcommand object contains the MetaView of the output property, which is a reference property for '_outputs['output1'].  This feature allows you to add or remove multiple MetaViews, each of which is used to store and manage data received from the server.  ## output structure of Bindcommand  When you create a Bindcommand object, the output attribute is added by default, which is a reference to '_outputs['output1']'.  ```js var bm = new BindModel();  bm.addCommand('test');  // bm.command['test'].output == MetaView // bm.command['test'].output1 == MetaView ``` - Here, output and output1 refer to the same MetaView.   ## output (MetaView) 추가  Type: newOutput ```ts type newOutput = (outputName?: string) => void; ``` - outputName—The name of the output to be added.  You can use the newOutput() method to add a new MetaView, which optionally takes outputName as a factor and adds MetaView to that name.  If there is no factor, it is added by default as a name in the form of 'output + order'.  Example: Adding Output ```js var bm = new BindModel();  bm.addCommand('test'); // bm.command['test'].output == MetaView // bm.command['test'].output1 == MetaView // bm.cmd['test']._outputs.count == 1  bm.cmd['test'].newOutput(); // bm.command['test'].output2 == MetaView // bm.cmd['test']._outputs.count == 2  bm.cmd['test'].newOutput('three'); // bm.command['test'].output3 == MetaView // bm.command['test'].three == MetaView // bm.cmd['test']._outputs.count == 3 ``` - If no factor is given in the first newOutput() method, it is added as 'output2'. - It was added as 'three' and 'output3' in the second newOutput() method.  If you add an output MetaView and add a column to the entire command, it is also mapped to the added view.  Example: Adding a column to an entire MetaView ```js var bm = new BindModel();  bm.addCommand('test');  bm.cmd['test'].newOutput('newOutput'); bm.cmd['test'].addColumn('aa');  // bm.cmd['test'].valid.count == 1 ('aa') // bm.cmd['test'].bind.count == 1 ('aa') // bm.cmd['test'].output.count == 1 ('aa') // bm.cmd['test'].newOutput.count == 1 ('aa') ``` - The 'aa' column added to the added 'newOutput' is added.    ## output (MetaView) 제거  타입 : removeOutput ```ts type newOutput = (outputName: string) => boolean; ``` - outputName: The output name that you want to remove.  Default properties 'output', 'output1' cannot be removed.  ```js var bm = new BindModel();  bm.addCommand('test');  bm.cmd['test'].newOutput(); bm.cmd['test'].newOutput('three');  // Remove bm.cmd['test'].removeOutput('output2'); bm.cmd['test'].removeOutput('three'); // bm.cmd['test'].removeOutput('output') : throw 발생 // bm.cmd['test']._outputs.count == 1 ``` - Here, you can remove the newOutput() method and the added output2 and three.  The examples and descriptions above will help you understand how to add or remove multiple MetaViews using the multiview functionality, which is useful for managing and processing multiple data received from the server.  ","url": "http://localhost:4000/docs/multi-view/"
  },{
    "title": "Implement notice in BindModel",
    "excerpt":"## Description - As an example of \"Notice\", the administrator and user pages. - You can use html, css, and js files produced by web designers right away without modification. - By separating and managing common service objects, it provides an efficient structure so that repetitive code writing is not required, increasing maintenance and scalability.  ## folder structure ```js vue-mix/ ├── service/ │   ├── base-notice-svc.js │   ├── notice-admin-svc.js  │   └--notice-front-svc.js : ** User Page ** ├-- front.html : ** User Page ** └── admin.html ```  ### admin.html --- A page that consists of html, css, and js of notice lists and forms.  You must add permission settings to the Administrators page during a physical implementation.  ```html      BindModel Example                  Notice Admin Page    Key Features: List inquiry/modification/deletion    Data is transmitted when modified or deleted from the test page, but it is not actually processed.                         Title         Status         Date                                 There is no content.                 {% raw %}               {% endraw %}                            날짜                                 Title                                    Content                                                                                 top notice                                                                              Standby                                                            Activation                                                            Hidden                                               Update     Delete     List             ``` #### Code Description - Inject service objects when creating a 'bm' BindModel object. - A class statement was used internally to separate common elements of the service object (NoticeAdminService). - You have registered the execute() method on the button using Jquery. - After loading the screen, you ran the command to get the list by running bm.cmd['list'].execute(). - The handlebars template was used to output the lock.  ### front.html --- This is the user page of the announcement.  ```html      BindModel Example                  Notice Front Page    Key functions: List Lookup    Data is transmitted when modified or deleted from the test page, but it is not actually processed.                         Title         Date                                 There is no content.                 {% raw %}               {% endraw %}                                Title                                    Content                            List              ``` #### Code Description - Inject service objects when creating a 'bm' BindModel object. - A class statement was used inside to separate common elements of the service object (NoticeFrontService). - You have registered the execute() method on the button using Jquery. - After loading the screen, you ran the command to get the list by running bm.cmd['list'].execute(). - The handlebars template was used to output the lock.   ### service/base-notice-svc.js --- The BaseNoticeService class has configured the common object of the notice.  ```js class BaseNoticeService {     constructor(_SUFF = '') {         var _this = this;              this.items = {             // misc             _area_temp: { selector: { key: `#area-temp${_SUFF}`,    type: 'html' } },             _area_tbody:{ selector: { key: `#area-tbody${_SUFF}`,   type: 'html' } },             _area_form: { selector: { key: `#class-form${_SUFF}`,   type: 'prop.class' } },             _index:     0,             // valid, bind, output             ntc_idx:        '',             title:      {                  selector: { key: `#title${_SUFF}`,        type: 'value' },                 required: true,             },             contents:   { selector: { key: `#contents${_SUFF}`,     type: 'value' } },             top_yn:     {                  selector: { key: `input[name=top_yn${_SUFF}]`,      type: 'none' },                 setFilter(val) {                      $(`input[name=top_yn${_SUFF}]`).prop('checked', val == 'Y' ? true : false);                 },                 getFilter(val) {                     return $(`input[name=top_yn${_SUFF}]:checked`).val();                 }             },             active_cd:  {                 selector: { key: `input[name=active_cd${_SUFF}][type=radio]`,  type: 'none' },                 setFilter(val) {                      $(`input[name=active_cd${_SUFF}][value=${val}]`).prop('checked', true);                 },                 getFilter(val) {                     return $(`input[name=active_cd${_SUFF}]:checked`).val();                 }             },             create_dt:  { selector: { key: `#create_dt${_SUFF}`,  type: 'text' } }         };                  this.fn = {             procRead(index) {                  _this.bindModel.items._index = index;                 _this.bindModel.command['read'].execute();             }         };     } } ``` #### Code Description - The _SUFF parameter was used to prevent duplication of id and name of service object. - var_this is defined to access bindModel objects in the callback function. - The 'items' area is a common property to register as an HTML Column.     - Selector properties are properties that point to DOM.         - The key property is the selector value that points to the element.         - Value, none, text, html, prop.synonyms, and attr.synonyms of type properties.     - setter/getter usually gets values from outside.     - The setFiter/getFiter obtains values from multiple DOM elements or sets them when processing.     The required property is a required value for valid inspection. - The 'fn' area is the user function area.   ### service/notice-admin-svc.js --- The NoticeAdminService class is an administrator service object for a notice.  ```js class NoticeAdminService extends BaseNoticeService {     constructor() {         super();          var _this       = this;         var _template   = null;     // Handlebars template          this.command = {             create:     {             },             read:       {                 outputOption: 3,                 cbBegin(cmd) {                      cmd.outputOption.index = Number(cmd._model.items._index);                     cmd._model.columns._area_form.value = '';  // form show                 },             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) alert('It has been modified.');                 }             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) {                         alert('The post has been deleted.');                         _this.bindModel.cmd['list'].execute();                     }                 }             },             list:       {                 outputOption: 1,                 cbBegin(cmd) {                     cmd._model.columns._area_form.value = 'd-none';                 },                 cbOutput(outs, cmd, res) {                     if (_template === null) {                         _template = Handlebars.compile( _this.bindModel.columns['_area_temp'].value );                      }                     _this.bindModel.columns['_area_tbody'].value   = _template(res.data);                 },             }         };          this.mapping = {             _area_temp:     { list:     'misc' },             _area_tbody:    { list:     'misc' },             _area_form:     { list:     'misc' },             ntc_idx:        { read:     'bind',     update:  'bind',               delete:     'bind' },             title:          { read:     'output',   update:  ['valid', 'bind'], },             contents:       { read:     'output',   update:  'bind' },             top_yn:         { read:     'output',   update:  ['valid', 'bind'], },             active_cd:      { read:     'output',   update:  ['valid', 'bind'], },             create_dt:      { read:     'output' },         };      }     } ``` #### Code Description - The command area sets the properties of the Bindcommand.     - The output option is a method of importing data sent to the server.     - The callback function is called step by step when executing execute().         - **cbBegin**() >> **cbValid**() >> **cbBind**() >> **cbResult**() >> **cbOutput**() >> **cbEnd**() - The mapping area is the Bindcommand object mapping information for the column.     - title:          { read:     'output',   update:  ['valid', 'bind'], }         - Create a Title column and map it to the output of the **read** command and the **valid** command to valid, bind.  ### service/notice-front-svc.js --- The NoticeFrontService class is a user service object of a notice.  ```js class NoticeFrontService extends BaseNoticeService {     constructor() {         super();          var _this       = this;         var _template   = null;     // Handlebars template          this.command = {             read:       {                 outputOption: 3,                 cbBegin(cmd) {                      cmd.outputOption.index = Number(cmd._model.items._index);                     cmd._model.columns._area_form.value = '';  // form show                 },             },               list:       {                 outputOption: 1,                 cbBegin(cmd) {                     cmd._model.columns._area_form.value = 'd-none'; // form hidden                 },                 cbOutput(outs, cmd, res) {                     if (_template === null) {                         _template = Handlebars.compile( _this.bindModel.columns['_area_temp'].value );                      }                     _this.bindModel.columns['_area_tbody'].value   = _template(res.data);                 },             }         };          this.mapping = {             _area_temp:     { list:     'misc' },             _area_tbody:    { list:     'misc' },             _area_form:     { list:     'misc' },             ntc_idx:        { read:     'bind' },             title:          { read:     'output' },             contents:       { read:     'output' },             create_dt:      { read:     'output' },         };     } } ```","url": "http://localhost:4000/exam/notice-bindmodel/"
  },{
    "title": "notice React Mix compare",
    "excerpt":"## Description   ## React folder structure ```js react-mix1/ ├── componets/ │   ├── NoticeAdminPage.js │   ├── NoticeForm.js │   └── NoticeList.js ├── app.js └── admin.html ```  ### NoticeAdminPage.js : React --- It is a code that implements business logic and core in the announcement.  ```js import React from 'https://esm.sh/react';  import NoticeList from './NoticeList.js'; import NoticeForm from './NoticeForm.js';  const { useState, useEffect } = React;  export default function NoticeAdminPage() {   const [notices, setNotices] = useState([]);   const [selectedNotice, setSelectedNotice] = useState(null);   const [formData, setFormData] = useState({     title: '',     contents: '',     active_cd: 'D',     top_yn: false,   });    useEffect(() => {     fetchNotices();   }, []);    const fetchNotices = async () => {     try {       const response = await axios.get('/notice/data/list.json');       setNotices(response.data.rows);     } catch (error) {       console.error('Failed to fetch notices:', error);     }   };    const handleRead = (notice) => {     setSelectedNotice(notice);     setFormData({       title: notice.title,       contents: notice.contents || '',       active_cd: notice.active_cd || 'D',       top_yn: notice.top_yn === 'Y',     });   };    const handleList = () => {     setSelectedNotice(null);   };    const handleChange = (e) => {     const { name, value, type, checked } = e.target;     setFormData((prevFormData) => ({       ...prevFormData,       [name]: type === 'checkbox' ? checked : value,     }));   };    const handleUpdate = async () => {     if (!formData.title.trim()) {       alert('Title is required.');       return;     }      try {       const response = await axios.put(`data/list/${selectedNotice.ntc_idx}`, formData);       console.log('Notice updated successfully:', response.data);       fetchNotices();       setSelectedNotice(null);     } catch (error) {       console.error('Failed to update notice:', error);     }   };    const handleDelete = async () => {     try {       const response = await axios.delete(`data/list/${selectedNotice.ntc_idx}`);       console.log('Notice deleted successfully:', response.data);       fetchNotices();       setSelectedNotice(null);     } catch (error) {       console.error('Failed to delete notice:', error);     }   };    return (     React.createElement('div', { className: 'container mt-3' },       React.createElement('h2', null, 'Notice Admin Page'),       React.createElement('h5', null, 'Key Features: List inquiry/modification/deletion'),       React.createElement('p', null, 'Data is transmitted when modified or deleted from the test page, but it is not actually processed.'),              !selectedNotice ? (         React.createElement(NoticeList, { notices, handleRead })       ) : (         React.createElement(NoticeForm, {           selectedNotice,           formData,           handleChange,           handleUpdate,           handleDelete,           handleList         })       )     )   ); } ```   ### NoticeAdminPage.js : Mix React and BindModel ---  ```js import React, { Component } from 'https://esm.sh/react'; import NoticeList from './NoticeList.js'; import NoticeForm from './NoticeForm.js'; import NoticeAdminService from '../service/notice-admin-svc.js'  export default class NoticeAdminPage extends Component {   constructor(props) {     super(props);          this.bm = new _L.BindModel(new NoticeAdminService(this));       this.bm.url = '/notice/data/list.json';            this.state = { selectedNotice: null };   }    componentDidMount() {     this.bm.cmd['list'].execute();   }    handleList = () => {     this.setState({ selectedNotice: null });   };    handleChange = (e) => {     let { name, value, type, checked } = e.target;     if (type === 'checkbox') value = checked ? 'Y' : 'N';     this.bm.cols[name].value = value;  //  column value setting     this.forceUpdate();           //  Forced screen rendering   };    render() {     const { selectedNotice } = this.state;      return (       React.createElement('div', { className: 'container mt-3' },         React.createElement('h2', null, 'Notice Admin Page'),         React.createElement('h5', null, 'Key Features: List inquiry/modification/deletion'),         React.createElement('p', null, 'Data is transmitted when modified or deleted from the test page, but it is not actually processed.'),                  React.createElement(NoticeList, { bindModel: this.bm }),         !selectedNotice || (           React.createElement(NoticeForm, {             handleChange: this.handleChange,             bindModel: this.bm           })         )       )     );   } } ```  ### notice-admin-svc.js : Mix Vue and BindModel ---  ```js export default class NoticeAdminService {     constructor(reactThis) {         const _this = this;          this.items = {             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res)  {                     if (res) {                       alert('The post has been modified.');                       reactThis.handleList();                     }                   }             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) {                       alert('The post has been deleted.');                       reactThis.handleList();                     }                   }             },             list:       {                 outputOption: 1,                 cbEnd(status, cmd, res) {                     reactThis.setState({ selectedNotice: null });                 }             }         };         this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };         this.fn = {             handleRead: async (idx) => {                 _this.bindModel.cmd['read'].outputOption.index = Number(idx);                 await _this.bindModel.cmd['read'].execute();                 reactThis.setState({ selectedNotice: true });             },         };     }     } ``` ## Comparison   > The use of class components and BindModel in the mixed code provides the benefits of providing a clearer separation of React's health management and business logic, including.  1. Improved Reusability and Maintenance of Business Logic: BindModel lets you separate and manage business logic from components. By defining logic such as data binding and API calls inside BindModel, the same logic can be reused by other components, and maintenance is easy in the event of future logic changes. Structurally cleaner management is possible than implementing business logic directly like the first code. 2. Data Binding Consistency: You can ensure data binding consistency by explicitly connecting data with screen elements via BindModel.Managing column values in the same way as this.bm .cols[name].value allows you to efficiently synchronize user input with data changes. 3. Clear health management: Class components explicitly manage health conditions, and interaction with BindModel makes it easier to track changes in the state of each data. This allows for more systematic health management between components. 4. Flexibility in large-scale projects: This approach is particularly advantageous for large and complex projects. BindModel helps ensure consistent handling of business logic across multiple components, and is highly scalable and flexible.  In conclusion, the mixed code provides a clear separation between React's state management and business logic to significantly improve the readability, maintenance, and reusability of the code, especially for large-scale projects or complex data processing.","url": "http://localhost:4000/exam/notice-compare-react/"
  },{
    "title": "notice Vue Mix compare",
    "excerpt":"## Description   ## folder structure ```js vue-mix/ ├── componets/ │   ├── NoticeForm.js │   └── NoticeList.js ├── app.js └── admin.html ```  ### app.js : Vue --- It is a code that implements business logic and core in the announcement. ```js import NoticeList from './components/NoticeList.js'; import NoticeForm from './components/NoticeForm.js';  const { createApp, ref } = Vue  const app = createApp({   data() {     return {       notices: [],       selectedNotice: null,       statusOptions: {         'D': 'Standby',         'A': 'Activation',         'H': 'Hidden'       }     };   },   methods: {     fetchNotices() {       axios.get('/notice/data/list.json')       .then(response => {         this.notices = response.data.rows.map(row => ({           ntc_idx: row.ntc_idx,           title: row.title,           contents: row.contents,           top_yn: row.top_yn,           active_cd: row.active_cd,           create_dt: row.create_dt         })) || [];       })       .catch(error => {         console.error('Error fetching notices:', error);       });     },     selectNotice(notice) {       this.selectedNotice = notice;       axios.get(`/notice/data/list.json`)  // RESTful : `/notice/data/${ntc_idx}.json`         .then(response => {           const notice = response.data;           this.selectedNotice = {             ntc_idx: notice.ntc_idx,             title: notice.title,             contents: notice.contents,              top_yn: notice.top_yn,             active_cd: notice.active_cd,             create_dt: notice.create_dt           };         })         .catch(error => {           console.error('Error reading notice:', error);         });     },     deselectNotice() {       this.selectedNotice = null;     },     updateNotice(notice) {       const isValid = this.validateNotice(notice);        if (isValid) {         axios.put(`/notice/data/list.json`, notice) // RESTful : '/notice/update/${notice.ntc_idx}`           .then(() => {             console.warn('Caution: Send to the test server, but the data is not reflected.', notice);             this.deselectNotice();           })           .catch(error => {             console.error('Error updating notice:', error);           });       } else {         alert('Validation failed');       }     },     deleteNotice(idx) {       const deleteNotice = {         ntc_idx: idx       };       if (confirm('Are you sure you want to delete it?')){         axios.delete(`/notice/data/list.json`, deleteNotice)  // RESTful : `/notice/delete/${ntc_idx}`           .then(() => {             console.warn('Caution: Send to the test server, but the data is not reflected.', deleteNotice);             this.deselectNotice();             // 삭제 후 공지사항 목록을 다시 불러옴             this.fetchNotices();           })           .catch(error => {             console.error('Error deleting notice:', error);           });       }     },     validateNotice(notice) {       let isValid = true;       if (!notice.title || notice.title === '') {         isValid = false;       }       if (!notice.top_yn || (notice.top_yn !== 'Y' && notice.top_yn !== 'N')) {         isValid = false;       }       if (!notice.active_cd || (notice.active_cd !== 'D' && notice.active_cd !== 'A' && notice.active_cd !== 'H')) {         isValid = false;       }       return isValid;     }   },   mounted() {     this.fetchNotices();   },   components: {     'notice-list': NoticeList,     'notice-form': NoticeForm   } });  app.mount('#app'); ```   ### app.js : Mix Vue and BindModel ---  ```js import NoticeList from './components/NoticeList.js'; import NoticeForm from './components/NoticeForm.js'; import NoticeAdminService from './service/notice-admin-svc.js'  const { createApp, ref } = Vue const bm = new _L.BindModel(new NoticeAdminService());    bm.url =' /notice/data/list.json';  const app = createApp({   data() {     return {       notices: [],       selectedNotice: null,       statusOptions: {         'D': 'Standby',         'A': 'Activation',         'H': 'Hidden'       },       bindModel: bm,     };   },   methods: {     selectNotice(idx) {       this.selectedNotice = idx;     },     deselectNotice() {       this.selectedNotice = null;     },   },   components: {     'notice-list': NoticeList,     'notice-form': NoticeForm   } });  app.mount('#app'); ```  ### notice-admin-svc.js : Mix Vue and BindModel ---  ```js export default class NoticeAdminService {     constructor() {         var _this       = this;         var _template   = null;     // Handlebars template          this.items = {             ntc_idx: { required: true },             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             list:       {                 outputOption: 1,             }         };          this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };     }     } ```  ## Comparison  1. Isolation and Reusability of Business Logic: The second code separated business logic into separate classes using BindModel and NoticeAdminService. This makes business logic separate from Vue components and reusable. This structure allows the same business logic to be recycled from other Vue components or projects, greatly improving maintenance and scalability. 2. Simplicity of data binding: By encapsulating logic, such as importing data using BindModel, you can reduce the number of methods for Vue components. The first code uses direct axios calls, but the second code is responsible for this at BindModel, which makes the code much simpler. 3. Maintenance and scalability: Because business logic is not directly dependent on Vue components, future API changes or service logic changes can only be modified by the NoticeAdminService. This simplifies the maintenance of the code. On the other hand, the first code contains business logic inside the Vue component, which may require modifying several components when changing logic. 4. Improved testability: The second method separated the business logic into separate classes, so unit tests can be written independently for that class. The business logic inside the Vue component is more complex to test, but the BindModel method provides a testable code structure.  > In conclusion, the advantage of the second code is to separate the business logic, increasing the reusability, maintenance, and testability of the code.","url": "http://localhost:4000/exam/notice-compare-vue/"
  },{
    "title": "notice React Mix",
    "excerpt":"## Description  As an example of \"Notice\", we excluded the user page as a page.  ## folder structure ```js react-mix1/ ├── componets/ │   ├── NoticeAdminPage.js │   ├── NoticeForm.js │   └── NoticeList.js ├── service/ │   └── notice-admin-svc.js ├── app.js └── admin.html ```  ### admin.html ---  ```html            Notice Admin Page - React                 ```  ### app.js ---  ```js  import React from 'https://esm.sh/react'; import ReactDOM from 'https://esm.sh/react-dom'; import NoticeAdminPage from './components/NoticeAdminPage.js';  function App() {   return React.createElement(NoticeAdminPage); }  ReactDOM.render(   React.createElement(App),   document.getElementById('root') ); ```  ### service/notice-admin-svc.js ---  ```js class NoticeAdminService {     constructor(reactThis) {         const _this = this;          this.items = {             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res)  {                     if (res) {                       alert('The post has been modified.');                       reactThis.handleList();                     }                   }             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) {                       alert('The post has been deleted.');                       reactThis.handleList();                     }                   }             },             list:       {                 outputOption: 1,                 cbEnd(status, cmd, res) {                     reactThis.setState({ selectedNotice: null });                 }             }         };         this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };         this.fn = {             handleRead: async (idx) => {                 _this.bindModel.cmd['read'].outputOption.index = Number(idx);                 await _this.bindModel.cmd['read'].execute();                 reactThis.setState({ selectedNotice: true });             },         };     }     }  export {     NoticeAdminService as default,     NoticeAdminService } ```   ### components/NoticeAdminPage.js ---  ```js import React, { Component } from 'https://esm.sh/react'; import NoticeList from './NoticeList.js'; import NoticeForm from './NoticeForm.js'; import NoticeAdminService from '../service/notice-admin-svc.js'  export default class NoticeAdminPage extends Component {   constructor(props) {     super(props);          this.bm = new _L.BindModel(new NoticeAdminService(this));       this.bm.url = '/notice/data/list.json';            this.state = { selectedNotice: null };   }    componentDidMount() {     this.bm.cmd['list'].execute();   }    handleList = () => {     this.setState({ selectedNotice: null });   };    handleChange = (e) => {     let { name, value, type, checked } = e.target;     if (type === 'checkbox') value = checked ? 'Y' : 'N';     this.bm.cols[name].value = value;  //  column value setting     this.forceUpdate();           //  Forced screen rendering   };    render() {     const { selectedNotice } = this.state;      return (       React.createElement('div', { className: 'container mt-3' },         React.createElement('h2', null, 'Notice Admin Page'),         React.createElement('h5', null, 'Key Features: List inquiry/modification/deletion'),         React.createElement('p', null, 'Data is transmitted when modified or deleted from the test page, but it is not actually processed.'),                  React.createElement(NoticeList, { bindModel: this.bm }),         !selectedNotice || (           React.createElement(NoticeForm, {             handleChange: this.handleChange,             bindModel: this.bm           })         )       )     );   } } ```   ### components/NoticeForm.js ---  ```js import React, { Component } from 'https://esm.sh/react';  export default class NoticeForm extends Component {   render() {     const { handleChange, bindModel } = this.props;      return (       React.createElement('div', { id: 'class-form' },         React.createElement('form', null,           React.createElement('div', { className: 'form-group' },             React.createElement('label', {}, '날짜'),             React.createElement('p', { id: 'create_dt' }, bindModel.cols.create_dt.value)           ),           React.createElement('div', { className: 'form-group' },             React.createElement('label', { htmlFor: 'title' }, 'Title'),             React.createElement('input', {               type: 'text',               className: 'form-control',               id: 'title',               name: 'title',               value: bindModel.cols.title.value,               onChange: handleChange             })           ),           React.createElement('div', { className: 'form-group' },             React.createElement('label', { htmlFor: 'contents' }, 'Content'),             React.createElement('textarea', {               className: 'form-control',               id: 'contents',               name: 'contents',               rows: '3',               value: bindModel.cols.contents.value,               onChange: handleChange             })           ),           React.createElement('div', { className: 'row' },             React.createElement('div', { className: 'col' },               React.createElement('div', { className: 'form-check' },                 React.createElement('input', {                   type: 'checkbox',                   className: 'form-check-input',                   id: 'check1',                   name: 'top_yn',                   checked: bindModel.cols.top_yn.value === 'Y',                   onChange: handleChange                 }),                 React.createElement('label', { className: 'form-check-label', htmlFor: 'check1' }, 'top notice')               )             ),             React.createElement('div', { className: 'col' },               ['D', 'A', 'H'].map(value => (                 React.createElement('div', { className: 'form-check', key: value },                   React.createElement('input', {                     type: 'radio',                     className: 'form-check-input',                     id: `radio${value}`,                     name: 'active_cd',                     value: value,                     checked: bindModel.cols.active_cd.value === value,                     onChange: handleChange                   }),                   React.createElement('label', { className: 'form-check-label', htmlFor: `radio${value}` },                     value === 'D' ? 'Standby' : value === 'A' ? 'Activation' : 'Hidden'                   )                 )               ))             )           )         ),         React.createElement('button', { type: 'button', className: 'btn btn-primary mt-3', onClick: ()=> bindModel.cmd['update'].execute() }, 'Update'),         React.createElement('button', { type: 'button', className: 'btn btn-primary mt-3', onClick: ()=> bindModel.cmd['delete'].execute() }, 'Delete'),         React.createElement('button', { type: 'button', className: 'btn btn-primary mt-3', onClick: ()=> bindModel.cmd['list'].execute() }, 'List')       )     );   } } ```   ### components/NoticeList.js ---  ```js import React, { Component } from 'https://esm.sh/react';  export default class NoticeList extends Component {   render() {     const { bindModel } = this.props;     const rows = bindModel.cmd.list.output.rows;      return (       React.createElement('table', { className: 'table' },         React.createElement('thead', null,           React.createElement('tr', null,             React.createElement('th', null, 'Title'),             React.createElement('th', null, 'Status'),             React.createElement('th', null, 'Date')           )         ),         React.createElement('tbody', null,           rows.count > 0 ? (             rows.map((notice, i) => (               React.createElement('tr', { key: notice.ntc_idx },                 React.createElement('td', null,                   React.createElement('a', { href: '#', onClick: () => bindModel.fn.handleRead(i), className: 'btnNormal' },                     notice.title                   )                 ),                 React.createElement('td', null, notice.active_cd),                 React.createElement('td', null, notice.create_dt)               )             ))           ) : (             React.createElement('tr', null,               React.createElement('td', { colSpan: '3' }, 'There is no content.')             )           )         )       )     );   } } ```    ","url": "http://localhost:4000/exam/notice-mix-react/"
  },{
    "title": "notice Vue Mix",
    "excerpt":"## Description  As an example of \"Notice\", we excluded the user page as a page.  ## folder structure ```js vue-mix/ ├── componets/ │   ├── NoticeForm.js │   └── NoticeList.js ├── service/ │   └── notice-admin-svc.js ├── app.js └── admin.html ```  ### admin.html ---  ```html      Notice Admin Page               Notice Admin Page    Key Features: List inquiry/modification/deletion    Data is transmitted when modified or deleted from the test page, but it is not actually processed.                      ```  ### app.js ---  ```js import NoticeList from './components/NoticeList.js'; import NoticeForm from './components/NoticeForm.js'; import NoticeAdminService from './service/notice-admin-svc.js'  const { createApp, ref } = Vue const bm = new _L.BindModel(new NoticeAdminService());    bm.url =' /notice/data/list.json';  const app = createApp({   data() {     return {       notices: [],       selectedNotice: null,       statusOptions: {         'D': 'Standby',         'A': 'Activation',         'H': 'Hidden'       },       bindModel: bm,     };   },   methods: {     selectNotice(idx) {       this.selectedNotice = idx;     },     deselectNotice() {       this.selectedNotice = null;     },   },   components: {     'notice-list': NoticeList,     'notice-form': NoticeForm   } });  app.mount('#app'); ```  ### service/notice-admin-svc.js ---  ```js class NoticeAdminService {     constructor() {         var _this       = this;         var _template   = null;     // Handlebars template          this.items = {             ntc_idx: { required: true },             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             list:       {                 outputOption: 1,             }         };          this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };     }     }  export {     NoticeAdminService as default,     NoticeAdminService } ```  ### components/NoticeForm.js ---  ```js export default {     props: ['statusOptions', 'bindModel'],     data() {       return {         formData: { ...this.notice }       };     },     emits: ['deselect-notice'],     template: `                                        날짜             {{ bindModel.cols.create_dt.value }}                                    Title                                                Content                                                                                                 Top notice                                                                                          {{ label }}                                                  Update           Delete           List                     `,     async created() {       var _this = this;        this.bindModel.cmd['update'].cbEnd = function(status, cmd, res) {         if (res) {           alert('The post has been modified.');           _this.$emit('deselect-notice');         }       };       this.bindModel.cmd['delete'].cbEnd = function(status, cmd, res) {         if (res) {           alert('The post has been deleted.');           _this.$emit('deselect-notice');         }       };     },     methods: {       updateClick() {         for (var prop in this.formData) {           this.bindModel.columns[prop].value = this.formData[prop];         }         this.bindModel.cmd['update'].execute();       },       deleteClick() {         this.bindModel.cmd['delete'].execute();       }      }   }; ```  ### components/NoticeList.js ---  ```js export default {     props: ['bindModel'],     emits: ['select-notice'],     template: `                                        Title             Status             Date                                                     There is no content.                                   {{ notice.title }}             {{ notice.active_cd }}             {{ notice.create_dt }}                                `,     async created() {            await this.bindModel.cmd['list'].execute();     },     methods: {       async readClick(idx) {         this.bindModel.cmd['read'].outputOption.index = Number(idx);         await this.bindModel.cmd['read'].execute();         this.$emit('select-notice', idx);       }     }   }; ```   ","url": "http://localhost:4000/exam/notice-mix-vue/"
  },{
    "title": "Notice example",
    "excerpt":"## Example screen  ![image-left](/assets/images/notice-800.gif){: .align-center}   ## Configuring the Environment  ```sh git clone https://github.com/white-base/exam-bind-model.git cd exam-bind-model npx serve ```  ## props drilling issue  The problem of Props drilling with React, Vue, and Angular can be solved all at once by BindModel, which manages data centrally and clearly separates business logic to significantly improve maintenance and reusability.  BindModel's components, MetaTable and MetaView, are defined as standard interfaces, making screen configurations more flexible. React and Vue only manage screen-related responsibilities and delegate business logic to BindModel, allowing business logic to be reused on a variety of screens.  ","url": "http://localhost:4000/exam/notice/"
  },{
    "title": "Start",
    "excerpt":"## What is BindModel?  BindModel is a front-end framework that operates on the web and in Node.js environments. It is designed for simplicity and productivity based on commands and entities (Table, View). Once you are familiar with the basics of HTML, CSS, and JavaScript, you can easily create websites using BindModel.  - Manage all data as an entity (MetaTable, MetaView). - It acts as a controller in the MVC pattern and is completely separate from the View. - It provides a command-based processor to provide a consistent development pattern. - It is a harmonious collection of libraries needed for web development, such as routing, form management, and client-server communication. - It can be used in conjunction with other frameworks.         ## Installation  ### Installation using npm  To install BindModel in a Node.js environment, use the following command.  ```sh npm install logic-bind-model ```  ### Installing in a browser environment  In a browser environment, BindModel is available via CDN.  ```html  ```    ## Use  BindModel is the core object of the framework.  ### Server Environment (node.js)  In the Node.js environment, you can use the BindModel through a require or import statement.  Example: Using with CommonJS ```js const { BindModel } = require('logic-bind-model');  const bm = new BindModel(); ```   Example: Using with ES6 ```js import { BindModel } from 'logic-bind-model';    const bm = new BindModel(); ```  ### HTML Environment  In the browser environment, it is accessed through the '_L' global variable.   Example: Using in HTML Environments ```html       ```   ## Packaging  BindModel relies on axios and jQuery modules to perform asynchronous communication and DOM operations with the server; reflecting this dependency, it provides a variety of deployment packages.  ### bindmodel.js  This package contains only BindModel and does not include axios and jQuery. This package is useful when externally already including axios and jQuery, or if you are managing them separately.  ### bindmodel.pack.js  This package contains the axios and jQuery libraries along with BindModel. This package can be fully functional with just one bind-model.pack.js, without having to install axios or jQuery from the outside.   {% capture notice-text %} 'Packy name + min.js' is a compressed file. * bindmodel.min.js * bindmodel.pack.min.js {% endcapture %}     See :    {{ notice-text | markdownify }} ","url": "http://localhost:4000/en/docs/quick-start/"
  },{
    "title": "Configure Service objects",
    "excerpt":"Service objects make it easy to create 'BindModel' objects, and inheritance can separate common areas for increased reuse.  The 'BindModel' object can be accessed by the this.bindModel property in the callback function.  Type: ServiceType ```ts // items area type KeyType = 'none' | 'value' | 'text' | 'html' | 'prop' | 'attr' | 'css'; type SelectorType = { key: string, type: KeyType }; type RegExpType = { reg: RegExp, msg: string, return?: boolean }; type FuncType = (value: any) => boolean; type ConstraintType = RegExpType | FuncType; type ColumnType = { \tselector?: SelectorType, \tgetter?: () => any, \tsetter?: (val: any) => any, \tgetFilter?: () => any, \tsetFilter?: (val; any) => any, \tdefault?: stirng | number | boolean | null, \tvalue?: any, \talias?: string, \tcaption?: string, \tconstraints?: ConstraintType[] | ConstraintType, \trequired?: boolean | false, \tcolumnName?: string }; type Itemtype = { \t[key: string]: string | number | boolean | ColumnType }; // command area type CmdValueType = { \toutputOption?: 0 | 1 | 2 | 3,  // alias : outOpt \tconfig?: see axiosConfig, // axios type \turl?: string, \tviews?: string[], \tcbBegin?: (cmd: BindCommand) => void, \tcbValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBind?: (view: MetaView, cmd: BindCommand, cfg: object) => void, \tcbResult?: (data: object, cmd: BindCommand, res: object) => object, \tcbOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, }; type CommandType = { \t[key: string]: CmdValueType }; // mapping area typeColumnName = string; // 'item name' | 'column name' | 'table name.column name'; type CommandName = '$all' | string;  // string = 'command name' type ViewName = 'valid' | 'bind' | 'output' | '$all' | string; // add view name type MappingType = { \t[key: ColumnName]: { \t\t[key: CommandName]: ViewName | ViewName[] \t} }; // fn area type fnType = { \t[key: string]: Function }; // ------------------------- // service area type ServiceType = { \ttables?: string | string[], \tbaseConfig?: axiosConfig,  // // axios type \turl?: string, \tcbBaseBegin?: (cmd: BindCommand) => void; \tcbBaseValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBaseBind?: (view: MetaView, cmd: BindCommand, cfg) => void, \tcbBaseResult?: (data: object, cmd: BindCommand, res) => object, \tcbBaseOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbBaseEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, \titems?: Itemtype, \tcommand?: CommandType, \tmapping?: MappingType, \tfn?: fnType, \tpreRegister?: (bindModel) => void', \tpreCheck?: (bindModel) => boolean', \tpreReady?: (bindModel) => void,  }; ```  # Service Object  ## Configuring the Default Area  Configures the default callback function and server request information for the service object.   Type: Default server request and default callback function ```ts // Configuring Callback and Server Requests on Service Objects type ServiceType = { \tbaseConfig?: axiosConfig,  // axios 타입 참조 \turl?: string, \tcbBaseBegin?: (cmd: BindCommand) => void; \tcbBaseValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBaseBind?: (view: MetaView, cmd: BindCommand, cfg) => void, \tcbBaseResult?: (data: object, cmd: BindCommand, res) => object, \tcbBaseOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbBaseEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, }; ``` - 'url' is the value of 'baseConfig.url'.  Example: Basic ```js var bm = new BindModel({ \t// Default Server Request \tbaseConfig: { method: 'GET' }, \turl: '/user', \t// Default callback function \tcbBaseBegin: function(cmd) {  \t\tconsole.log ('default start callback);  \t}, \tcbBaseValid: function(view, cmd) { \t\tconsole.log ('default validation callback); \t\treturn true; \t}, \tcbBaseBind: function(view, cmd, cfg) {  \t\tconsole.log ('Basic Server Request Callback');  \t}, \tcbBaseResult: function(data, cmd, res) { \t\tconsole.log ('Default Server Response Callback'); \t\treturn data; \t}, \tcbBaseOutput: function(vidw, cmd, res) => {  \t\tconsole.log ('Default Response Output Callback');  \t}, \tcbBaseEnd: function(status, cmd, res) => {  \t\tconsole.log ('Default Termination Callback');  \t},\t }); ```  Example: Basic Configuration by Method ```js var bm = new BindModel();  // Default Server Settings bm.baseConfig = { method: 'GET', url: '/user' }; bm.cbBaseBegin = function(cmd) {  \tconsole.log ('default start callback);  };  // Default callback function bm.cbBaseValid: function(view, cmd) { \tconsole.log ('default validation callback); \treturn true; }; bm.cbBaseBind: function(view, cmd, cfg) {  \tconsole.log ('Basic Server Request Callback');  }; bm.cbBaseResult: function(data, cmd, res) { \tconsole.log ('Default Server Response Callback'); \treturn data; }; bm.cbBaseOutput: function(vidw, cmd, res) => {  \tconsole.log ('Default Response Output Callback');  }; bm.cbBaseEnd: function(status, cmd, res) => {  \tconsole.log ('Default Termination Callback');  }; ``` - Same as the service object configured above.  The default configuration can be set by command, and 'command' has a higher priority than the default configuration.  ## Configuring a Table Area  Configures additional table information for service objects.   Type: Tables ```ts // Configuring Tables in a Service Object type ServiceType = { \ttables?: string | string[], }; ```  The 'BindModel' object automatically generates and uses the 'MetaTable' named 'first'. Set the additional table to the 'tables' property.   ```js var bm = new BindModel({     tables: ['second', 'third'] });  // Refer to the main table // bm.first === bm._tables['first']  // true // bm.first === bm._tables[0]        // true  // See Additional Table // bm.second === bm._tables['second'] // true // bm.second === bm._tables[1]        // true // bm.third === bm._tables['third']   // true // bm.third === bm._tables[2]         // true ``` - Use when you need an additional table.  Example: Configuring a Table by Method ```js var bm = new BindModel();  // Create a table bm.addTable('second'); bm.addTable('third'); ``` - Same as the service object configured above.   ## Configuring the Item Area  Configures the column raw value for the service object.  ### Setting Raw Values for Columns  - items Each element has the raw value of the column.  - If the key value of items is of type 'string, number, boolean, null', it is set to the value of the column.  - If the key value of items is of the 'object' type, it is used as the property value of the column.  Type: items ```ts type KeyType = 'none' | 'value' | 'text' | 'html' | 'prop' | 'attr' | 'css'; type SelectorType = { key: string, type: KeyType }; type RegExpType = {reg: RegExp, msg: string, return?: boolean = true}; type FuncType = (value: any) => boolean; type ConstraintType = RegExpType | FuncType; type ColumnType = { \tselector?: SelectorType, \tgetter?: () => any, \tsetter?: (val: any) => any, \tgetFilter?: () => any, \tsetFilter?: (val: any) => any, \tdefault?: stirng | number | boolean | null, \tvalue?: any, \talias?: string, \tcaption?: string, \tconstraints?: ConstraintType[] | ConstraintType, \trequired?: boolean | false, \tcolumnName?: string }; type Itemtype = { \t[key: string]: string | number | boolean | ColumnType }; // Configuring items in a service object type ServiceType = { \titems?: ItemType }; ```  ### item naming rule - Column Name : The column is registered in the default table. - Table name.Column name: The column is registered in the target table. ### items property description - 'string, number, boolean, null ': The raw value is set to the value of the column. - selector : Selector to use when importing or setting the value of a column from DOM. - setter : A function to use when setting an external value. - getter : A function to use when importing values from outside. - required : Sets whether the column value is required or not. - setFilter : A filter function to use when setting the value. - getFilter —Filter function to use to import value. - constructs —Set the constraints of the value with a regular expression or user function, used for validation.  [[54. HTML Column Class-B|Refer to HTML Column]]   Example: items ```js var bm = new BindModel({ \t// Create additional tables \ttables: 'second', \t \t// Create an item \titems: { \t\taa: 'Cat', \t\t'second.bb': 10, \t\t'second.cc': true, \t\tdd: { \t\t\tselector: { key: '#U_ID', type: 'value' },  // 컬럼의 selector 설정 \t\t\tsetter: (val) => {/*Outside setting area*/}, // Setter for column \t\t\tgetter: () => { return 'external value'; }, // set getter for column \t\t}, \t\tee: { \t\t\trequired: true, // required setting of column \t\t\tsetFilter: (val) => {/*Outside setting area*/}, // SetFilter on column \t\t\tgetFilter: () => { return 'external value'; }, // set getFilter for column \t\t}, \t\tff: { \t\t\tconstructs: {reg: /abc/, msg: 'Failed to match!' } // Set Constraints for Column \t\t} \t} }); ``` - The item aa' is registered as a column in the default table, and 'Cat' is set in the value. - The item 'bb' registers as a column in the second table, and sets value to 10. - The cc' item registers as a column in the second table and sets true to the value.  Example: Configuring an Item Using the Method ```js var bm = new BindModel();  // Create additional tables bm.addTable('second');  // Create an item bm.items.add('aa', 'Cat'); bm.items.add('second.bb', 10); bm.items.add('second.cc', true); bm.items.add('dd', { \tselector: { key: '#U_ID', type: 'value' }, \tsetter: function(val) {/*external setting area*/}, \tgetter: function() { return '외부값'; },  }); bm.items.add('ee', { \trequired: true, \tsetFilter: function(val) {/*external setting*/}, \tgetFilter: function() { return '외부값'; }, }); bm.items.add('ff', { \tconstructs: {reg: /abc/, msg: 'Failed to match!' } }); ``` - Same as the service object configured above.  Items can also help manage data when registering the same column in multiple tables.  ## Configuring Command Areas  Configures command information for a service object.  Type: command ```ts type CmdValueType = { \toutputOption?: 0 | 1 | 2 | 3,  // 별칭 : outOpt \tconfig?: see axiosConfig, // axios type \turl?: string, \tviews?: string[], \tcbBegin?: (cmd: BindCommand) => void, \tcbValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBind?: (view: MetaView, cmd: BindCommand, cfg: object) => void, \tcbResult?: (data: object, cmd: BindCommand, res: object) => object, \tcbOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, }; type CommandType = { \t[key: string]: CmdValueType }; // Configuring a command in a service object type ServiceType = { \tcommand?: CommandType, }; ``` - For 'CmdValueType.url', see the value 'CmdValueType.config.url'. - 'CommandType' key is the name of the 'command' to be added.  ### Command Type Description -  outputOption —Specifies how the view is output; the default is 0.  -  config : Same as the setting object of axios. -  url : 'config.url' value, setting the URL path to request via axios. - views —Name of the output view (MetaView) to be added. - cbBegin : This is the callback function before the start. - cbValid : Validation callback function. - cbBind : This is the server request callback function. - cbResult —The server response callback function. - cbOutput —Answer output callback function. - cbEnd —Callback function before termination.  [24. Bind Command Composition - C#Callback (Attribute)] Example: command ```js var bm = new BindModel({ \tcommand: { \t\tcreate: {}, \t\tread: { \t\t\toutputOption: 3, // Set data to column value (specified column) \t\t\tconfig: {method: 'GET' }, // GET request setting \t\t\tcbEnd: function() { alarm('Normal Processed') ; } // Callback function after processing is completed \t\t}, \t\tupdate: { \t\t\tviews: ['two'], // adding 'two' views \t\t\turl: '/user' // URL path to request \t\t} \t} }); ``` - I created \"create\"  \t- Set the default output option = 0. - We created \"read\" \t- Set output option = 3 \t- Set the config server request and \t- Sets the cbEnd callback function. - Create 'update' and \t- Set the default output option = 0 and \t- I'll add \"two\" to the output view \t- Set the server request url.  Example: Configuring Commands by Method ```js var bm = new BindModel(); // command generation bm.addCommand('create'); bm.addCommand('read'); bm.addCommand('update');  // Set the read command bm.commmand['read'].outputOption = 3; bm.commmand['read'].config = { method: 'GET' }; bm.commmand['read'].cbEnd = {  \talert('Normal Processed'); };  // update command setting bm.commmand['update'].newOutput('two'); bm.commmand['update'].url = '/user'; ``` - Same as the service object configured above.   ## Configuring Mapping Areas  Configure the mapping of items and 'command' in the service object.  Type: Mapping ```ts typeColumnName = string; // 'item name' | 'column name' | 'table name.column name'; type CommandName = '$all' | string;  // string = '명령 이름' type ViewName = 'valid' | 'bind' | 'output' | '$all' | string; // 추가 뷰 이름 type MappingType = { \t[key: ColumnName]: { \t\t[key: CommandName]: ViewName | ViewName[] \t} }; // Configuring Mapping on a Service Object type ServiceType = { \tmapping?: MappingType }; ```  ### Mapping Rules - Column Name  \t- 'Column Name' : The column in the base table is selected. \t- ''Table name.Column name' : A column for the specified table is selected. (Create when none exists) #REVIEW - Command Name  \t- ' 'command name' : The specified command is selected. \t- '$all' : Full command is selected. - View Name (ViewName) \t- 'valid', 'bind', 'output' : Map to the selected MetaView (multiple is specified as array) \t- '$all' : Map to the entire MetaView (including added output) \t [00. Column mapping]  Example: Mapping ```js var bm = new BindModel(); bm.setService({ \t// Table Area \ttables: ['second'], \t// Item Area \titems: { \t\taa: '', \t\tbb: '', \t\tcc: '', \t\tdd: '' \t}, \t// command area \tcommand: { \t\tone: {}, \t\ttwo: {}, \t}, \t// Mapping area \tmapping: { \t\taa: { $all: ['valid']}, // Register 'aa' in the 'valid' view of all commands \t\tbb: {one: ['bind']}, // Register 'bbb' in 'bind' view of 'one' command \t\t'second.cc ': {two: ['output'] } // Register 'cc' in 'output' view of 'two' command \t} });  // bm.items.count == 4 ('aa','bb','cc','dd') // bm.first.columns.count == 2 ('aa','bb') // bm.second.columns.count == 1 ('cc') // bm.cmd['one'].valid.columns.count == 1 ('aa') // bm.cmd['one'].bind.columns.count == 1 ('bb') // bm.cmd['one'].output.columns.count == 0 // bm.cmd['two'].valid.columns.count == 1 ('aa') // bm.cmd['two'].bind.columns.count == 0 // bm.cmd['two'].output.columns.count  == 1 ('cc') ``` - Items 'aa' are registered in the default table and mapped to the valid (MetaVeiw) of all commnads. - Items 'bbb' are registered in the default table and mapped to the bind (MetaVeiw) of the 'one' command. - The 'cc' item is registered in the 'second' table and mapped to the output (MetaVeiw) of the 'two' command.  Type: setMapping() ```ts type setMapping( \tmapping: PropertyCollection | object,  \tbTable?: MetaTable | string ) => void; ``` - mapping : The collection to be mapped. - bTable : Default table to be mapped, default is \\_baseTable.  Example: Configuring Mapping by Method ```js var bm = new BindModel();  // Create additional tables bm.addTable('second');  // Create an item bm.items.add('aa', ''); bm.items.add('bb', ''); bm.items.add('cc', ''); bm.items.add('dd', '');  // command generation bm.addCommand('one'); bm.addCommand('two');  // Item mapping bm.setMapping({ \taa: { $all: ['valid']}, // Register 'aa' in the 'valid' view of all commands \tbb: {one: ['bind']}, // Register 'bbb' in 'bind' view of 'one' command \t'second.cc ': {two: ['output'] } // Register 'cc' in 'output' view of 'two' command }) ``` - Same as the service object configured above.  You can efficiently map the columns required for a specific view of each command, which helps to maintain consistency in data processing and improve management convenience.  ## Configuring a Function Area  Configures the user function of the service object.  Type : fn ```ts type fnType = { \t[key: string]: Function; }; // Configuring fn in a service object type ServiceType = { \tfn?: fnType }; ``` - The key is the user function name.  Example: fn ```js var bm = new BindModel({ \tcbBaseBegin: function(cmd) { \t\tAccess the parameter at cmd._model.fn.ecCreate(); //cmd \t\tthis.bindModel.fn.sum(1, 1); // this.bindModel로 접근 \t}, \tcommand: { \t\tcreate: { \t\t\tcbEnd: function() { \t\t\t\tthis.bindModel.fn.sum(1, 2); \t\t\t} \t\t}, \t}, \tfn: { \t\tsum: function(a, b) {return a + b}, \t\texecCreate: function() { \t\t\tthis.bindModel.cmd.read.execute(); \t\t} \t} });  // Register for an event $('#btn_create').click(function() { \tbm.fn.execCreate(); });  ``` - You can access the BindModel object with the 'parameter' or 'this.bindModel' properties in the callback function.  Example: Configuring a Method as a Function ```js var bm = new BindModel();  // Configuring Functions bm.fn.add('sum', function(a, b) {return a + b}); bm.fn.add('execCreate', function() { \tthis.bindModel.cmd.read.execute(); // this.bindModel 로 접근 });  // Common callback configuration bm.cbBaseBegin = function(cmd) { \tcmd._model.fn.ecCreate(); // Access to the cmd parameter \tthis.bindModel.fn.sum(1, 1); // this.bindModel 로 접근 };  // Configuring Commands bm.addCommand('create'); bm.command['create'].cbEnd = function() { \tthis.bindModel.fn.sum(1, 2);  // this.bindModel 로 접근 }  // Register for an event $('#btn_create').click(function() { \tbm.fn.execCreate(); // Access functions from outside }); ``` - Same as the service object configured above.  Each area can increase the degree of engagement and increase reusability and maintenance.   ## Configuring the Preprocessing Area  Configures preprocessing information for service objects, primarily used to automate service objects.  타입 : init(), preRegister, preCheck, preReady ```ts type init = () => void;  type preRegister = (bindModel) => void;  type preCheck = (bindModel) => boolean;  type preReady = (bindModel) => void;  ```  ### Preprocessing Call Flow  1. The init() mesodle calls are preRegister, preCheck, and preReady sequentially. 2. If you return false from preCheck, preReady is called cbFail without calling. 3. If you return true from preCheck, a preReady call is made.  Preprocessing is used for interaction between service objects and screen pages or selector validation.  Example: Pre-processing ```js var bm = new BindModel({ \tpreRegister: function(bindModel) {  \t\t// Pre-processing: Before the inspection \t}, \tpreCheck: function(bindModel) { \t\t// Pre-processing: Inspection \t\tif (bm.checkSelector().length === 0) return true; \t}, \tpreReady: function(bindModel) {  \t\t// Pre-processing: Ready \t\tbindModel.command['test'].execute(); \t}, });  $(document).ready(function () { \tbm.init(); }); ``` - When the page is ready, call the init() method to inspect the DOM and run the 'test' command.  Example: Pre-processing a Method ```js var bm = new BindModel(); // BindModel Settings...  bm.preRegister = function(bindModel) {  \t// Pre-processing: Before the inspection }; bm.preCheck = function(bindModel) {  \t// Pre-processing: Inspection \tif (bm.checkSelector().length === 0) return true; }; bm.preReady = function(bindModel) {  \t// Pre-processing: Ready \tbindModel.command['test'].execute(); };  $(document).ready(function () { \tbm.init(); });  ``` - Same as the service object configured above.  Pre-processing areas can be utilized if automation is required.  # function  ## To inject service objects  When creating a 'BindModel' object, you can either pass parameters or call the setService() method to inject service objects.   Type: setservice() ```ts type setService = (service: IService, isTypeCheck: boolean = false) => void; ``` -  service —The service object to be injected. - isTypeCheck : Sets whether to perform a type check; the default is false.  As a setService() method, it separates service objects to enhance readability and maintenance of code.  Example: Injection via Creator ```js var bm1 = new BindModel({ \titems: {         aa: 'Cat',         bb: 10,         cc: true,     },     fn: {         sum: function(a, b) { return a + b; },     },     url: '/user',     command: {         read: {             outputOption: 3,             cbEnd: function() { console.log('Normal Processed'); }         },         update: {             views: ['two'],             url: '/user'         }     },     mapping: {         aa: { $all: ['valid'] },         bb: { read: ['bind'], update: 'output' },         cc: { update: ['output'] }     }, }); ```  Example: Inject with setService() Method ```js // items, fn configuration var svcItems = { \titems: {         aa: 'Cat',         bb: 10,         cc: true,     },     fn: {         sum: function(a, b) { return a + b; },     } };  // Other configurations var svcCommon = {     baseConfig: { method: 'GET' },     url: '/user',     command: {         read: {             outputOption: 3,             config: { method: 'GET' },             cbEnd: function() { console.log('Normal Processed'); }         },     },     mapping: {         aa: { $all: ['valid'] },         bb: { read: ['bind'], update: 'output' },         cc: { update: ['output'] }     }, };  barbm = new BindModel(); // Injection by Parameters  bm2.setService(svcItems); bm2.setService(svcCommon); ``` - Same as the service object configured above. - In the first setService() method call, set items, fn to service. - The second setService() method call sets up services such as command, mapping, and so on.  Duplicate settings retain the last-minute value, and are added for event values.  Areas 'items', 'fn' have low dependence on other areas. Service objects allow you to manage common settings and increase reusability.  ## Defining a service class  ### Create a service object through inheritance  You can create a service in a class to increase the reuse of the common part of the code. Service classes can be used in various structures.  common-svc.js ```js class CommonService() { \tcbFail = function(msg) { \t\tconsole.warn (\"user failure handling:+ msg\"); \t}; \tcbError = function(msg) { \t\tconsole.error (\"User error handling\") \t}; } ``` - Common areas were created as common service classes.  member-svc.js ```js class MemberService(suffix) extends CommonService { \titems = { \t\tidx: -1, \t\tuser_no: { selector: { key: '#user_no'+ suffix, type: 'value' } }, \t\tu_name: { selector: { key: '#u_name'+ suffix, type: 'value' } }, \t}; \tcommand = { \t\tcreate: 0, \t\tread: { \t\t\toutputOption: 3, \t\t\tcbEnd: () => { alert('Normal Processed'); } \t\t} \t}; \tmapping = { \t\tidx: {  \t\t\tread: ['valid', 'bind']  \t\t}, \t\tu_name: {  \t\t\tcreate: ['valid', 'bind'], \t\t\tread: ['output'] \t\t}, \t\tuser_no: {  \t\t\tcreate: ['bind'], \t\t\tread:: ['output'], \t\t} \t}; \tpreCheck = function(bindModel) {  \t\tif (bm.checkSelector().length === 0) return true; \t} }; ``` - The suffix parameter is a prefix for preventing conflicts in the selector name.  member.html ```html   \tClass number     \t이름   추가      ``` - When the page is ready, the init() method is called to validate the selector in preReady. - When you click the 'Add' button, run command.create.execute() to bind the server request result to the screen.  Easy to manage common parts such as paging processing on the screen.   ","url": "http://localhost:4000/docs/service-config/"
  },{
    "title": "Step-by-step process",
    "excerpt":"It is an HTML production process that uses BindModel to process customer information registration, inquiry, and correction functions.  ## Registering customer information  Since it is a screen that is used by sharing columns in several commands, it was created using the service object injection method. ### 1. Create membership HTML  ```html  \tname    \tman \twoman\t   \ttel    등록 ``` - This HTML includes an entry field and a register button to enter your username, gender, and contact information. ### 2. Set Items and Commands  ```js var bm = new BindModel({ \titems: { \t\tuser_name: { \t\t\tselector: { key: '#user_name', type: 'value' }, \t\t\trequired: true \t\t}, \t\tgender: { \t\t\tsetFilter: function(val) {  \t\t\t\t$('input[name=gender][value='+ val + ']').prop('checked',true); \t\t\t}, \t\t\tgetFilter: function() {  \t\t\t\treturn $('input[name=gender]:checked').val()  \t\t\t} \t\t}, \t\ttel: { \t\t\tselector: { key: '#tel', type: 'value' }, \t\t\tconstraints: [ \t\t\t\t{ regex: /\\d{3}-\\d{3,4}-\\d{4}/, msg: \"Not in phone number format.\"} \t\t\t] \t\t} \t}, \tcommand: { \t\tcreate: { \t\t\tcbEnd: function() { \t\t\t\talert( 'Registration processed successfully'); \t\t\t} \t\t} \t}, \tmapping: { \t\tuser_name: { create: ['valid', 'bind'] }, \t\tgender:    { create: ['bind'] }, \t\ttel:       { create: ['bind', 'bind'] } \t} }); bm.url = '/user'; ``` - items define the input fields and their characteristics. \t- user_name : Binds with element with ID 'user_name' and is required. \t- gender : Use a filter to set and import radio buttons. \t- tel: contains a validation that binds to an element with ID 'tel' and checks the phone number format. - command defines the interaction with the server. \t- create—Registration-related command, including a callback function that alerts you upon completion. - Mapping defines the mapping between items and commands. \t- Sets how the user_name, gender, and tel fields are mapped to the create command.  ### 3. Event registration  ```js $('#btn_create').click(() => bm.command['create'].execute()); ``` - When the register button is clicked, run the create command.  ## Looking up customer information  Example Server Data ```json // Restful :/user/1 { \t\"rows\": [ \t\t{ \t\t\t\"user_name\": \"Hong Gildong\", \t\t\t\"gender\": \"male\", \t\t\t\"tel\": \"010-123-1234\" \t\t} \t] } ``` - Data in JSON format that you will receive when you query the server. ### 1. Add html  ```html  ``` - Add a hidden field to store the ID of the customer you want to look up.  ### 2. items, command, mapping 추가  ```js var bm = new BindModel({ \titems: { \t\tidx: { \t\t\tselector: { key: '#idx', type: 'value' }, \t\t} \t}, \tcommand: { \t\tread: { \t\t\toutputOption: 3 \t\t} \t}, \tmapping: { \t\tidx:       { read: ['valid', 'bind'] }, \t\tuser_name: { read: ['output'] }, \t\tgender:    { read: ['output'] }, \t\ttel:       { read: ['output'] } \t} }); ``` -  Save the customer ID by adding the idx item to the items. - Define the lookup function by adding the read command to the command. - Mapping maps idx, user_name, gender, tel items to read commands.  ### 3. Get idx from url and read it  ```js   $(document).ready(function () { \tvar idx = window.location.href.split('=')[1]; \tif (idx) { \t\t$(\"#idx\").val(idx);  // input hidden 설정 \t\tbm.command['read'].execute(); \t} }); ``` - When the page loads, take the idx value from the URL and set it in the idx column, run the read command to query the data.  ## To modify customer information  ### 1. Add a modification button  ```html 수정 ``` - Add the Modify button.  ### 2. Add command and mapping  ```js var bm = new BindModel({ \tcommand: { \t\tupdate: { \t\t\tcbEnd: function() { \t\t\t\talert('Corrected processed'); \t\t\t} \t\t} \t}, \tmapping: { \t\tuser_name: { update: ['valid', 'bind'] }, \t\tgender:    { update: ['bind'] }, \t\ttel:       { update: ['bind', 'bind'] } \t} }); ``` -  Define modifications by adding the update command to the command. -  In mapping, map the user_name, gender, and tel columns with the update command. ### 3. Event registration  ```js $('#btn_update').click(() => bm.command['update'].execute()); ``` - When the edit button is clicked, run the update command.   ## Full Source (Inquiry, Registration, Modification)  ### 1. Body area  ```html   \tname    \tman \twoman\t   \ttel    create update ```  ### 2. Script Area  ```html  ```  This code is a simple and intuitive example of using BindModel to establish binding between input fields and commands and interactions with servers. It contains all the elements needed to implement the ability to register, query, and modify customer information, and efficiently handles user input and data exchange between servers. ","url": "http://localhost:4000/docs/step-by-step/"
  },{
    "title": "Synchronization",
    "excerpt":"The execute() method of the Bindcommand object returns Promise, so you can use the async and wait keywords to execute commands asynchronously and write synchronization codes if necessary.   Type: execute() ```ts type execute () => Promise; ```  ## Example of synchronizing single-flawed fish  The following code executes a command called 'read_member' and displays a notification after that command is complete. ```js var bm = new BindModel();  bm.addCommand('read_member', 3); // ... omit column settings  async function readView() {     try {         await bm.cmd['read_member'].execute();         alert( 'Called membership information');     } catch (error) {         console.error ('Error encountered during command execution:', error);     } } ``` - In this code, the execute() method returns Promise, so use the wait keyword to wait for the command to complete. If the command completes successfully, a notification message is displayed. You can also use the try...catch block to handle errors that may occur during the execution of the command.   ## Multiple Command Synchronization Example  The following code executes two commands in sequence: read_meb and read_corp. ```js var bm = new BindModel();  bm.addCommand('read_meb', 3); bm.addCommand('read_corp', 3); // ... omit column settings  async function readView() {     try {         await bm.cmd['read_meb'].execute();         console.log ('calling private membership information');                  await bm.cmd['read_corp'].execute();         console.log ('could get corporation information');     } catch (error) {         console.error ('Error encountered during command execution:', error);     } } ``` - The code executes two commands in sequence, and outputs a log message each time they complete. Use the try...catch block to handle errors that may occur during the execution of both commands.  ## Example of a Simultaneous Run  Promise.all is available if you need to run commands simultaneously instead of sequentially.  ```js var bm = new BindModel();  bm.addCommand('read_meb', 3); bm.addCommand('read_corp', 3); // ... Column Settings async function readView() {     try {         await Promise.all([             bm.cmd['read_meb'].execute(),             bm.cmd['read_corp'].execute()         ]);         console.log ('Called all information');     } catch (error) {         console.error ('Error encountered during command execution:', error);     } } ``` - In this code, use Promise.all to run both commands at the same time, and wait for all commands to complete. Once all commands have completed successfully, a log message will be output. If an error occurs, the catch block will handle it.  This makes it easy to synchronize promise-based asynchronous code using the async and wait keywords, allowing you to control the order of command execution and handle errors. ","url": "http://localhost:4000/docs/synchronization/"
  }]
