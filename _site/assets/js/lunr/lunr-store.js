var store = [{
        "title": "Edge Case: Nested and Mixed Lists",
        "excerpt":"Nested and mixed lists are an interesting beast. It’s a corner case to make sure that      Lists within lists do not break the ordered list numbering order   Your list styles go deep enough.   Ordered – Unordered – Ordered      ordered item   ordered item            unordered       unordered                 ordered item       ordered item           ordered item   ordered item   Ordered – Unordered – Unordered      ordered item   ordered item            unordered       unordered                 unordered item       unordered item           ordered item   ordered item   Unordered – Ordered – Unordered      unordered item   unordered item            ordered       ordered                    unordered item           unordered item                           unordered item   unordered item   Unordered – Unordered – Ordered      unordered item   unordered item            unordered       unordered                    ordered item           ordered item                           unordered item   unordered item   Task Lists      Finish my changes   Push my commits to GitHub   Open a pull request            Follow discussions       Push new commits          ","categories": ["Edge","View"],
        "tags": ["content","css","edge case","lists","markup"],
        "url": "/edge/view/edge-case-nested-and-mixed-lists/",
        "teaser": null
      },{
        "title": "Edge Case: Many Tags",
        "excerpt":"This post has many tags.  ","categories": ["en","Edge Case"],
        "tags": ["8BIT","alignment","Articles","captions","categories","chat","comments","content","css","dowork","edge case","embeds","excerpt","Fail","featured image","FTW","Fun","gallery","html","image","Jekyll","layout","link","Love","markup","Mothership","Must Read","Nailed It","Pictures","Post Formats","quote","standard","Success","Swagger","Tags","template","title","twitter","Unseen","video","YouTube","U:R:COOL","C#"],
        "url": "/en/edge%20case/edge-case-many-tags/",
        "teaser": null
      },{
        "title": "Feedback & Suggestions",
        "excerpt":"We’d love to hear from you! Your feedback is incredibly valuable as we work to make this project better. Whether you spot an issue, have suggestions for improvement, or just want to share your experience, feel free to reach out!           💡 Notice something off or think of a way to improve?  We’re constantly growing and improving, and your input helps us get there faster! Drop us a line at bindmodel@gmail.com 😊            🚀 “Something’s broken!”  If you run into any issues or errors, don’t hesitate to let us know! Your feedback is our lifeline and can help us fix things pronto. Send us a message at bindmodel@gmail.com 😎            😊 How was your experience?  First impressions are important, and we’re eager to know how things went for you. Any thoughts, feedback, or suggestions are warmly welcomed. Email us at bindmodel@gmail.com 🙏      ","categories": ["en","post"],
        "tags": ["content","edge case","layout"],
        "url": "/en/post/edge-case-no-body-content/",
        "teaser": null
      },{
        "title": "피드백 및 제안",
        "excerpt":"여러분의 의견을 듣고 싶습니다! 이 프로젝트를 개선하기 위해 노력하는 동안 여러분의 피드백은 매우 귀중합니다. 문제를 발견했거나 개선할 사항이 있거나 경험을 공유하고 싶으시다면 언제든지 연락해 주세요!           💡 약간 이상한 점을 발견하거나 개선할 방법을 생각하시나요?  저희는 지속적으로 성장하고 개선하고 있으며, 여러분의 의견은 더 빠르게 도달하는 데 도움이 됩니다! bindmodel@gmail.com 😊로 연락주세요            🚀 “무언가 고장 났어요!”  문제나 오류가 발생하면 주저하지 말고 알려주세요! 피드백은 우리의 생명줄이며 문제를 해결하는 데 도움이 될 수 있습니다. bindmodel@gmail.com 😎로 메시지를 보내주세요            😊 경험은 어땠나요?  첫인상은 중요하며, 상황이 어떻게 진행되었는지 알고 싶습니다. 모든 생각, 피드백 또는 제안은 따뜻하게 환영합니다. 이메일(bindmodel@gmail.com 🙏)      ","categories": ["ko","post"],
        "tags": ["categories","edge case"],
        "url": "/ko/post/ko-feedback/",
        "teaser": null
      },{
    "title": "API Documentation",
    "excerpt":" ","url": "http://localhost:4000/en/docs/api/"
  },{
    "title": "API Documentation",
    "excerpt":" ","url": "http://localhost:4000/ko/docs/api/"
  },{
    "title": "기본 사용법",
    "excerpt":"BindModel 생성   BindModelAjax 객체 생성은 데이터 바인딩과 서버 간 통신을 위한 첫 번째 단계입니다.  이 객체는 서버와의 AJAX 통신을 관리하는 핵심 역할을 합니다.           참조 : BindModel 클래스     참조 : 서비스객체 구성      var bm = new BindModel();  bm.url = '/user';     ‘/user’ 경로는 사용자의 정보와 관련된 API 요청을 처리하기 위한 기본 경로로 설정됩니다.   ‘command’ 별로 ‘url’ 을 설정할 수도 있습니다.   command 추가   BindModelAjax 객체에 새로운 명령(command)을 추가하려면 addCommand() 메서드를 사용합니다. 이 메서드는 BindCommand 객체를 생성하고, 이를 BindModelAjax에 등록하여 서버와의 데이터 통신을 관리할 수 있도록 합니다.   BindCommand 객체는 서버와의 데이터 통신을 위해 세 가지 주요 역할을 하는 MetaView 객체들을 포함하고 있습니다.     valid : 데이터의 유효성을 검사하는 역할을 합니다.   bind : 클라이언트의 데이터가 서버에 전달되기 전에 데이터를 바인딩하는 역할을 합니다.   output : 서버로부터 수신된 데이터를 가져오는 역할을 합니다.           참조 : BindCommand 클래스      bm.addCommand('newCmd', 3);  // bm.command['newCmd'] === bm.cmd['newCmd'] // bm.command['newCmd'] instanceof BindCommand // bm.cmd['newCmd'].vallid instanceof MetaView // bm.cmd['newCmd'].bind instanceof MetaView // bm.cmd['newCmd'].output instanceof MetaView     출력옵션 에 따라 다르게 동작합니다. (범위 : 0, 1, 2, 3 )   'bm.command['명칭']' 으로 BindCommand 객체에 접근할 수 있습니다.   bm.cmd['명칭'] 는 동일한 객체를 참조하며, 이 중 더 짧은 bm.cmd 를 별칭으로 사용할 수 있습니다.           참조 : BindCommand 구성      column 추가   addColumn() 메서드는 BindModelAjax 객체에 컬럼을 추가하고, 지정된 BindCommand 객체의 MetaView에 컬럼을 설정하는 기능을 제공합니다. 추가적으로, addColumnValue() 메서드를 사용하여 컬럼의 초기값을 설정할 수 있습니다.   예시 : 빈 컬럼 추가  bm.addColumn('aa', 'newCmd', 'valid'); bm.addColumn('bb', 'newCmd', ['valid', 'bind']); bm.addColumn('cc', 'newCmd', '$all');     ‘aa’ 이름으로 컬럼을 추가하고 cmd[‘newCmd’] 의 valid(MetaView)에 설정합니다.   ‘bb’ 이름으로 컬럼을 추가하고 cmd[‘newCmd’] 의 ‘valid’, ‘bind’ 에 설정합니다.   ‘cc’ 이름으로 컬럼을 추가하고 cmd[‘newCmd’] 의 전체(‘valid’, ‘bind’, ‘output’)에 설정합니다.   예제 : 초기값으로 컬럼 추가  bm.addColumnValue('aa', 100, 'newCmd', 'valid'); bm.addColumnValue('bb', 'B', 'newCmd', ['valid', 'bind']); bm.addColumnValue('cc', true, 'newCmd', '$all');     ‘aa’ 이름으로 100 초기값으로 컬럼을 추가하고 cmd[‘newCmd’] 의 ‘valid’ 에 설정합니다.   ‘bb’ 이름으로 'B' 초기값으로 컬럼을 추가하고 cmd[‘newCmd’] 의 ‘valid’, ‘bind’ 에 설정합니다.   ‘cc’ 이름으로 true 초기값으로 컬럼을 추가하고 cmd[‘newCmd’] 의 전체에 설정합니다.   실행   BindCommand 객체의 execute() 메서드는 유효성 검사, 데이터 요청, 데이터 수신의 세 가지 주요 단계를 처리합니다. 각 단계는 콜백 함수를 통해 제어할 수 있으며, 이를 통해 요청의 흐름을 세부적으로 관리할 수 있습니다.   bm.command['newCmd'].execute();     execute() 메소드 호출시 세 가지 주요 단계를 거칩니다.            유효성 검사 : ‘valid’ 컬럼 유효성 검사를 진행하고, 실패하면 ‘cbFail’ 콜백을 호출합니다.       데이터 바인딩 : ‘bind’ 에 컬럼과 같을 서버경로에 요청합니다.       데이터 수신 : 수신된 데이터를 ‘output’ 으로 가져옵니다.          ","url": "http://localhost:4000/ko/docs/basic/"
  },{
    "title": "Basic usage",
    "excerpt":"Create BindModel   Creating ‘BindModel’ objects is the first step for data binding and server-to-server communication.  This object serves as the key to managing AJAX communication with the server.   [[52. BindModel Class-B| - Reference: BindModel Configuration] [25. Service Object Configuration-C|-Refer to: Service Object Configuration]   var bm = new BindModel();  bm.url = '/user';     The ‘/user’ path is set as the default path to handle API requests related to the user’s information.   You can also set “url” for each “command”.   Add command   To add a new command to a BindModel object, use the addcommand() method, which creates a Bindcommand object and registers it with the BindModel to manage data communication with the server.   The Bindcommand object contains MetaView objects that play three key roles in data communication with the server.     valid: serves to validate the data.   bind: serves to bind the client’s data before it is passed to the server.   output : It is responsible for fetching data received from the server.                  [53. Bind Command Class-B       - Reference: Bind Command Configuration]           bm.addCommand('newCmd', 3);  // bm.command['newCmd'] === bm.cmd['newCmd'] // bm.command['newCmd'] instanceof BindCommand // bm.cmd['newCmd'].vallid instanceof MetaView // bm.cmd['newCmd'].bind instanceof MetaView // bm.cmd['newCmd'].output instanceof MetaView     It operates differently depending on output options (range: 0, 1, 2, 3)   You can access the ‘Bindcommand’ object with ‘bm.command[‘name’]’.   ‘bm.cmd[‘name’]’ refers to the same object, of which shorter ‘bm.cmd’ can be used as an alias.                  [24. Bind Command Configuration - C# Type of Output Option       - Reference: Type of Output Option]           Add column   The addColumn() method provides the ability to add a column to a BindModel object and set the column to the MetaView for the specified Bindcommand object. Additionally, you can use the addColumnValue() method to set the initial value of the column.   Example: Adding an Empty Column  bm.addColumn('aa', 'newCmd', 'valid'); bm.addColumn('bb', 'newCmd', ['valid', 'bind']); bm.addColumn('cc', 'newCmd', '$all');     Add a column with the name ‘aa’ and set it to the valid (MetaView) in cmd[‘newCmd’].   Add a column with the name ‘bbb’ and set it to ‘valid’, ‘bind’ in cmd [‘newCmd’].   Add a column with the name ‘cc’ and set it to the whole of the cmd [‘newCmd’] (‘valid’, ‘bind’, ‘output’).   Example: Adding a column as an initial value  bm.addColumnValue('aa', 100, 'newCmd', 'valid'); bm.addColumnValue('bb', 'B', 'newCmd', ['valid', 'bind']); bm.addColumnValue('cc', true, 'newCmd', '$all');     Add a column with the ‘aa’ name as the initial value of ‘100’ and set it to ‘valid’ in cmd[‘newCmd’].   Add a column with the initial value of ‘B’ under the name ‘bbb’ and set it to ‘valid’, ‘bind’ in cmd[‘newCmd’].   Add a column with the initial value of ‘true’ under the name ‘cc’ and set it throughout cmd[‘newCmd’].   Execute   The execute() method of the Bindcommand object handles three main steps: validation, data request, and data reception. Each step can be controlled through the callback function, which lets you manage the flow of requests in detail.   bm.command['newCmd'].execute();     There are three main steps when calling the execute() method.            Validation : Perform a validation of the ‘valid’ column, and call a ‘cbFail’ callback if it fails.       Data Binding: Request ‘bind’ to server path same as column.       Data Receipt : Gets received data as ‘output’.          ","url": "http://localhost:4000/en/docs/basic/"
  },{
    "title": "BindCommand 클래스",
    "excerpt":"주요 구조   속성 관계   BindCommand 객체는 valid, bind, output 속성의 MetaView을 포함하고 있습니다. output 속성은 _outputs(MetaViewCollection)의 객체의 속성 output1 을 참조합니다. newOutput(name?) 메소드를 통해서 view 추가할 수 있습니다. _outputs 에  “output + 순번” 이름으로 컬렉션이 추가됩니다.   Class diagram    상속 관계   BindCommandAjax 을 상속하여 확장하거나 BindCommand 을 상속하여 재정의하여 사용자화 할 수 있습니다.   Class diagram    구성 요소   속성                  항목       설명                       config       axios config 와 동일                 url       url 경로                 _outputs       _outputs MetaView 컬켁션 속성입니다.                 _model       _model BindModel 객체 입니다.                 valid       검사대상 MetaView 입니다.                 bind       바인드 MetaView 입니다.                 output       기본 출력 MetaView 입니다. _ouputs[0] 객체를 참조합니다.                 outputOption       출력 옵션입니다. (기본값 = 0) - 0 : view 안함 - 1 : 모든 column 및 rows 가져오기 - 2 : 존재하는 column 의 rows 가져오기  - 3 : 존재하는 column 의 rows 가져오기,  n번째 자로 value 에 설정                 cbBegin       execute() 시작 콜백 입니다. callback(bindComamnd)                 cbValid       execute() valid 검사 전 콜백 입니다. callback(validView, bindComamnd)                 cbBind       execute() bind  전 콜백 입니다. callback(validView, bindComamnd, config)                 cbResult       execute() 회신  콜백 입니다. callback(data, bindComamnd, response)                 cbOutput       execute() \boutput View 매칭 후  콜백 입니다. callback(views, bindComamnd, response)                 cbEnd       execute() 종료 콜백 입니다. callback(status, bindComamnd, response)                 _guid       객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다.                 _type       객체의 생성자 함수. 객체가 생성될 때 사용된 함수입니다.            메소드                  항목       설명                       execute(): Promise       순서 :  _execBegin() » _execValid() » _execBind() » _execResult() » _execOutput() » _execEnd()                 addColumn(column, views, bTable?)       컬럼을 추가하고 지정 테이블에 추가하고, 컬럼의 참조를 BindCommand 의 valid, bind, output MetaView 에 등록합니다.                 addColumnValue(name, value, views, bTable?)       지정한 이름으로 컬럼과 값을 추가하고, 컬럼의 참조를 BindCommand 의 valid, bind, output MetaView 에 등록합니다.                 setColumn(names, views, bTable?)       메타테이블의 컬럼을 지정한 MetaView 에 설정합니다.                 release(names)       지정한 컬럼을 대상 MeteView 에서 제거합니다.                 newOutput(name?)       _output MetaViewCollection 에 MetaView 을 추가합니다. * - 기본 이름 = ‘output’ + _outout.count                 removeOutput(name)       _output MetaViewCollection 에 MetaView 을 제거합니다.                 getObject(): object       현재 객체의 guid 타입의 객체를 가져옵니다.                 setObject(obj, origin)       현재 객체를 초기화 후, 지정한 guid 타입의 객체를 사용하여 설정합니다.                 equal(target)       현재 객체와 지정된 객체가 동일한지 비교합니다.                 getTypes()       현재 객체의 생성자와 프로토타입 체인의 모든 생성자를 배열로 반환합니다.                 instanceOf(target)       현재 객체가 지정된 타입의 인스턴스인지 확인합니다. (_UNION 포함)             이벤트                  항목       설명                       onExecute       execte() 실행 전 공통 이벤트 입니다.                 onExecuted       execte() 실행 후 공통 이벤트 입니다.           세부 설명   주요 속성   config      AJAX 요청에 대한 설정값입니다. axios 의 config와 동일한 형식입니다.    type config = object;   url      AJAX 요청의 URL을 설정합니다.    type url = string;   _outputs      출력 결과를 저장하는 컬렉션입니다.    type _outputs = MetaViewCollection;   _model      바인드 모델 객체입니다.    type _model = BindModel;   valid      검사 대상 MetaView 객체입니다.    type valid = MetaView;   bind      바인드 대상 MetaView 객체입니다.    type bind = MetaView;   bind(MetaView) 는 서버에 전송하는 컬럼 목록입니다. bind.columns 컬렉션의 컬럼명과 컬럼값은 서버로 전송(요청)합니다.  예제 : 내부 작동 구조  var bm = new BindModelAjax(); bm.url = '/user' bm.addCommand('test'); bm.cmd['test'].addColumnValue('user_name', '홍길동'); bm.cmd['test'].addColumnValue('passwd', '1234'); bm.cmd['test'].execute();  ///// 내부적오로 전송 var axiosConfig = { \turl: '/user', \tdata: { \t\tuser_name: '홍길동', \t\tpasswd: '1234' \t} }   output      동적으로 추가된 출력 MetaView 객체입니다.    type output = MetaView;   outputOption      출력 특성 옵션입니다.         0: 제외     1: 모든 컬럼의 로우 가져옴     2: 존재하는 컬럼의 로우만 가져옴     3: 존재하는 커럼의 로우만 가져오고, value 설정      type outputOption = object;   \boutOpt      outputOption 의 별칭입니다.    type outOpt = object;   cbBegin      실행 시작 시 호출되는 콜백 함수입니다.    type cbBegin = (cmd: BindCommand) =&gt; void;     cmd - 현재 바인드 명령 객체입니다.   cbValid      검사(valid) 전 호출되는 콜백 함수입니다.    type cbValid = (valid: MetaView, command: BindCommand) =&gt; boolean;     valid : 검사할 MetaView 객체입니다.   command : 현재 바인드 명령 객체입니다.   return : 검사 결과를 나타내는 boolean 값입니다.   cbBind      바인드(bind) 전 호출되는 콜백 함수입니다.    type cbBaseBind = ( \tbind: MetaView,  \tcommand: BindCommand,  \tconfig: object ) =&gt; void;     bind : 바인드할 MetaView 객체입니다.   command : 현재 바인드 명령 객체입니다.   config : 설정 객체입니다.   cbResult      바인드 결과를 처리하는 콜백 함수입니다. 주로 결과 데이터 가공에 사용됩니다.    type cbResult = ( \tdata: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     data : 바인드 결과 데이터 객체입니다.   cmd : 현재 바인드 명령 객체입니다.   response : 응답 객체입니다.   return : 처리된 결과 데이터입니다.     cbOutput          바인드 결과를 출력하는 콜백 함수입니다. 주로 목록의 출력에 사용됩니다.    type cbOutput = ( \toutputs: MetaViewCollection,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     outputs : 메타 뷰 컬렉션입니다.   command : 현재 바인드 명령 객체입니다.   response : 응답 객체입니다.   return : 처리된 결과 객체를 반환합니다.     cbEnd          처리 종료 후 호출되는 콜백 함수입니다.    type cbBaseEnd = ( \tstatus: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; void;     status : 상태 정보를 담은 객체입니다.   command : 현재 바인드 명령 객체입니다.   response : 응답 객체입니다.   _guid      객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다.    type _guid = string;   _type      객체의 생성자 함수입니다. 객체가 생성될 때 사용된 함수입니다.    type _type = Function;    주요 메소드   execute()      바인드 명령을 실행합니다. 유효성 검사, 바인딩, 결과 처리, 성공 및 오류 콜백을 포함한 전체 실행 프로세스를 수행합니다.    type execute = () =&gt; Promise&lt;void&gt;;     return : 실행 결과를 나타내는 Promise 객체입니다.   예제  var bm = new BindModelAjax();  bm.addCommand('test1'); bm.addCommand('test2'); ...  bm.cmd['test1'].execute(); bm.cmd['test2'].execute();   addColumn()      컬럼을 추가하고 지정한 뷰와 매핑합니다.    type addColumn = ( \tcolumn: string | MetaColumn,  \tviews: string | string[],  \tbTable: string | MetaTable ) =&gt; void;     column : 등록할 컬럼 객체입니다. 문자열 또는 MetaColumn 객체일 수 있습니다.   views : 추가할 뷰 엔티티 이름입니다. 문자열 또는 문자열 배열일 수 있습니다.   bTable : (선택적) 매핑할 기본 테이블 객체 또는 테이블 이름입니다.     addColumnValue()          컬럼과 값을 추가하고 지정한 뷰와 매핑합니다.    type addColumnValue = ( \tname: string,  \tvalue: any,  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; void;     name : 컬럼 이름입니다.   value : 컬럼 값입니다.   views : (선택적) 추가할 뷰 엔티티 이름입니다.   bTable : (선택적) 매핑할 기본 테이블 객체 또는 테이블 이름입니다.   setColumn()      컬럼을 설정합니다.    type setColumn = (name: string | string[], views: string | string[]) =&gt; void;     name : 컬럼 이름 또는 이름 배열입니다.   views : 설정할 뷰 이름 또는 이름 배열입니다.   release()      대상 엔티티에서 컬럼을 해제합니다.    type release = (name: string | string[], views: string | string[]) =&gt; void;     name : 해제할 컬럼 이름 또는 이름 배열입니다.   views : 해제할 뷰 엔티티 이름 또는 이름 배열입니다.   newOutput()      출력에 사용할 뷰 엔티티를 추가합니다. 기본 이름은 ‘output’ + _outputs.count입니다.    type newOutput = (name?: string) =&gt; void;     name : (선택적) 추가로 참조할 뷰 이름입니다.   removeOutput()      출력 뷰를 삭제합니다.    type removeOutput = (name: string) =&gt; boolean;     name - 삭제할 뷰 이름입니다.   getObject()      현재 객체를 직렬화(guid 타입) 객체로 얻습니다. (순환참조는 $ref 값으로 대체됩니다.)    type getObject = (vOpt?: number, owned?: object | Array&lt;object&gt;) =&gt; object;     vOpt :  가져오기 옵션입니다. 기본값은 0 입니다.            opt=0 : 참조 구조(_guid:Yes, $ref:Yes)       opt=1 : 중복 구조(_guid:Yes, $ref:Yes)       opt=2 : 비참조 구조(_guid:No, $ref:No)           owned : 현재 객체를 소유하는 상위 객체들입니다. 기본값은 빈객체 입니다.   return : 직렬화된 객체를 반환합니다.   예제  a.getObject(2) == b.getObject(2)   setObject()      직렬화(guid 타입) 객체를 현재 객체에 설정합니다. (객체는 초기화 됩니다.)    type setObject = (oGuid: object, origin?: object) =&gt; void;     oGuid : 직렬화할 guid 타입의 객체입니다.   origin : 현재 객체를 설정하는 원본 객체입니다. 기본값은 oGuid 입니다.   equal()      현재 객체와 지정된 객체가 동일한지 비교합니다.    type equal = (target: object) =&gt; boolean;     return : 두 객체가 동일한지 여부를 반환합니다.   getTypes()      현재 객체의 생성자와 프로토타입 체인의 모든 생성자를 배열로 반환합니다.    type getTypes = () =&gt; Array&lt;Function&gt;;     return : 생성자 함수의 배열을 반환합니다.   예제  const types = obj.getTypes(); console.log(types); // [Function: MetaObject]   instanceOf()      현재 객체가 지정된 타입의 인스턴스인지 확인합니다. (_UNION 포함)    type instanceOf = (target: object | string) =&gt; boolean;     target : 확인할 대상 타입 (객체 또는 문자열)입니다.   return : 지정된 타입의 인스턴스인지 여부를 반환합니다.    주요 이벤트   onExecute      명령 실행 전 호출되는 이벤트입니다.    type onExecute = (cmd: BindCommand) =&gt; void;     cmd : 실행할 명령 객체입니다.   onExecuted      명령 실행 후 호출되는 이벤트입니다.    type onExecuted = (cmd: BindCommand, result: object) =&gt; void;     cmd : 실행한 명령 객체입니다.   result : 명령 실행 결과 객체입니다.   ","url": "http://localhost:4000/ko/docs/api-bind-command-ajax/"
  },{
    "title": "BindCommand Class",
    "excerpt":"the main structure   Property Relationships   The Bindcommand object contains MetaView with valid, bind, and output properties. The ‘output’ property refers to the property ‘output1’ of the object in ‘_outputs’ (MetaViewCollection). You can add a view through the newOutput(name?) method, “output + sequential” to “_outputs” The collection is added as a name.   Class diagram      an inheritance relationship   You can either inherit and extend Bindcommand or override Bindcommand to customize it.      Components   Properties                  Item       Description                       config       same as axios config                 url       url path                 _outputs       ‘_outputs’ MetaView collection property                 _model       ‘_model’ BindModel object                 valid       MetaView for inspection                 bind       bind MetaView                 output       default output MetaView.See  _outputs[0] object                 Output Option       Output option. (Default = 0) - 0: No view -1: Import all columns and rows - 2: Import the rows of existing columns - 3: Import the rows of existing columns, set to value in the nth letter                 cbBegin       execute() start callback. ‘callback(bindComand)’                 cbValid       execute() valid 검사 전 콜백 입니다. callback(validView, bindComamnd)                 cbBind       execute() bind  전 콜백 입니다. callback(validView, bindComamnd, config)                 cbResult       execute() 회신  콜백 입니다. callback(data, bindComamnd, response)                 cbOutput       execute() output View 매칭 후  콜백 입니다. callback(views, bindComamnd, response)                 cbEnd       execute() 종료 콜백 입니다. callback(status, bindComamnd, response)                 _guid       Unique identifier of the object (GUID). Uniquely identifies the object.           Method                  Item       Description                       execute(): Promise       순서 :  _execBegin() » _execValid() » _execBind() » _execResult() » _execOutput() » _execEnd()                 addColumn(column, views, bTable?)       Add a column, add it to the specified table, and register the reference of the column to the valid, bind, output MetaView in Bindcommand.                 addColumnValue (name, value, views, bTable?)       Add a column and value with the specified name, and register the reference of the column with the value, bind, output MetaView in Bindcommand.                 setColumn (names, views, bTable?)       Sets the column of the meta table to the specified MetaView                 release(names)       Remove the specified column from the destination MetView                 add MetaView to the newOutput(name?)       ‘_output’ MetaViewCollection. * - default name = ‘output’ + _out.count                 removeOutput(name)       _output MetaViewCollection 에 MetaView 을 제거합니다.                 getObject(): object       Get object of the guid type of the current object                 setObject(obj, origin)       Initialize the current object, and set it using the object of the specified guid type                 equal(target)       Compare the current object with the specified object.                 getTypes()       Returns the constructors of the current object and all the constructors of the prototype chain to the array.                 instanceOf(target)       Verify that the current object is an instance of the specified type (with _UNION)           Events                  Item       Description                               onExecute       common event before execution                         OnExecuted       common event after execution       inspect()           Detailed description   Key Properties   config      This is the setting for the AJAX request. Same format as ‘config’ in axios.    type config = object;   url      Set the URL for the AJAX request.    type url = string;   _outputs      Collection that stores output results.    type _outputs = MetaViewCollection;   _model      Bind model object.    type _model = BindModel;   valid      MetaView object to be inspected.    type valid = MetaView;   bind      Bind target MetaView object.    type bind = MetaView;   bind (MetaView) is a list of columns that are sent to the server. The column name and column value in the bind.column collection are sent (requested) to the server.   Internal operating structure  var bm = new BindModel(); bm.url = '/user' bm.addCommand('test'); bm.cmd['test'].addColumnValue('user_name', 'Neo'); bm.cmd['test'].addColumnValue('passwd', '1234'); bm.cmd['test'].execute();  ///// Send to internal var axiosConfig = { \turl: '/user', \tdata: { \t\tuser_name: 'Neo', \t\tpasswd: '1234' \t} }   output     Dynamic added output MetaView object.    type output = MetaView;   outputOption     Output attribute options.         0: Except     1: Import rows of all columns     2: Import only rows of existing columns     3: Import only rows of existing curums, set value      type outputOption = object;   outOpt   Alias for &gt; outputOptions.   type outOpt = object;   cbBegin      This is the callback function that is called at the start of execution.    type cbBegin = (cmd: BindCommand) =&gt; void;     cmd - This is the current bind command object.   cbValid      Callback function called before valid.    type cbValid = (valid: MetaView, command: BindCommand) =&gt; boolean;     valid : object ‘MetaView’ to be inspected.   command : The current bind command object.   return : A boolean value representing the result of the examination.   cbBind      This is the callback function that is called before bind.    type cbBaseBind = ( \tbind: MetaView,  \tcommand: BindCommand,  \tconfig: object ) =&gt; void;     bind : object ‘MetaView’ to bind.   command : The current bind command object.   config : This is the setting object.   cbResult      This is a callback function that handles binding results. Mainly used for processing result data.    type cbResult = ( \tdata: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     data : Bind result data object.   cmd : This is the current bind command object.   response —Response object.   return : Processed result data.     cbOutput          This is a callback function that outputs binding results. Mainly used for the output of lists.    type cbOutput = ( \toutputs: MetaViewCollection,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     outputs : Metabiew collection.   command : The current bind command object.   response —Response object.   return —Returns the processed result object.     cbEnd          This is a callback function that is called after processing is finished.    type cbBaseEnd = ( \tstatus: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; void;     status : The object containing status information.   command : The current bind command object.   response —Response object.   _guid      Unique identifier of the object (GUID). Uniquely identifies the object.    type _guid = string;   _type      The generator function of the object, which was used when the object was created.    type _type = Function;   Key Methods   execute()      Run the bind command. Performs the entire execution process, including validation, binding, result processing, success, and error callback.    type execute = () =&gt; Promise&lt;void&gt;;     return : This is the ‘Promise’ object representing the execution result.   var bm = new BindModel();  bm.addCommand('test1'); bm.addCommand('test2'); ...  bm.cmd['test1'].execute(); bm.cmd['test2'].execute();   addColumn()      Add a column and map it to the specified view.    type addColumn = ( \tcolumn: string | MetaColumn,  \tviews: string | string[],  \tbTable: string | MetaTable ) =&gt; void;     column : column object to be registered; it could be a string or ‘MetaColumn’ object.   views : The name of the view entity to be added; it can be a string or array of strings.   bTable : (Optional) Default table object or table name to be mapped.     addColumnValue()          Add columns and values and map them to the specified view.    type addColumnValue = ( \tname: string,  \tvalue: any,  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; void;     name : The name of the column.   value : The value of the column.   views —(Optional) Name of the view entity to be added.   bTable : (Optional) Default table object or table name to be mapped.   setColumn()      Set the column.    type setColumn = (name: string | string[], views: string | string[]) =&gt; void;     name —Column name or array of names.   views —The name or array of views to set.   release()      Release the column from the target entity.    type release = (name: string | string[], views: string | string[]) =&gt; void;     name —Column name or array of names to release.   views —The name or array of view entities to be disabled.   newOutput()      Add a view entity to use for the output. The default name is ‘output’ + _outputs.count.    type newOutput = (name?: string) =&gt; void;     name —(Optional) The name of the view to be referenced additionally.   removeOutput()      Delete the output view.    type removeOutput = (name: string) =&gt; boolean;     name — The name of the view to be deleted.   getObject()      Obtain the current object as a guide type object. (Circular references are replaced by $ref values.)    type getObject = (vOpt?: number, owned?: object | Array&lt;object&gt;) =&gt; object;     vOpt : Import option; default is 0.            opt=0: Reference structure (_guid:Yes, $ref:Yes)       opt=1: Redundant structure (_guid:Yes, $ref:Yes)       opt=2 : Non-tidal structure (_guid: No, $ref: No)           aged : The parent objects that currently own the object. The default is an empty object.   return —Returns serialized objects.   a.getObject(2) == b.getObject(2)   setObject()      Set the Guid type object to the current object. (The object will be reset.)    type setObject = (oGuid: object, origin?: object) =&gt; void;     oGuid : Object of the guid type to serialize.   origin : This is the original object that sets the current object. The default is oGuid.   equal()      Compare the current object with the specified object.    type equal = (target: object) =&gt; boolean;     return —Returns whether the two objects are identical.   getTypes()      Returns the creators of the current object and all the creators of the prototype chain to the array.    type getTypes = () =&gt; Array&lt;Function&gt;;     return : Returns the array of generator functions.   const types = obj.getTypes(); console.log(types); // [Function: MetaObject]   instanceOf()      Verify that the current object is an instance of the specified type (including _UNION)    type instanceOf = (target: object | string) =&gt; boolean;     target : The type of object to be checked (object or string).   return —Returns whether this is an instance of the specified type.   Key Events   onExecute      Events that are called before the command is executed.    type onExecute = (cmd: BindCommand) =&gt; void;     cmd : Command object to be executed.   onExecuted      An event that is called after the command is executed.    type onExecuted = (cmd: BindCommand, result: object) =&gt; void;     cmd : Command object executed.   result : The result object of the command execution.   ","url": "http://localhost:4000/en/docs/api-bind-command-ajax/"
  },{
    "title": "BindCommand 구성",
    "excerpt":"BindCommand 는 연관된 MetaView 의 묶음으로 execute() 메소드로 작동합니다.   주요 기능      흐름제어 : 단계별 콜백함수로 흐름 제어 할 수 있습니다.   컬럼 추가 : HTMLColumn 객체의 추가합니다.(컬럼 참조값)   응답 관리 : 서버 응답을 MetaView 로 바인딩 합니다.   유효성 검사 : 컬럼 제약조건 설정으로 유효성 검사를 합니다.     주요 속성       ‘outputOption’ : 옵션에 따라 output(MetaView) 불러오는 방식입니다.   ‘url’ : axios.url 경로 입니다.   ‘config’ : axios config 객체 입니다.   ‘valid’ : 유효성 검사하는 MetaView 입니다.   ‘bind’ : 서버에 요청하는 MetaView 입니다.   ‘output’ : 서버의 응답받는 MetaView 입니다.   ‘_outputs’ : 출력과 관련된 MetaView 를 제어하는 컬렉션입니다.   ‘_model’ : BindModel 객체를 가르킵니다 (소유자)   콜백(속성)      ‘cbBegin’ : 시작 전 콜백함수 입니다.   ‘cbValid’ : 유효성 검사 콜백함수 입니다.   ‘cbBind’ : 서버 요청 콜백함수 입니다.   ‘cbResult’ : 서버 응답 콜백함수 입니다.   ‘cbOutput’ : 출력 콜백함수 입니다.   ‘cbEnd’ : 종료 전 콜백함수 입니다.   이벤트      onExecute :   execute() 실행시 처음으로 호출합니다.   onExecuted : execute() 실행시 마지막으로 호출합니다.        주요 메소드       execute() : BindCommand 객체를 실행합니다.   addColumn() : HTMLColumn 객체를 추가합니다.   addColumnValue() : HTMLColumn 객체를 추가하고, ‘value’ 값을 설정합니다.   setColumn() : 지정한 컬럼을 MetaView 에 참조로 등록합니다.   release() : 지정한 MetaView 에 참조를 해제합니다.   newOutput() : 응답 출력 MetaView 을 추가합니다. (_outputs)   removeOptput() : 출력 MetaView 를 제거합니다. (_outputs)   명령별 서버 요청 설정하기   명령별 요청 경로   ‘url’ 은 서버에 요청하는 url 경로 입니다. 값이 없으면 ‘baseUrl’ 으로 대체됩니다.   var bm = new BindModel();  bm.addCommand('cmdA'); bm.addCommand('cmdB');  bb.command['cmdA'].url = '/user/1'; bb.command['cmdB'].url = '/list';     command ‘cmdA’, ‘cmdB’는 다른 경로를 가집니다.   동적 url 설정하기   때로는 특정 작업(command)에 따라 요청 경로(url)를 동적으로 변경해야 할 때가 있습니다. BindModelAjax 객체의 콜백 함수를 통해서 쉽게 설정할 수 있습니다.    var idx = 1;  bb.command['cmdA'].cbBegin = function(cmd) { \t cmd.url = `/user/${idx}`;  };  요청 환경 설정(axios)   http 통신을 위한 axios 의 config 를 설정합니다. #TODO   명령별 이벤트 설정하기   명령별 이벤트 설정은 execute() 메서드를 실행할 때 특정 이벤트를 호출하여 다양한 작업을 수행할 수 있도록 하는 기능입니다.   타입 : onExecute, onExecuted  // Event Type type onExecute = (model: BindModel, cmd: BindCommand) =&gt; void;  type onExecuted = (model: BindModel, cmd: BindCommand) =&gt; void;      onExecute : 해당 execute() 메서드가 처음 실행될 때 호출됩니다.   onExecuted :  해당 execute() 메서드가 실행된 후 마지막으로 호출됩니다.   이 이벤트 타입들은 BindModel과 BindCommand 객체를 인자로 받아 다양한 작업을 수행할 수 있게 합니다.   var bm = new BindModel();  bm.addCommand('read'); // Global Event Settings bm.onExecute = function() {      console.log('model 에서 onExecute 호출'); }; bm.onExecuted = function() {      console.log('model 에서 onExecuted 호출'); }; // Command Event Settings bm.command['read'].onExecute = function() {      console.log('command 에서 onExecute 호출'); }; bm.command['read'].onExecuted = function() {      console.log('command 에서 onExecuted 호출'); }; // Execute bm.command['read'].execute();  // Output results: // Call onExecute from model // Call onExecute from command // Call onExecuted from command // Call onExecuted in model   전역 이벤트와 명령별 이벤트를 설정하면 execute() 메서드가 실행될 때 다양한 작업을 순차적으로 처리할 수 있습니다. 이는 특정 작업이 실행될 때 필요한 초기화 작업이나 후속 작업을 정의하는 데 유용합니다.   명령별 흐름 제어하기   execute() 메서드를 실행할 때 순차적으로 콜백 함수가 호출되어 흐름을 제어할 수 있습니다.                  [[41. Callback Lifecycle-B       Refer to: Callback Lifecycle]           콜백 함수의 호출 순서     cbBegin : URL 및 config 정보 설정   cbValid : 유효성 검사   cbBind : 서버 요청 전에 호출   서버 요청 수행   cbResult : 서버 응답 후 호출   cbOutput : _outputs 컬렉션으로 응답 처리   cbEnd : 모든 과정이 완료된 후 호출   1. 시작시 콜백   execute() 호출시 처음으로 호출되는 콜백입니다.   타입: cbBegin  type cbBegin = (cmd: BindCommand) =&gt; void;   일반적인 활용방안은     url 및 config 의 정보 설정에 활용됩니다.   var bm = new BindModel(); // Add Commands bm.addCommand('list'); // Callback Settings bm.command['list'].cbBegin = (command) =&gt; {      command.url = '/member/1';  };   2. 유효성 검사 콜백   execute() 실행 시 valid(MetaView)에 대한 유효성 검사 전에 호출되는 콜백입니다.  리턴값이 false 이면 cbFail 콜백이 호출되고 실행이 종료됩니다.   타입: cbValid  type cbValid = (valid: MetaView, cmd: BindCommand) =&gt; boolean;   일반적인 활용방안은     서버 요청전 검사에 활용됩니다.   사용자에게 처리결과를 확인하는 용도로 활용됩니다.   var bm = new BindModel(); // Add Commands bm.addCommand('list'); // Callback Settings bm.command['list'].cbValid = function(view) {  \treturn view.colums.count &lt;= 0  }; bm.command['list'].cbValid = function() { \treturn confirm ('Do you want to delete?') };   3. 서버 요청 콜백   execute() 실행 시 bind(MetaView) 컬럼 값을 전송하기 전에 호출되는 콜백입니다.   타입 : cbBind  type cbBind = (view: MetaView, cmd: BindCommand, config: object) =&gt; void;   일반적인 활용방안은     전송타입의 설정에 활용됩니다. (enctype)   통합 로그인 관련 설정에 활용됩니다.   비밀번호 암호화에 활용됩니다.   4. 서버 응답 콜백   execute() 실행 시 서버에서 응답을 받은 후에 호출되는 콜백입니다. 타입 : cbResult  type cbResult = (data: object, cmd: BindCommand, res: object) =&gt; object;   일반적인 활용방안은     응답받은 data 를 MetaView 형식의 스키마로 커스텀 하는 용도활용됩니다.   // data = { aa: 1, bb: 2 } bm.command['list'].cbResult = function(data) { \treturn = { \t\trows: data \t}; };     리턴값 : { rows: {aa: 1, bb: 2 }}    5. 출력 콜백   응답을 ‘_outputs’ 컬렉션으로 읽어들인 후에 호출되는 콜백입니다.   BindCommand 출력 옵션에 따라서 데이터를 ‘_outputs’ 컬렉션에 가져오는 방식이 달라집니다. [24. Bind Command Configuration - B# Type of Output Option (output) | Reference: Type of Output Option]   타입: cbOutput  type cbOutput = ( \tviews: MetaViewColleciton,  \tcmd: BindCommand,  \tres: object ) =&gt; void;   일반적인 활용방안은     응답받은 output(MetaView)을 사용하여 화면(html) 바인딩에 활용됩니다.   { \t\"rows\": [ \t\t{ \"u_name\": \"Neo\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Jane\", \"gender\", \"W\" }, \t] }   bm.command['list'].cbOutput = function(views) { \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(1, row['u_name'], row['gender']); \t} }; // Output results: // 0  Neo  M // 1  Jane  W     views[0] 은 BindCommand 의 ‘output’ 과 동일합니다.   6. 종료시 콜백   execute() 실행시 마지막으로 호출되는 콜백입니다.   타입 : cbEnd  type cbEnd = (status: number, cmd: BindCommand, res: object) =&gt; void;    일반적인 활용방안은     성공 메세지 전달에 활용합니다.   경로 리다이렉트에 활용합니다.   다른 명령의 execute() 체인 연결에 활용합니다.   bm.command['list'].cbEnd = function(views) { \talert('Normal processed') }   각 콜백 함수는 특정 상황에서 명령의 동작을 조정하거나, 데이터를 전처리 및 후처리하는 데 사용됩니다. 이를 통해 BindCommand의 실행 흐름을 세부적으로 제어할 수 있습니다.   출력 옵션 설정하기   BindCommandAjax 에 제공되는 output(MetaView)외에 추가 MetaView 를 지정할 수 있습니다.   타입: outputOption  type outputOption = { option: number, index: number }`;      객체타입 초기값은 outputOption = {option: 0, index: 0} 입니다.   ‘option’ 속성은 값에 따라 output(MetaView)에서 데이터를 불러오는 방식입니다.   ‘index’ 속성은 컬럼의 값을 설정할 때 rows 인덱스 위치를 지정합니다. (option: 3일 경우 사용)   ‘outOpt’ 는 ‘outputOption’ 의 별칭입니다.   생성자를 통한 설정   객체를 생성할 때 outputOption 파라미터를 전달하여 설정할 수 있습니다.   var bm = new BindModel();  var bc1 = new BindCommand(bm, 1); var bc2 = new BindCommand(bm, { option: 1, index: 1 });     ‘bc1.outputOption’ 값은 {option:1, index: 0} 입니다.   ‘bc2.outputOption’ 값은 {option:1, index: 1} 입니다.   addCommand() 에서 설정   BindModelAjax 객체의 addCommand() 메소드를 통해 생성 시 파라미터로 ‘outputOption’을 전달할 수 있습니다.   var bm = new BindModel();  bm.addCommand('read', 2); bm.addCommand('view', { option: 2, index: 1 });     bm.command['read'].outputOption 값은 {option:2, index: 0} 입니다.   bm.command['view'].outputOption 값은 {option:2, index: 1} 입니다.   프로퍼티로 설정   BindCommandAjax 객체의 ‘outputOption’ 속성을 변경하여 설정할 수 있습니다.   bm.command['read'].outputOption = 3; bm.command['view'].outputOption = { option: 3, index: 1 };     bm.command['read'].outputOption 값은 {option:3, index: 0} 입니다.   bm.command['view'].outputOption 값은 {option:3, index: 1} 입니다.   유효성 검사 대상 설정하기 (valid)   유효성 검사하기 위해서는 valid(MetaView)을 구성해야 합니다. 먼저 검사 대상은 valid.columns 컬렉션에 추가하고 ‘required’, ‘constraints’ 속성을 설정합니다.   타입 : constraints (HTMLColumn 속성)  type RegExpType = {reg: RegExp, msg: string, return: boolean = true}; type FuncType = (value: any)=&gt;boolean; type ContiditionType = RegExpType | FuncType; type ConstrainstType = ContiditionType[] | ContiditionType;  const constraints: ConstrainstType[] | ConstrainstType;     required : 필수 여부를 나타내며, true일 경우 ‘value’ 값이 공백, null이면 실패합니다.   constraints : value 값이 공백이나 null이 아니면 제약 조건을 검사합니다.   • reg : 매칭되어야 할 정규식입니다.   • msg : 매칭 여부에 따라 return이 false이면 실패 메시지입니다.       • return이 true이면 매칭 실패 시 오류 메시지입니다.       • return이 false이면 매칭 성공 시 오류 메시지입니다.   • return : reg 매칭 시 리턴 결과입니다. 기본값은 true입니다.   사용빈도별 제약조건                  빈도       required       constraints       설명                       50%                       선택값입니다.                 30%       true               필수값입니다.                 15%               {…}       선택값이며, value 값이 제약조건이 있습니다.                 5%       true       {…}       필수값이며, value 값에 제약조건이 있습니다.           (쇼핑몰 table: 20ea 기준)   var bm = new BindModel();  bm.addCommand('test');  bm.cmd['test'].addColumn('user_name'); bm.cmd['test'].addColumn('passwd'); bm.cmd['test'].addColumn('user_id'); bm.cmd['test'].addColumn('email');  bm.columns['user_name'].required = true; bm.columns['passwd'].required = true; bm.columns['user_id'].required = true;  bm.columns['passwd'].constraints = { \tregex: /.{6}/, msg: \"Please enter at least 6 characters.\" }; bm.columns['user_id'].constraints = [ \t(val)=&gt;{ reutrn val.length &gt; 8 },  \t{regex: /\\D{8}/, msg: \"Please type in English\", return: false} ]; bm.columns['email'].constraints = { \tregex: /.{6}/, msg: \"Please enter at least 6 characters.\" };  bm.cmd['test'].execute();     user_name : 필수 조건입니다. 공백 입력 시 실패합니다. ‘cbFail’ 이 호출됩니다.   passwd : 필수 조건이며, 정규식 조건에 매칭되어야 성공합니다.   user_id : 필수 조건이며, 첫 번째 함수 조건에서 성공하고, 두 번째 정규식 조건에서는 비매칭되어야 성공합니다.   email : 선택 조건입니다. 공백일 경우 성공하며, 값을 입력 시 정규식과 매칭되어야 성공합니다.   컬럼 추가하기   컬럼을 추가하면 기본 테이블인 ‘_baseTable’에 컬럼이 추가되고, 바인드 명령에 지정한 MetaView 에 참조가 등록됩니다. 컬럼을 추가하는 메소드로는 addColumn() 과 addColumnValue() 가 있습니다.   타입 : addColumn(), addColumnValue()  type addColumn = ( \tcolName: string,  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;  type addColumnValue = ( \tcolName: string,  \tvalue: any,  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;     views 파라메터에 ‘$all’ 지시자를 사용하면, 모든 MetaView(valid, bind, output)에 추가됩니다.   bTable 파라미터는 컬럼을 추가할 테이블을 지정하며, 기본값은 ‘_baseTable’입니다.   컬럼 추가 및 매핑   기본 테이블에 컬럼을 추가하고, 지정한 MetaView에 참조를 등록합니다. addColumn() 메소드는 빈 컬럼을 추가하고, addColumnValue() 메소드는 컬럼 추가 후 ‘value’ 값을 설정합니다.   var bm = new BindModel();  bm.addCommand('test');  bm.command['test'].addColumn('aa', 'valid'); bm.command['test'].addColumn('bb', ['bind', 'output']); bm.command['test'].addColumn('cc', '$all'); bm.command['test'].addColumn('dd');  // bm['first'].columns.count  == 4 ('aa', 'bb', 'cc', 'dd')  // bm.command['test'].valid.columns.count  == 3 ('aa', 'cc', 'dd') // bm.command['test'].bind.columns.count   == 3 ('bb', 'cc', 'dd') // bm.command['test'].output.columns.count == 3 ('bb', 'cc', 'dd')     addColumn() 메소드를 호출하면 빈 컬럼이 추가됩니다.   addColumnValue() 메소드를 호출하면 컬럼 추가 후 ‘value’ 값이 설정합니다.   ‘aa’ 컬럼은  지정한 MetaView(valid) 에 참조를 등록합니다.   ‘bb’ 컬럼은  지정한 MetaView(bind, output) 에 참조를 등록합니다.   ‘cc’ 컬럼은  전체 MetaView(valid, bind, output) 에 참조를 등록합니다.   ‘dd’ 컬럼 추가시 파라메터를 생략하면 전체 MetaView 에 참조를 등록합니다.   확장 테이블에 컬럼 추가 및 매핑   지정한 MetaTable 에 컬럼을 추가하고 지정한 MetaView 에 참조를 등록합니다.   var bm = new BindModel();  bm.addTable('second'); bm.addCommand('test');  bm.command['test'].addColumn('aa', 'valid', bm.second); bm.command['test'].addColumn('bb', '$all', 'second');  // bm['first'].columns.count  == 0 // bm['second'].columns.count == 2 ('aa', 'bb')  // bm.command['test'].valid.columns.count  == 1 ('aa', 'bb') // bm.command['test'].bind.columns.count   == 1 ('bb') // bm.command['test'].output.columns.count == 1 ('bb')     ‘aa’ 컬럼은 MetaTable(second) 에 추가하고  지정한 MetaView(valid) 에 참조를 등록합니다.   ‘bb’ 컬럼은 MetaTable(second) 에 추가하고  전체 MetaView 에참조를 등록합니다.   위의 메소드를 활용하여 다양한 방식으로 테이블과 컬럼을 추가하고, 각 컬럼을 적절한 MetaView에 매핑할 수 있습니다. 이는 데이터의 유효성 검사, 바인딩, 출력 등 다양한 요구사항을 효율적으로 처리하는 데 유용합니다.   기존 컬럼 설정하기   이미 등록된 컬럼을 MetaView에 참조로 등록하거나 해제할 수 있습니다. 이를 통해 데이터의 유효성 검사, 바인딩, 출력 등 다양한 요구사항에 맞춰 컬럼을 동적으로 관리할 수 있습니다.   주요 기능 요약     컬럼 설정: 특정 테이블의 컬럼을 원하는 MetaView에 설정하여 데이터 유효성 검사, 바인딩, 출력 등의 처리를 할 수 있습니다.   컬럼 해제 : 설정된 컬럼을 원하는 MetaView에서 해제하여 동적으로 컬럼 참조를 관리할 수 있습니다.   타입 : setColumn(), release()  type TableNameType : string; type ColumnType : string; type FullColumnType : TableNameType + '.'+ ColumnType; type ColumnDotType : FullColumnType | ColumnType; type ViewType : 'valid' | 'bind' | 'output' | '$all' | string;  type setColumn = ( \tcolName: ColumnDotType,  \tviews: ViewType | ViewType[],  \tbTable?: string | MetaTable ) =&gt; void;  type release = ( \tcolName: string,  \tviews?: ViewType | ViewType[] ) =&gt; void;  컬럼 설정 및 해제   컬럼을 설정할 때는 테이블명 + . + 컬럼명 표기법을 사용하여 특정 테이블의 컬럼을 지정할 수 있습니다.   var bm = new BindModel(); bm.addTable('second');  // Add a column to the default table, first bm.addColumn('aa'); bm.addColumn('bb');  // Adding a column to the extension table, second bm['second'].columns.add('cc'); bm['second'].columns.add('dd');  bm.addCommand('test');  // Column Settings bm.command['test'].setColumn('aa', 'valid'); bm.command['test'].setColumn(['bb', 'second.cc'], 'bind'); bm.command['test'].setColumn('second.dd', '$all');  // Number of columns in the base table // bm.first.columns.count == 2 ('aa', 'bb') // Number of columns in the extension table // bm.second.columns.count == 2 ('cc', 'dd') // Number of columns in MetaView // bm.command['test'].valid.columns.count == 2 ('aa', 'dd') // bm.command['test'].bind.columns.count == 2 ('bb', 'dd') // bm.command['test'].output.columns.count == 2 ('cc', 'dd')  // Release the column bm.command['test'].release('aa', 'valid'); bm.command['test'].release(['bb', 'cc'], 'bind'); bm.command['test'].release('dd', '$all');  // Number of columns in MetaView // bm.command['test'].valid.columns.count == 0 // bm.command['test'].bind.columns.count == 0 // bm.command['test'].output.columns.count == 0     ‘aa’ 컬럼을 추가하고 지정한 MetaView(valid) 에 참조를 등록합니다.   ‘bb’ 컬럼을 추가하고 지정한 MetaView(bind) 에 참조를 등록합니다.   ‘cc’ 컬럼을 MetaTable(second) 추가하고 지정한 MetaView(bind)에 참조를 등록합니다.   ‘dd’ 컬럼을 MetaTable(second) 추가하고 전체 MetaView에 참조를 등록합니다.   위의 메소드를 사용하면 기존 컬럼을 동적으로 MetaView에 설정하거나 해제할 수 있어, 복잡한 데이터 처리 요구사항에 유연하게 대응할 수 있습니다.   출력옵션의 종류 (output)   응답 데이터가 복수 레코드일 경우, ‘_outputs’ 컬렉션의 순서대로 데이터를 가져옵니다. 복수의 레코드를 가져오려면 레코드 개수만큼 ‘_outputs’ 컬렉션을 추가해야 합니다.  ‘_outputs ‘컬렉션의 개수보다 많은 레코드는 제외됩니다. (option &gt; 0)                  옵션       설명                       0 (default)       output bind 안함                 1       모든 column 의 row 를 가져옵니다.                 2       존재하는 column 의 row 를 가져옵니다.                 3       존재하는 column 의 row 를 가져오고, index 위치의 row 를 column value 에 설정합니다.           출력 무시하기 : option = 0   output(MetaView)에 데이터를 가져오지 않습니다. 주로 create, update, delete와 같은 데이터 수정 작업에 사용되며, 응답 데이터가 필요 없는 경우에 적합합니다.  이 옵션은 주로 데이터 변경 작업을 수행할 때 사용되며, 데이터 반환을 최소화하여 효율성을 높입니다.   var bm = new BindModel(); // Add 'create' command and set output option to 0 to not get data bm.addCommand('create', 0); // Set a value in column 'aa' bm.cmd['create'].addColumnValue('aa', -10); // Execute a command bm.cmd['create'].execute();  // bm.columns.count == 1 // bm.columns['aa'].value == -10 // bm.cmd['create'].output.rows.count == 0   모든 데이터 가져오기 : option = 1   옵션 값 1은 모든 응답 데이터를 output(MetaView)에 불러오는 방식입니다. 이 옵션은 서버로부터 수신한 전체 데이터의 컬럼을 단순하게 출력하거나, 데이터 구조를 확인할 때 유용합니다.   { \t\"rows\": [ \t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t] }   var bm = new BindModel();  // Add 'list' command and set output option to 1 to get all data bm.addCommand('list', 1);  bm.cmd['list'].execute();  // bm.columns.count == 3 // bm.cmd['list'].output.rows.count == 2 // bm.cmd['list'].output.rows[0]['aa'] == 10 // bm.cmd['list'].output.rows[0]['bb'] == 20 // bm.cmd['list'].output.rows[0]['cc'] == 30 // bm.cmd['list'].output.rows[1]['aa'] == 11 // bm.cmd['list'].output.rows[2]['bb'] == 21 // bm.cmd['list'].output.rows[3]['cc'] == 31     컬럼이 미리 정의되지 않더라도 응답 데이터에 기반하여 동적으로 생성됩니다.   이 옵션은 서버로부터 수신한 데이터의 전체 구조를 확인하거나, 디스플레이 및 후속 처리 작업을 위한 기본 데이터 로딩에 유용합니다.   지정한 컬럼의 데이터만 가져오기 : option = 2   응답 데이터에서 ouput(MetaView) 에 존재하는 컬럼만 불러옵니다.   { \t\"rows\": [ \t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t] }   var bm = new BindModel(); bm.addCommand('list', 2); bm.cmd['list'].addColumnValue('aa', 0); bm.cmd['list'].addColumnValue('bb', 0); bm.cmd['list'].execute();  // bm.columns.count == 2 // bm.cmd['list'].output.rows.count == 2 // bm.cmd['list'].output.rows[0]['aa'] == 10 // bm.cmd['list'].output.rows[0]['bb'] == 20 // bm.cmd['list'].output.rows[1]['aa'] == 11 // bm.cmd['list'].output.rows[2]['bb'] == 21   데이터를 컬럼값에 설정하기 (지정한 컬럼) : option = 3   응답 데이터에서 ouput(MetaView) 에 존재하는 컬럼만 불러오고, 지정한 데이터를 컬럼 ‘value’ 값으로 설정합니다.   { \t\"rows\": { \"aa\": 10, \"bb\", 20, \"cc\": 30 }, }   var bm = new BindModel(); bm.addCommand('read', 3); bm.cmd['read'].addColumnValue('aa', 0); bm.cmd['read'].addColumnValue('bb', 0); bm.cmd['read'].execute();  // bm.columns.count == 2 // bm.columns['aa'].value == 10 // bm.columns['bb'].value == 20   단일 인덱스 지정 (option : 3)   응답 데이터의 특정 ‘행’ 값을 ‘값’ 열로 설정합니다.   { \t\"rows\": [ \t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t] }   var bm = new BindModel(); bm.addCommand('test', 3); bc.outputOption.index = 1;   // index set bm.cmd['test'].addColumnValue('aa', 0); bm.cmd['test'].addColumnValue('bb', 0); bm.cmd['test'].execute();  // bm.columns.count == 2 // bm.columns['aa'].value == 11 // bm.columns['bb'].value == 21     2번째(index = 1) ‘rows’ 의 값이 ‘value’ 값으로 설정되었습니다.   복합 인덱스 지정 (option : 3)   복수의 응답 데이터의 특정 ‘rows’ 값을 컬럼 ‘value’ 값으로 설정합니다.   [ \t{ \t\t\"rows\": [ \t\t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t\t] \t}, \t{ \t\t\"rows\": [ \t\t\t{ \"dd\": 40, \"ee\", 50 }, \t\t\t{ \"dd\": 41, \"ee\", 51 }, \t\t\t{ \"dd\": 42, \"ee\", 52 }, \t\t] \t}, ]   var bm = new BindModel(); bm.addCommand('test', 3); bc.outputOption.index = [0, 1];   // index set bm.cmd['test'].newOutput('two'); bm.cmd['test'].addColumnValue('aa', 0); bm.cmd['test'].addColumnValue('bb', 0); bm.cmd['test'].addColumnValue('dd', 0); bm.cmd['test'].execute();  // bm.columns.count == 3 // bm.columns['aa'].value == 10 // bm.columns['bb'].value == 20 // bm.columns['dd'].value == 41 // bm.cmd['test'].output.rows.count == 2 // bm.cmd['test'].two.rows.count == 3     첫번째 응답 레코드의 index = 0 의 값이 컬럼 (‘aa’, ‘bb’) 값으로 설정되었습니다.   두번째 응답 레코드의 index = 1 의 값이 컬럼(‘dd’) 값으로 설정되었습니다.  ","url": "http://localhost:4000/ko/docs/bind-commnad-config/"
  },{
    "title": "Configure Command",
    "excerpt":"‘Bindcommand’ is a bundle of associated ‘MetaView’ and works as an execute() method.   Key Features      Flow control: Flow control can be performed with a step-by-step callback function.   Add column: Add ‘HTML Column’ object (column reference value)   Response Management : Binds the server response to ‘MetaView’.   Validation : Validates with column constraint settings.     Key Properties       ‘outputOption’ : This is a method of calling output (MetaView) depending on the option.   ‘url’ : The path ‘axios.url’.   ‘config’ : ‘axios’ config object.   ‘valid’ : This is a validation ‘MetaView’.   ‘bind’ : This is the ‘MetaView’ request from the server.   ‘output’ : This is the server’s response ‘MetaView’.   ‘_outputs’ : A collection that controls ‘MetaView’ associated with the output.   ‘_Model’ : Point to ‘BindModel’ object (owner)   Callback (Properties)      ‘cbBegin’ : This is the callback function before the start.   ‘cbValid’ : Validation callback function.   ‘cbBind’ : This is the server request callback function.   ‘cbResult’ : This is the server response callback function.   ‘cbOutput’ : Output callback function.   ‘cbEnd’ : This is the callback function before termination.   Events      ‘onExecute’ : Invoke for the first time when executing execute().   ‘onExecuted’ : Last call when executing execute().        Key Methods       execute(): Execute the ‘Bindcommand’ object.   addColumn(): Add ‘HTMLColumn’ object.   addColumnValue(): Add ‘HTMLColumn’ object and set ‘value’ value.   setColumn(): Register the specified column as a reference in ‘MetaView’.   release() : Unreferences to the specified MetaView.   newOutput(): Add the response output ‘MetaView’ (_outputs)   removeOptput(): Remove the output ‘MetaView’ (_outputs)   Setting up a per-command server request   Request path by command   ‘url’ is the url path you request from the server. If there is no value, it will be replaced by ‘baseUrl’.   var bm = new BindModel();  bm.addCommand('cmdA'); bm.addCommand('cmdB');  bb.command['cmdA'].url = '/user/1'; bb.command['cmdB'].url = '/list';     command ‘cmdA’ and ‘cmdB’ have different paths.   Set dynamic url   Sometimes it is necessary to dynamically change the request path (url) depending on a specific command. It can be easily set up through the callback function of the BindModel object.   var idx = 1;  bb.command['cmdA'].cbBegin = function(cmd) { \t cmd.url = `/user/${idx}`;  };  Request configuration (axios)   Set the config of the axios for http communication. #TODO   Setting up events by command   Command-by-command event setting is a feature that allows you to perform various tasks by calling specific events when you execute the execute() method.   타입 : onExecute, onExecuted  // Event Type type onExecute = (model: BindModel, cmd: BindCommand) =&gt; void;  type onExecuted = (model: BindModel, cmd: BindCommand) =&gt; void;      onExecute : Called the first time the execute() method is executed.   onExecuted —Last called after the execute() method is executed.   These event types take the BindModel and Bindcommand objects as factors, allowing you to perform a variety of tasks.   var bm = new BindModel();  bm.addCommand('read'); // Global Event Settings bm.onExecute = function() {      console.log('model 에서 onExecute 호출'); }; bm.onExecuted = function() {      console.log('model 에서 onExecuted 호출'); }; // Command Event Settings bm.command['read'].onExecute = function() {      console.log('command 에서 onExecute 호출'); }; bm.command['read'].onExecuted = function() {      console.log('command 에서 onExecuted 호출'); }; // Execute bm.command['read'].execute();  // Output results: // Call onExecute from model // Call onExecute from command // Call onExecuted from command // Call onExecuted in model   Setting global and command-specific events allows you to process a variety of tasks in sequence when the execute() method is executed, which is useful for defining the initialization or subsequent actions required when certain tasks are executed.   To control flow by command   When executing the execute() method, callback functions are called sequentially to control the flow.  [[41. Callback Lifecycle-B|Refer to: Callback Lifecycle]   Callback function’s call order     cbBegin : URL and config information settings   cbValid : Validation   cbBind : Call before server request   Performing a server request   cbResult : Call after server response   cbOutput : Response processed with _outputs collection   cbEnd : Call after completion of the entire process   1. Callback at start   The first callback to be called upon execution().   Type: cbBegin  type cbBegin = (cmd: BindCommand) =&gt; void;   The general application plan is     Utilized for setting up information in url and config.   var bm = new BindModel(); // Add Commands bm.addCommand('list'); // Callback Settings bm.command['list'].cbBegin = (command) =&gt; {      command.url = '/member/1';  };  2. Validation callback   Callback called before validation for ‘valid(MetaView)’ when executing execute().  If the return value is false, a cbFail callback is called and execution is terminated. Type: cbValid  type cbValid = (valid: MetaView, cmd: BindCommand) =&gt; boolean;   The general application plan is     Used for inspection before requesting a server.   It is used to check the processing results from the user.   var bm = new BindModel(); // Add Commands bm.addCommand('list'); // Callback Settings bm.command['list'].cbValid = function(view) {  \treturn view.colums.count &lt;= 0  }; bm.command['list'].cbValid = function() { \treturn confirm ('Do you want to delete?') };   3. Server Request Callback   Callback called before sending the ‘bind(MetaView)’ column value when executing execute().   Type: cbBind  type cbBind = (view: MetaView, cmd: BindCommand, config: object) =&gt; void;   The general application plan is     Used to set the transport type. (encttype)   Utilized for integrated login-related settings.   Used for password encryption.   4. Server Response Callback   Callback called after receiving a response from the server when executing execute(). Type: cbResult  type cbResult = (data: object, cmd: BindCommand, res: object) =&gt; object;   The general application plan is     It is used to customize the responded data into a schema in the form of ‘MetaView’.   // data = { aa: 1, bb: 2 } bm.command['list'].cbResult = function(data) { \treturn = { \t\trows: data \t}; };     Return value: ‘{aa: 1, bb:2}’     5. Output callback       Callback called after the response is read into the ‘_outputs’ collection.   Depending on the ‘Bindcommand’ output option, the way data is imported into the ‘_outputs’ collection is different. [24. Bind Command Configuration - B# Type of Output Option (output) | Reference: Type of Output Option]   Type: cbOutput  type cbOutput = ( \tviews: MetaViewColleciton,  \tcmd: BindCommand,  \tres: object ) =&gt; void;   The general application plan is     It is utilized for screen (html) binding using the ‘output(MetaView)’ responded.   { \t\"rows\": [ \t\t{ \"u_name\": \"Neo\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Jane\", \"gender\", \"W\" }, \t] }   bm.command['list'].cbOutput = function(views) { \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(1, row['u_name'], row['gender']); \t} }; // Output results: // 0  Neo  M // 1  Jane  W  ‘views[0]’ is the same as ‘output’ of ‘Bindcommand’.   6. Callback at the end of the day   The last callback to be called when execute().   Type: cbEnd  type cbEnd = (status: number, cmd: BindCommand, res: object) =&gt; void;    The general application plan is     Use it to deliver success messages.   Utilizes for path redirection.   Utilizes the execute() chain connection of other commands.   bm.command['list'].cbEnd = function(views) { \talert('Normal processed') }   Each callback function is used to coordinate the behavior of commands in certain situations, or to pre-process and post-process data. This provides detailed control over the execution flow of Bindcommand.   Setting Output Options   Additional ‘MetaView’ can be specified in addition to the ‘MetaView’ provided in ‘Bindcommand’.   타입 : outputOption  type outputOption = { option: number, index: number }`;      The initial value of the object type is ‘outputOption = {option: 0, index: 0}.   The ‘option’ attribute is a method of fetching data from ‘output(MetaView)’ depending on the value.   The ‘index’ property specifies the location of the rows index when setting the value of the column. (Option: Used if 3)   ‘outOpt’ is an alias for ‘outputOptions’.   Configuration via Creator   You can set the output option parameter by passing it when you create an object.   var bm = new BindModel();  var bc1 = new BindCommand(bm, 1); var bc2 = new BindCommand(bm, { option: 1, index: 1 });     The value of ‘bc1.outputOption’ is ‘{option:1, index: 0}.   The value of ‘bc2.outputOption’ is ‘{option:1, index:1}’.   setting in addcommand()   The addcommand() method of the ‘BindModel’ object can deliver ‘outputOptions’ as parameters when created.   var bm = new BindModel();  bm.addCommand('read', 2); bm.addCommand('view', { option: 2, index: 1 });     bm.command['read'].outputOption value {option:2, index: 0}   bm.command['view'].outputOption vaule {option:2, index: 1}   Set to Property   It can be set by changing the ‘outputOption’ property of the ‘Bindcommand’ object.   bm.command['read'].outputOption = 3; bm.command['view'].outputOption = { option: 3, index: 1 };     bm.command['read'].outputOption value {option:3, index: 0}   bm.command['view'].outputOption value {option:3, index: 1}     Setting Validation Targets (valid)       ‘valid(MetaView)’ must be configured for validation. First, add the inspection object to the ‘valid.column’ collection and set the ‘required’ and ‘constraits’ properties.   Type: constructs (HTML Column property)  type RegExpType = {reg: RegExp, msg: string, return: boolean = true}; type FuncType = (value: any)=&gt;boolean; type ContiditionType = RegExpType | FuncType; type ConstrainstType = ContiditionType[] | ContiditionType;  const constraints: ConstrainstType[] | ConstrainstType;     required : indicates whether required; if true, the value ‘value’ is ‘blank, null’ will fail.   constructs : Inspects for constraints if the value is not blank or null.   • reg : regular expression to be matched.   • msg : If return is false depending on whether it matches or not, it is a failure message.       • If return is true, this is an error message when matching fails.       • If return is false, it is an error message when matching is successful.   • return : This is the return result for reg matching. The default is true.   Constraints by frequency of use   | FREQUIRED | required | constraits | Explanation| | —— | ———— | ————— | ————————— | | 50% || || Select value | 30% | true | | required value | 15% | | | {…} | Select value, value constrained | | 5% | True | {…} | Required value, value has constraints |  (Shopping mall table: based on 20ea)   var bm = new BindModel();  bm.addCommand('test');  bm.cmd['test'].addColumn('user_name'); bm.cmd['test'].addColumn('passwd'); bm.cmd['test'].addColumn('user_id'); bm.cmd['test'].addColumn('email');  bm.columns['user_name'].required = true; bm.columns['passwd'].required = true; bm.columns['user_id'].required = true;  bm.columns['passwd'].constraints = { \tregex: /.{6}/, msg: \"Please enter at least 6 characters.\" }; bm.columns['user_id'].constraints = [ \t(val)=&gt;{ reutrn val.length &gt; 8 },  \t{regex: /\\D{8}/, msg: \"Please type in English\", return: false} ]; bm.columns['email'].constraints = { \tregex: /.{6}/, msg: \"Please enter at least 6 characters.\" };  bm.cmd['test'].execute();     user_name : Mandatory condition. Failed to enter blank space. ‘cbFail’ will be called.   passwd : Required condition, successful only if it matches the regular expression condition.   user_id : prerequisite, successful in the first functional condition, and successful only when non-matching in the second regular expression condition.   email : Selection condition; successful if blank; successful if you enter a value must be matched with the regular expression.   To add a column   Adding a column adds the column to the default table ‘_baseTable’ and registers the reference to the ‘MetaView’ specified in the bind command. Methods of adding a column include addColumn() and addColumnValue().   타입 : addColumn(), addColumnValue()  type addColumn = ( \tcolName: string,  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;  type addColumnValue = ( \tcolName: string,  \tvalue: any,  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;     If you use the ‘$all’ indicator in the views parameter, it is added to all ‘MetaView (valid, bind, output).   The bTable parameter specifies the table to which the column is added, and the default is ‘_baseTable’.   Adding and mapping columns   Add a column to the base table and register a reference to the specified ‘MetaView’. The addColumn() method adds an empty column, and the addColumnValue() method sets the ‘value’ value after adding the column.   var bm = new BindModel();  bm.addCommand('test');  bm.command['test'].addColumn('aa', 'valid'); bm.command['test'].addColumn('bb', ['bind', 'output']); bm.command['test'].addColumn('cc', '$all'); bm.command['test'].addColumn('dd');  // bm['first'].columns.count  == 4 ('aa', 'bb', 'cc', 'dd')  // bm.command['test'].valid.columns.count  == 3 ('aa', 'cc', 'dd') // bm.command['test'].bind.columns.count   == 3 ('bb', 'cc', 'dd') // bm.command['test'].output.columns.count == 3 ('bb', 'cc', 'dd')     Invoking the addColumn() method adds an empty column.   Calling the addColumnValue() method sets the ‘value’ value after adding the column.   The ‘aa’ column registers a reference to the specified ‘MetaView (valid).   The ‘bb’ column registers a reference to the specified ‘MetaView (bind, output).   The ‘cc’ column registers a reference to the entire ‘MetaView (valid, bind, output).   If you omit the parameter when adding the ‘dd’ column, register the reference in the entire ‘MetaView’.   Adding and mapping columns to an extension table   Add a column to the specified ‘MetaTable’ and register a reference to the specified ‘MetaView’.   var bm = new BindModel();  bm.addTable('second'); bm.addCommand('test');  bm.command['test'].addColumn('aa', 'valid', bm.second); bm.command['test'].addColumn('bb', '$all', 'second');  // bm['first'].columns.count  == 0 // bm['second'].columns.count == 2 ('aa', 'bb')  // bm.command['test'].valid.columns.count  == 1 ('aa', 'bb') // bm.command['test'].bind.columns.count   == 1 ('bb') // bm.command['test'].output.columns.count == 1 ('bb')     The ‘aa’ column is added to the ‘MetaTable(second)’ and registers a reference to the specified ‘MetaView(valid).   The ‘bb’ column is added to ‘MetaTable(second)’ and the reference is registered in the entire ‘MetaView’.   You can use the above methods to add tables and columns in a variety of ways, and map each column to the appropriate ‘MetaView’, which is useful for efficiently handling data validation, binding, and output.   Setting Up an Existing Column   You can register or release an already registered column as a reference to ‘MetaView’, which allows you to dynamically manage the column to meet various requirements such as validation, binding, and output of data.   Key Features Summary     Column Settings: You can set a specific table’s column to the desired MetaView to process data validation, binding, and output.   Uncolumn: You can dynamically manage column references by releasing the set column from the desired MetaView.   타입 : setColumn(), release()  type TableNameType : string; type ColumnType : string; type FullColumnType : TableNameType + '.'+ ColumnType; type ColumnDotType : FullColumnType | ColumnType; type ViewType : 'valid' | 'bind' | 'output' | '$all' | string;  type setColumn = ( \tcolName: ColumnDotType,  \tviews: ViewType | ViewType[],  \tbTable?: string | MetaTable ) =&gt; void;  type release = ( \tcolName: string,  \tviews?: ViewType | ViewType[] ) =&gt; void;   Setting up and releasing columns   When setting up columns, you can specify columns for a specific table using the ‘Table Name + . + Column Name’ notation.   var bm = new BindModel(); bm.addTable('second');  // Add a column to the default table, first bm.addColumn('aa'); bm.addColumn('bb');  // Adding a column to the extension table, second bm['second'].columns.add('cc'); bm['second'].columns.add('dd');  bm.addCommand('test');  // Column Settings bm.command['test'].setColumn('aa', 'valid'); bm.command['test'].setColumn(['bb', 'second.cc'], 'bind'); bm.command['test'].setColumn('second.dd', '$all');  // Number of columns in the base table // bm.first.columns.count == 2 ('aa', 'bb') // Number of columns in the extension table // bm.second.columns.count == 2 ('cc', 'dd') // Number of columns in MetaView // bm.command['test'].valid.columns.count == 2 ('aa', 'dd') // bm.command['test'].bind.columns.count == 2 ('bb', 'dd') // bm.command['test'].output.columns.count == 2 ('cc', 'dd')  // Release the column bm.command['test'].release('aa', 'valid'); bm.command['test'].release(['bb', 'cc'], 'bind'); bm.command['test'].release('dd', '$all');  // Number of columns in MetaView // bm.command['test'].valid.columns.count == 0 // bm.command['test'].bind.columns.count == 0 // bm.command['test'].output.columns.count == 0     Add the ‘aa’ column and register the reference to the specified ‘MetaView (valid).   Add a ‘bb’ column and register a reference to the specified ‘MetaView(bind).   Add ‘cc’ column ‘MetaTable(second)’ and register the reference to the specified ‘MetaView(bind).   Add ‘dd’ column ‘MetaTable(second)’ and register a reference to the entire ‘MetaView’.   The above methods allow you to dynamically set up or release existing columns in MetaView, providing flexibility for complex data processing requirements.   Type of output option (output)   If response data is multiple records, import the data in the order of the ‘_outputs’ collection. To import multiple records, you must add a collection of ‘_outputs’ as many records as possible.  Records greater than ‘_outputs’ collections are excluded. (option &gt; 0)   | Options | Description | | ———– | ————————————————————— | | 0 (default) | output bind 안함                                                  | | 1 | Gets the row of all columns | 2 | Gets the row of existing columns | | 3 | Gets the row of existing columns and sets the row of index locations to column value |  Ignore output: option = 0   Does not import data to ‘output(MetaView)’. It is mainly used to modify data, such as create, update, delete, and is suitable when response data is not needed.  This option is mainly used when performing data change operations, and increases efficiency by minimizing data returns.   var bm = new BindModel(); // Add 'create' command and set output option to 0 to not get data bm.addCommand('create', 0); // Set a value in column 'aa' bm.cmd['create'].addColumnValue('aa', -10); // Execute a command bm.cmd['create'].execute();  // bm.columns.count == 1 // bm.columns['aa'].value == -10 // bm.cmd['create'].output.rows.count == 0   Import all data: option = 1   Option value 1 is a way to load all response data into ‘output(MetaView)’, which is useful for simply outputting a column of all data received from a server or for checking the data structure.   { \t\"rows\": [ \t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t] }   var bm = new BindModel();  // Add 'list' command and set output option to 1 to get all data bm.addCommand('list', 1);  bm.cmd['list'].execute();  // bm.columns.count == 3 // bm.cmd['list'].output.rows.count == 2 // bm.cmd['list'].output.rows[0]['aa'] == 10 // bm.cmd['list'].output.rows[0]['bb'] == 20 // bm.cmd['list'].output.rows[0]['cc'] == 30 // bm.cmd['list'].output.rows[1]['aa'] == 11 // bm.cmd['list'].output.rows[2]['bb'] == 21 // bm.cmd['list'].output.rows[3]['cc'] == 31     Even if the column is not predefined, it is dynamically generated based on response data.   This option is useful for checking the full structure of data received from the server, or for loading basic data for display and subsequent processing operations.   Import only data from the specified column: option = 2   From the response data, only columns existing in ‘output(MetaView)’ are imported.   { \t\"rows\": [ \t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t] }   var bm = new BindModel(); bm.addCommand('list', 2); bm.cmd['list'].addColumnValue('aa', 0); bm.cmd['list'].addColumnValue('bb', 0); bm.cmd['list'].execute();  // bm.columns.count == 2 // bm.cmd['list'].output.rows.count == 2 // bm.cmd['list'].output.rows[0]['aa'] == 10 // bm.cmd['list'].output.rows[0]['bb'] == 20 // bm.cmd['list'].output.rows[1]['aa'] == 11 // bm.cmd['list'].output.rows[2]['bb'] == 21   Set data to column value (specified column): option = 3   From the response data, only the column that exists in ‘output(MetaView)’ is imported, and the specified data is set to the value of the column ‘value’.   { \t\"rows\": { \"aa\": 10, \"bb\", 20, \"cc\": 30 }, }   var bm = new BindModel(); bm.addCommand('read', 3); bm.cmd['read'].addColumnValue('aa', 0); bm.cmd['read'].addColumnValue('bb', 0); bm.cmd['read'].execute();  // bm.columns.count == 2 // bm.columns['aa'].value == 10 // bm.columns['bb'].value == 20   Single Indexing (option: 3)   Sets the specific ‘rows’ value of the response data to the column ‘value’.   { \t\"rows\": [ \t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t] }   var bm = new BindModel(); bm.addCommand('test', 3); bc.outputOption.index = 1;   // index set bm.cmd['test'].addColumnValue('aa', 0); bm.cmd['test'].addColumnValue('bb', 0); bm.cmd['test'].execute();  // bm.columns.count == 2 // bm.columns['aa'].value == 11 // bm.columns['bb'].value == 21     The value of the second (index = 1) ‘rows’ is set to the value of ‘value’.   Specifying composite index (option: 3)   Sets a specific ‘rows’ value for multiple response data to the column ‘value’.   [ \t{ \t\t\"rows\": [ \t\t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t\t] \t}, \t{ \t\t\"rows\": [ \t\t\t{ \"dd\": 40, \"ee\", 50 }, \t\t\t{ \"dd\": 41, \"ee\", 51 }, \t\t\t{ \"dd\": 42, \"ee\", 52 }, \t\t] \t}, ]   var bm = new BindModel(); bm.addCommand('test', 3); bc.outputOption.index = [0, 1];   // index set bm.cmd['test'].newOutput('two'); bm.cmd['test'].addColumnValue('aa', 0); bm.cmd['test'].addColumnValue('bb', 0); bm.cmd['test'].addColumnValue('dd', 0); bm.cmd['test'].execute();  // bm.columns.count == 3 // bm.columns['aa'].value == 10 // bm.columns['bb'].value == 20 // bm.columns['dd'].value == 41 // bm.cmd['test'].output.rows.count == 2 // bm.cmd['test'].two.rows.count == 3     The value of index = 0 in the first response record was set to the value of the column (‘aa’, ‘bb’).   The value of index = 1 in the second response record was set to the value of column (‘dd’).     {   \"rows\": { \"aa\": 10, \"bb\", 20, \"cc\": 30 }, }           var bm = new BindModel(); bm.addCommand('read', 3); bm.cmd['read'].addColumnValue('aa', 0); bm.cmd['read'].addColumnValue('bb', 0); bm.cmd['read'].execute();  // bm.columns.count == 2 // bm.columns['aa'].value == 10 // bm.columns['bb'].value == 20   Single Indexing (option: 3)   Sets the specific ‘rows’ value of the response data to the column ‘value’.   { \t\"rows\": [ \t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t] }   var bm = new BindModel(); bm.addCommand('test', 3); bc.outputOption.index = 1;   // index set bm.cmd['test'].addColumnValue('aa', 0); bm.cmd['test'].addColumnValue('bb', 0); bm.cmd['test'].execute();  // bm.columns.count == 2 // bm.columns['aa'].value == 11 // bm.columns['bb'].value == 21     The value of the second (index = 1) ‘rows’ is set to the value of ‘value’.   Specifying composite index (option: 3)   Sets a specific ‘rows’ value for multiple response data to the column ‘value’.   [ \t{ \t\t\"rows\": [ \t\t\t{ \"aa\": 10, \"bb\", 20, \"cc\": 30 }, \t\t\t{ \"aa\": 11, \"bb\", 21, \"cc\": 31 }, \t\t] \t}, \t{ \t\t\"rows\": [ \t\t\t{ \"dd\": 40, \"ee\", 50 }, \t\t\t{ \"dd\": 41, \"ee\", 51 }, \t\t\t{ \"dd\": 42, \"ee\", 52 }, \t\t] \t}, ]   var bm = new BindModel(); bm.addCommand('test', 3); bc.outputOption.index = [0, 1];   // index set bm.cmd['test'].newOutput('two'); bm.cmd['test'].addColumnValue('aa', 0); bm.cmd['test'].addColumnValue('bb', 0); bm.cmd['test'].addColumnValue('dd', 0); bm.cmd['test'].execute();  // bm.columns.count == 3 // bm.columns['aa'].value == 10 // bm.columns['bb'].value == 20 // bm.columns['dd'].value == 41 // bm.cmd['test'].output.rows.count == 2 // bm.cmd['test'].two.rows.count == 3     The value of index = 0 in the first response record was set to the value of the column (‘aa’, ‘bb’).   The value of index = 1 in the second response record was set to the value of column (‘dd’).  ","url": "http://localhost:4000/en/docs/bind-commnad-config/"
  },{
    "title": "BindModel Class",
    "excerpt":"주요 구조  속성 관계   BindModel 객체를 생성하고 addCommmand() 메소드로 BindCommand 객체를 생성합니다. 생성된 command['별칭'] 에는 valid, bind, output 속성값의  MetaView 가 있습니다. ajax 통신은 내부적으로 axios 모듈을 이용하고 있습니다.   클래스 다이어그램    상속 관계   BindModelAjax 을 상속하여 확장하거나 BindModel 을 상속하여 재정의하여 사용자화 할 수 있습니다.   클래스 다이어그램    구성요소   속성                  항목       설명                       baseConfig       바인딩 기본 config을 설정합니다.                 url       바인딩 기본 config.url을 설정합니다.                 _tables       메타 테이블 컬렉션입니다. 여러 메타 테이블을 관리합니다.                 _columnType       아이템 타입을 설정합니다.                 items       아이템 컬렉션입니다.                 fn       바인드모델 함수 컬렉션입니다. (내부함수 + 노출함수)                 command       바인딩 명령 컬렉션입니다.                 columns       컬럼 컬렉션입니다. _baseTable의 컬럼을 나타냅니다.                 first       동적으로 생성된 첫 번째 메타 테이블입니다.                 cbFail       검사(valid)에서 실패 시 호출되는 콜백 함수입니다.                 cbError       오류 발생 시 호출되는 콜백 함수입니다.                 cbBaseBegin       시작 전 기본 콜백 함수입니다.  (cbBegin 콜백 함수가 없을 경우 사용됨)                 cbBaseValid       검사(valid) 시 기본 콜백 함수입니다.  (cbValid 콜백 함수가 없을 경우 사용됨)                 cbBaseBind       바인드 시 기본 콜백 함수입니다.  (cbBind 콜백 함수가 없을 경우 사용됨)                 cbBaseResult       바인드 결과 수신 시 기본 콜백 함수입니다.  (cbResult 콜백 함수가 없을 경우 사용됨)                 cbBaseOutput       출력 기본 콜백 함수입니다. (cbOutput 콜백 함수가 없을 경우 사용됨)                 cbBaseEnd       실행 완료 시 기본 콜백 함수입니다.  (cbEnd 콜백 함수가 없을 경우 사용됨)                 preRegister       init() 호출시 처음에 호출되는 콜백 함수입니다.                 preCheck       init() 호출시 boolean 을 리턴하는 콜백 함수입니다.                 preReady       init() 호출시 preCheck 콜백 함수 결과가 true 일때 호출되는 콜백 함수입니다.                 _baseTable       기본 엔티티를 정의합니다.                 _guid       객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다.                 _type       객체의 생성자 함수. 객체가 생성될 때 사용된 함수입니다.                                     메소드                  항목       설명                       checkSelector(collection?)       셀렉터를 검사합니다.                 getSelector()       대상 셀렐터 목록을 얻습니다.                 addCommand(name, opt?, baseTable?)       명령을 추가합니다.                 setService(svc, chkType)       서비스를 설정합니다.                 init()       초기화 작업을 수행합니다. 내부적으로 preRegister() -&gt; preCheck() -&gt; preReady() 순서로 호출합니다.                 addTable(name)       테이블을 등록합니다.                 addColumn(column, cmds?, views?, bTable?)       컬럼을 추가하고 명령과 매핑합니다.                 addColumnValue(name, value, cmds?, views?, bTable?)       컬럼과 값을 추가하고 지정된 테이블에 추가하며, 컬럼의 참조를 BindCommand의 valid, bind, output MetaView에 등록합니다.                 setMapping(mapping: collection | object, bTable?)       컬럼을 매핑합니다.                 getObject(): object       현재 객체를 직렬화(guid 타입) 객체로 얻습니다. (순환참조는 $ref 값으로 대체됩니다.)                 setObject(obj, origin)       직렬화(guid 타입) 객체를 현재 객체에 설정합니다. (객체는 초기화 됩니다.)                 equal(target)       현재 객체와 지정된 객체가 동일한지 비교합니다.                 getTypes()       현재 객체의 생성자와 프로토타입 체인의 모든 생성자를 배열로 반환합니다.                 instanceOf(target)       현재 객체가 지정된 타입의 인스턴스인지 확인합니다. (_UNION 포함)           이벤트                  항목       설명                       onExecute       execte() 실행 전 이벤트 입니다.                 onExecuted       execte() 실행 후 이벤트 입니다.             세부 설명   주요 속성   baseConfig      바인딩 기본 config을 설정합니다.    type baseConfig = object;   url      바인딩 기본 config.url을 설정합니다.    type url = string;   _tables      메타 테이블 컬렉션입니다. 여러 메타 테이블을 관리합니다.    type _tables = MetaTableCollection;   _columnType      컬럼 타입을 설정합니다.    type _columnType = MetaColumn;   items      아이템 컬렉션입니다.    type items = PropertyCollection;   fn      바인드모델 함수 컬렉션입니다. (내부함수 + 노출함수)    type fn = PropertyCollection;   command      바인딩 명령 컬렉션입니다.    type command = PropertyCollection;   \bcmd      command 의 별칭입니다.    type \bcmd = PropertyCollection;   columns      컬럼 컬렉션입니다. _baseTable의 컬럼을 나타냅니다.    type columns = MetaTableColumnCollection;   first      동적으로 생성된 첫 번째 메타 테이블입니다. _tables[0] 의 참조값입니다.    type first = MetaTable;   cbFail      검사(valid)에서 실패 시 호출되는 콜백 함수입니다.    type cbFail = (result: object, column: MetaColumn) =&gt; void;     result : 검사 결과를 담은 객체입니다.   column : 검사에 사용된 MetaColumn 객체입니다.     cbError          오류 발생 시 호출되는 콜백 함수입니다.    type cbError = (msg: string, status: object, response: object) =&gt; void;     msg : 오류 메시지입니다.   status : 상태 정보를 담은 객체입니다.   response : 응답 객체입니다.     cbBaseBegin          시작 전 기본 콜백 함수입니다. (cbBegin 콜백 함수가 없을 경우 사용됨)    type cbBaseBegin = (command: BindCommand) =&gt; void;     command : 현재 바인드 명령 객체입니다.     cbBaseValid          검사(valid) 시 기본 콜백 함수입니다. (cbValid 콜백 함수가 없을 경우 사용됨)    type cbBaseValid = (valid: MetaView, command: BindCommand) =&gt; boolean;     valid : 검사할 MetaView 객체입니다.   command : 현재 바인드 명령 객체입니다.   return : 검사 결과를 나타내는 boolean 값입니다.   cbBaseBind      바인드 시 기본 콜백 함수입니다. (cbBind 콜백 함수가 없을 경우 사용됨)    type cbBaseBind = ( \tbind: MetaView,  \tcommand: BindCommand,  \tconfig: object ) =&gt; void;     bind : 바인드할 MetaView 객체입니다.   command : 현재 바인드 명령 객체입니다.   config : 설정 객체입니다.   cbBaseResult      바인드 결과 수신 시 기본 콜백 함수입니다. (cbResult 콜백 함수가 없을 경우 사용됨)    type cbBaseResult = ( \tdata: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     data : 바인드 결과 데이터 객체입니다.   command : 현재 바인드 명령 객체입니다.   response : 응답 객체입니다.   return : 처리된 결과 객체를 반환합니다.   cbBaseOutput      출력 기본 콜백 함수입니다. (cbOutput 콜백 함수가 없을 경우 사용됨)    type cbBaseOutput = ( \toutputs: MetaViewCollection,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     outputs : 메타 뷰 컬렉션입니다.   command : 현재 바인드 명령 객체입니다.   response : 응답 객체입니다.   return : 처리된 결과 객체를 반환합니다.   cbBaseEnd      실행 완료 시 기본 콜백 함수입니다. (cbEnd 콜백 함수가 없을 경우 사용됨)    type cbBaseEnd = ( \tstatus: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; void;     status : 상태 정보를 담은 객체입니다.   command : 현재 바인드 명령 객체입니다.   response : 응답 객체입니다.   preRegister      init() 호출시 처음에 호출되는 콜백 함수입니다.    type preRegister = (model: BindModel) =&gt; void;     model : 현재 바인드 모델 객체입니다.   preCheck      init() 호출시 boolean 을 리턴하는 콜백 함수입니다.    type (model: BindModel)=&gt;boolean;     model : 현재 바인드 모델 객체입니다.   return : 검사 결과를 나타내는 boolean 값입니다.   preReady      init() 호출시 preCheck 콜백 함수 결과가 true 일때 호출되는 콜백 함수입니다.    type preReady = (model: BindModel) =&gt; void;     model : 현재 바인드 모델 객체입니다.   _baseTable      기본 엔티티를 정의합니다.    type _baseTable = MetaTable;   _guid      객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다.    type _guid = string;   _type      객체의 생성자 함수입니다. 객체가 생성될 때 사용된 함수입니다.    type _type = Function;    주요 메소드   checkSelector()      셀렉터를 검사합니다.    type checkSelector = (collection: BaseColumnCollection) =&gt; boolean;     collection : 검사할 컬럼 컬렉션입니다.   return : 검사 결과를 나타내는 boolean 값입니다.   getSelector()      대상 셀렐터 목록을 얻습니다.    type getSelector = (collection: PropertyCollection) =&gt; object[];     collection : 검사할 속성 컬렉션입니다. 기본값은 items 입니다.   return : 셀렉터 목록을 나타내는 객체 배열입니다.   addCommand()      명령을 추가합니다.    type addCommand = ( \tname: string,  \toption: number,  \tbaseTable: MetaTable ) =&gt; BindCommand;     name : 명령 이름입니다.   option : 출력옵션입니다.   baseTable : (선택적) 기본 테이블 객체입니다.   return : 추가된 바인드 명령 객체입니다.   setService()      서비스를 설정합니다.    type setService = (service: IServiceAjax, passTypeChk: boolean) =&gt; void;     service : 서비스 객체입니다.   passTypeChk : 서비스객체 type 검사 통과 유무입니다. (기본값: false)   init()      초기화 작업을 수행합니다. 내부적으로 preRegister() -&gt; preCheck() -&gt; preReady() 순서로 호출합니다.    type init = () =&gt; void;   addTable()      테이블을 등록합니다.    type addTable = (name: string) =&gt; MetaTable;     name : 등록할 테이블의 이름입니다.   return : 등록된 메타 테이블 객체를 반환합니다.   addColumn()      컬럼을 추가하고 명령과 매핑합니다.    type addColumn = ( \tcolumn: MetaColumn,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; void;     column: 등록할 컬럼 객체입니다. 문자열 또는 MetaColumn 객체일 수 있습니다.   cmds : (선택적) 뷰의 위치를 지정하는 명령입니다. 문자열 또는 문자열 배열일 수 있습니다.   views : (선택적) 추가할 뷰 엔티티 이름입니다. 문자열 또는 문자열 배열일 수 있습니다.   bTable : (선택적) 매핑할 기본 테이블 객체 또는 테이블 이름입니다.   addColumnValue()      컬럼과 값을 추가하고 지정된 테이블에 추가하며, 컬럼의 참조를 BindCommand의 valid, bind, output MetaView에 등록합니다.    type addColumnValue = ( \tname: string,  \tvalue: any,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; void;     name : 컬럼 이름입니다.   value : 컬럼 값입니다.   cmds : 뷰의 위치를 지정하는 명령입니다. 문자열 또는 문자열 배열일 수 있습니다.   views : 추가할 뷰 엔티티 이름입니다. 문자열 또는 문자열 배열일 수 있습니다.   bTable : (선택적) 매핑할 기본 테이블 객체 또는 테이블 이름입니다.   setMapping()      컬럼을 매핑합니다.    type setMapping = ( \tmapping: PropertyCollection | object,  \tbaseTable?: string | MetaTable ) =&gt; void;     mapping : MetaColumn에 매핑할 객체 또는 컬렉션   baseTable : (선택적) 매핑할 기본 테이블 객체 또는 테이블 이름입니다.   getObject()      현재 객체를 직렬화(guid 타입) 객체로 얻습니다. (순환참조는 $ref 값으로 대체됩니다.)    type getObject = (vOpt?: number, owned?: object | Array&lt;object&gt;) =&gt; object;     vOpt :  가져오기 옵션입니다. 기본값은 0 입니다.            opt=0 : 참조 구조(_guid:Yes, $ref:Yes)       opt=1 : 중복 구조(_guid:Yes, $ref:Yes)       opt=2 : 비참조 구조(_guid:No, $ref:No)           owned : 현재 객체를 소유하는 상위 객체들입니다. 기본값은 빈객체 입니다.   return : 직렬화된 객체를 반환합니다.   a.getObject(2) == b.getObject(2)   setObject()      직렬화(guid 타입) 객체를 현재 객체에 설정합니다. (객체는 초기화 됩니다.)    type setObject = (oGuid: object, origin?: object) =&gt; void;     oGuid : 직렬화할 guid 타입의 객체입니다.   origin : 현재 객체를 설정하는 원본 객체입니다. 기본값은 oGuid 입니다.   equal()      현재 객체와 지정된 객체가 동일한지 비교합니다.    type equal = (target: object) =&gt; boolean;     return : 두 객체가 동일한지 여부를 반환합니다.   getTypes()      현재 객체의 생성자와 프로토타입 체인의 모든 생성자를 배열로 반환합니다.    type getTypes = () =&gt; Array&lt;Function&gt;;     return : 생성자 함수의 배열을 반환합니다.   예제  const types = obj.getTypes(); console.log(types); // [Function: MetaObject]   instanceOf()      현재 객체가 지정된 타입의 인스턴스인지 확인합니다. (_UNION 포함)    type instanceOf = (target: object | string) =&gt; boolean;     target : 확인할 대상 타입 (객체 또는 문자열)입니다.   return : 지정된 타입의 인스턴스인지 여부를 반환합니다.    주요 이벤트   onExecute      명령 실행 전 호출되는 이벤트입니다.    type onExecute = (cmd: BindCommand) =&gt; void;     cmd : 실행할 명령 객체입니다.   onExecuted      명령 실행 후 호출되는 이벤트입니다.    type onExecuted = (cmd: BindCommand, result: object) =&gt; void;     cmd : 실행한 명령 객체입니다.   result : 명령 실행 결과 객체입니다.   ","url": "http://localhost:4000/ko/docs/api-bind-model-ajax/"
  },{
    "title": "BindModel Class",
    "excerpt":"the main structure  Property Relationships   Create a BindModel object and create a Bind Command object in the addCommmand() method. The generated ‘command[‘identifier’]’ has MetaView with valid, bind, and output attribute values. Ajax communication uses the ‘axios’ module internally.   Class diagram      an inheritance relationship   You can either inherit and extend the BindModel or override the BindModel to customize it.   Class diagram      Components   Properties                  Item       Description                       baseConfig       Set binding default config                 url       Set binding default config.url                 _tables       Meta-table collection. Manage multiple meta-tables.                 [[52. BindModel Class-B#_columnType|_columnType]       Set item type.                 items       Item collection                 fn       collection of bound model functions. (Internal function + Exposure function)                 command       collection of binding commands                 columns       Collection of columns. Represents the columns of the _baseTable.                 first       The first dynamically generated meta table                 cbFail       Callback function called upon failure in inspection (valid)                 cbError       Callback function called in case of error                 cbBaseBegin       Default callback function before startup.   (used without cbBegin callback function)                 cbBaseValid       Default callback function at inspection (valid)   (used without cbValid callback function)                 cbBaseBind       Default callback function when bound.   (used without cbBind callback function)                 cbBaseResult       Default callback function on the receipt of bind results.   (used without cbResult callback function)                 cbBaseOutput       Output Default callback function.  (used without cbOutput callback function)                 cbBaseEnd       Default callback function at execution completion.   (used without cbEnd callback function)                 preRegister       callback function initially called upon init() call                 PreCheck       callback function that returns boolean on init() call.           Method                  Item       Description                               Check Selector (collection?)       Examine the selector                         getSelector()       Get a list of destination selectors                         addcommand (name, opt? , baseTable?)       add command                         setService(svc, chkType)       Set up a service                         Init()       Perform the initialization operation. Internally call ‘preRegister()’ -&gt; ‘preCheck()’ -&gt; ‘preReady()’                         addTable(name)       Register the table                         addColumn (column, cmds? , views? , bTable?)       Add columns and map them with commands                         addColumnValue (name, value, cmds? , views? , bTable?)       Add columns and values, add them to the specified table, and register the reference to the column in the value, bind, output MetaView in Bindcommand.                         setMapping (mapping: collection \\       object, bTable?)       Map columns                 getObject(): object       Gets the current object as a guid type object. (Circular reference is replaced by $ref value.)                         setObject(obj, origin)       Set the serialization (guid type) object to the current object. (The object is initialized.)                         equal(target)       Compare the current object with the specified object.                         getTypes()       Returns the constructors of the current object and all the constructors of the prototype chain to the array.                         instanceOf(target)       Verify that the current object is an instance of the specified type (with _UNION)                   Events  | Item | Description | | ———- | ———————- | | OnExecute | expecte() pre-execution event | OnExecuted | expecte() post-execution event   Detailed description   Key Properties   baseConfig      Set the binding default config.    type baseConfig = object;   url      Set the binding default config.url.    type url = string;   _tables      This is the meta table collection. Manage multiple meta tables.    type _tables = MetaTableCollection;   _columnType      Set the column type.    type _columnType = MetaColumn;   items      It’s an item collection.    type items = PropertyCollection;  fn      A collection of bound model functions. (Internal function + Exposure function)    type fn = PropertyCollection;   command      A collection of binding commands.    type command = PropertyCollection;   cmd      It’s an alias for command.    type cmd = PropertyCollection;   columns      It’s a column collection. Indicates the column in &gt; _baseTable.    type columns = MetaTableColumnCollection;   first      This is the first dynamically generated meta table. Reference value for &gt; _tables[0].    type first = MetaTable;   cbFail      This is the callback function that is called upon failure by valid.    type cbFail = (result: object, column: MetaColumn) =&gt; void;     result : The object containing the result of the examination.   column : ‘MetaColumn’ object used in the inspection.     cbError          This is the callback function that is called when an error occurs.    type cbError = (msg: string, status: object, response: object) =&gt; void;     msg : Error message.   status : The object containing status information.   response —Response object.     cbBaseBegin             Default callback function before startup (used when cbBegin callback function is not present)            type cbBaseBegin = (command: BindCommand) =&gt; void;     command : The current bind command object.     cbBaseValid          Default callback function at valid (used without cbValid callback function)    type cbBaseValid = (valid: MetaView, command: BindCommand) =&gt; boolean;     valid : object ‘MetaView’ to be inspected.   command : The current bind command object.   return : A boolean value representing the result of the examination.   cbBaseBind      Default callback function when bound (used without cbBind callback function)    type cbBaseBind = ( \tbind: MetaView,  \tcommand: BindCommand,  \tconfig: object ) =&gt; void;     bind : object ‘MetaView’ to bind.   command : The current bind command object.   config : This is the setting object.   cbBaseResult      Default callback function when receiving bind results. (Used when cbResult callback function is not available)    type cbBaseResult = ( \tdata: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     data : Bind result data object.   command : The current bind command object.   response —Response object.   return —Returns the processed result object.   cbBaseOutput      Output default callback function (used when cbOutput callback function is not present)    type cbBaseOutput = ( \toutputs: MetaViewCollection,  \tcommand: BindCommand,  \tresponse: object ) =&gt; object;     outputs : Metabiew collection.   command : The current bind command object.   response —Response object.   return —Returns the processed result object.   cbBaseEnd      Default callback function at execution completion (used when cbEnd callback function is not present)    type cbBaseEnd = ( \tstatus: object,  \tcommand: BindCommand,  \tresponse: object ) =&gt; void;     status : The object containing status information.   command : The current bind command object.   response —Response object.   preRegister      This is the callback function that is initially called upon init().    type preRegister = (model: BindModel) =&gt; void;     model : The current bound model object.   preCheck      Callback function that returns boolean on init() call.    type (model: BindModel)=&gt;boolean;     model : The current bound model object.   return : A boolean value representing the result of the examination.   preReady      Callback function called when preCheck callback function result is true when invoking &gt; init().    type preReady = (model: BindModel) =&gt; void;     model : The current bound model object.   _baseTable      Define the default entity.    type _baseTable = MetaTable;   _guid      Unique identifier of the object (GUID). Uniquely identifies the object.    type _guid = string;   _type      The generator function of the object, which was used when the object was created.    type _type = Function;   Key Methods   checkSelector()      Examine the selector.    type checkSelector = (collection: BaseColumnCollection) =&gt; boolean;     collection —Column collection to examine.   return : A boolean value representing the result of the examination.   getSelector()      Obtain a list of destination selectors.    type getSelector = (collection: PropertyCollection) =&gt; object[];     collection : A collection of properties to be examined; the default is items.   return : An object array representing a list of selectors.   addCommand()      Add a command.    type addCommand = ( \tname: string,  \toption: number,  \tbaseTable: MetaTable ) =&gt; BindCommand;     name : The name of the command.   option : Output option.   baseTable : (Optional) Default table object.   return —Added bind command object.   setService()      Set up the service.    type setService = (service: IServiceAjax, passTypeChk: boolean) =&gt; void;     service : service object.   PassTypeChk : Whether the service object type inspection has passed or not. (Default: false)   init()      Perform the initialization operation. Internally, call ‘preRegister()’ -&gt; ‘preCheck()’ -&gt; ‘preReady()’.    type init = () =&gt; void;   addTable()      Register the table.    type addTable = (name: string) =&gt; MetaTable;     name : The name of the table to be registered.   return : Returns the registered meta table object.   addColumn()      Add columns and map them to commands.    type addColumn = ( \tcolumn: MetaColumn,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; void;     column: column object to be registered. It could be a string or ‘MetaColumn’ object.   cmds : (Optional) Command to specify the location of the view; it can be a string or an array of strings.   views —(Optional) Name of the view entity to be added; it can be a string or an array of strings.   bTable : (Optional) Default table object or table name to be mapped.   addColumnValue()      Add columns and values, add them to the specified table, and register the reference to the column in the value, bind, and output MetaView in the Bindcommand.    type addColumnValue = ( \tname: string,  \tvalue: any,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; void;     name : The name of the column.   value : The value of the column.   cmds : Command to specify the location of the view; it can be a string or an array of strings.   views : The name of the view entity to be added; it can be a string or array of strings.   bTable : (Optional) Default table object or table name to be mapped.   setMapping()      Map columns.    type setMapping = ( \tmapping: PropertyCollection | object,  \tbaseTable?: string | MetaTable ) =&gt; void;     mapping —Object or collection to map to MetaColumn   baseTable —(Optional) Default table object or table name to be mapped.   getObject()      Obtain the current object as a guide type object. (Circular references are replaced by $ref values.)    type getObject = (vOpt?: number, owned?: object | Array&lt;object&gt;) =&gt; object;     vOpt : Import option; default is 0.            opt=0: Reference structure (_guid:Yes, $ref:Yes)       opt=1: Redundant structure (_guid:Yes, $ref:Yes)       opt=2 : Non-tidal structure (_guid: No, $ref: No)           aged : The parent objects that currently own the object. The default is an empty object.   return —Returns serialized objects.   a.getObject(2) == b.getObject(2)   setObject()      Set the Guid type object to the current object. (The object will be reset.)    type setObject = (oGuid: object, origin?: object) =&gt; void;     oGuid : Object of the guid type to serialize.   origin : This is the original object that sets the current object. The default is oGuid.   equal()      Compare the current object with the specified object.    type equal = (target: object) =&gt; boolean;     return —Returns whether the two objects are identical.   getTypes()      Returns the creators of the current object and all the creators of the prototype chain to the array.    type getTypes = () =&gt; Array&lt;Function&gt;;     return : Returns the array of generator functions.   const types = obj.getTypes(); console.log(types); // [Function: MetaObject]  instanceOf()      Verify that the current object is an instance of the specified type (including _UNION)    type instanceOf = (target: object | string) =&gt; boolean;     target : The type of object to be checked (object or string).   return —Returns whether this is an instance of the specified type.   Key Events   onExecute      Events that are called before the command is executed.    type onExecute = (cmd: BindCommand) =&gt; void;     cmd : Command object to be executed.   onExecuted      An event that is called after the command is executed.    type onExecuted = (cmd: BindCommand, result: object) =&gt; void;     cmd : Command object executed.   result : The result object of the command execution.   ","url": "http://localhost:4000/en/docs/api-bind-model-ajax/"
  },{
    "title": "바인드 모델 구성",
    "excerpt":"BindModelAjax는 프레임워크의 핵심 클래스이며, 주요 기능으로 명령 추가, 컬럼 추가, 테이블 추가, 서비스 객체 주입 등을 지원합니다.   주요 기능      명령 추가 : BindCommand 객체를 추가합니다.   컬럼 추가 : HTMLColumn 객체를 추가합니다.   테이블 추가 : MetaTable 객체를 추가합니다.   기본 콜백함수 제공 : 단계별 기본 콜백함수를 제공합니다.   서비스객체 주입 : 서비스 객체를 주입하여 BindModel 객체를 구성합니다.   주요 속성      ‘baseConfig’ : 기본 axios 의 config 설정 객체입니다.   ‘url’ : baseConfig.url 경로입니다.   ‘columns’ :  HTMLColumn 을 제어하는 컬렉션입니다.   ‘command’ : BindCommand 을 제어하는 컬렉션입니다. (별칭 : cmd)   ‘fn’ :  사용자 함수를 제어하는 컬렉션입니다.   ‘items’ : item 을 제어하는 컬렉션 입니다. (컬럼의 원시 속성)   ‘_tables’ : MetaTable 을 제어하는 컬렉션입니다.   ‘_baseTable’ : 기본 테이블 입니다. (‘columns’ = _baseTable.columns)   이벤트      onExecute :  공통으로  execute() 실행시 처음으로 호출합니다.   onExecuted : 공통으로 execute() 실행시 마지막으로 호출합니다.   콜백(속성)      ‘cbBaseBegin’ : 기본 시작 전 콜백함수 입니다.   ‘cbBaseValid’ : 기본 유효성 검사 콜백함수 입니다.   ‘cbBaseBind’ : 기본 서버 요청 콜백함수 입니다.   ‘cbBaseResult’ : 기본 서버 응답 콜백함수 입니다.   ‘cbBaseOutput’ : 기본 출력 콜백함수 입니다.   ‘cbBaseEnd’ : 기본 종료 전 콜백함수 입니다.     주요 메소드       addCommand() : BindCommand 객체를 생성합니다.   addTable() : MetaTable 객체를 추가합니다.   setService() : 서비스 객체를 주입하여 BindModel  객체를 구성합니다.   checkSelector() :  ‘selector’ 객체로 DOM 유효성 검사합니다.   getSelector() : ‘selector’ 객체 목록을 가져옵니다.   addColumn() : HTMLColumn 객체를 추가합니다.   addColumnValue() : HTMLColumn 객체를 추가하고, ‘value’ 값을 설정합니다.   setMapping() : HTMLColumn 을 BindCommand 의 MetaView 객체에 매핑합니다.   init() : ‘preRegister’, ‘preCheck’, ‘preRedy’ 콜백함수를 순차적으로 실행합니다.   BindModelAjax 는 다목적 프레임워크로, 다양한 명령과 테이블, 컬럼을 유연하게 추가하고 관리할 수 있는 기능을 제공합니다. 이 문서를 통해 이 클래스의 주요 기능과 콜백을 숙지하여 효과적으로 사용할 수 있습니다.   서버 요청 설정하기   기본 요청 경로   url 속성은 서버에 요청하는 기본 URL 경로를 설정합니다. BindCommand 객체에 url 경로를 설정하면, BindModel의 url 경로는 무시됩니다.   var bm = new BindModel();  bm.url  = '/user';   동적 url 설정하기   특정 작업(command)에 따라 요청 경로를 동적으로 변경해야 할 경우, BindModelAjax 객체의 콜백 함수를 활용하여 URL을 쉽게 설정할 수 있습니다.    var idx = 1;  bm.cbBegin = function(cmd) { \tcmd._model.url = `/user/${idx}`;  };     cmd._model은 BindCommand가 포함된 BindModel을 참조합니다.   기본 요청 환경 설정(axios)   HTTP 통신을 위한 axios의 기본 설정을 통해 요청 환경을 구성할 수 있습니다.   var bm = new BindModel(); // Axios Preference Example bm.baseConfig.baseURL = 'https://api.example.com'; bm.baseConfig.timeout = 10000; // 10초 bm.baseConfig.headers.common['Authorization'] = 'Bearer YOUR_TOKEN'; bm.baseConfig.headers.post['Content-Type'] = 'application/json';     baseURL : 모든 요청에 공통으로 적용될 기본 URL을 설정합니다.   timeout : 요청의 최대 대기 시간을 설정합니다.   headers : 요청 시 사용할 기본 헤더를 설정합니다. 예를 들어, 인증 토큰을 설정하거나 콘텐츠 유형을 지정할 수 있습니다.   실행 이벤트 설정하기   모든 명령의 execute() 실행 시 호출되는 전역 이벤트입니다.   타입 : onExecute, onExecuted  type onExecute = (model: BindModel, cmd: BindCommand) =&gt; void;  type onExecuted = (model: BindModel, cmd: BindCommand) =&gt; void;      ‘onExecute’ 이벤트는 모든 execute() 실행시 처음으로 호출됩니다.   ‘onExecuted’ 이벤트는 모든 execute() 실행시 마지막으로 호출됩니다.   var bm = new BindModel(); bm.addCommand('read'); // Global Event Settings bm.onExecute = () =&gt; {  \tconsole.log('model 에서 onExecute 호출') }; bm.onExecuted = () =&gt; {  \tconsole.log('model 에서 onExecuted 호출') }; // Execute bm.command['read'].execute();  // Output results: // Call onExecute from model // Call onExecuted in model  오류 및 실패 처리하기   오류 처리   모든 오류 및 예외 발생 시 호출되는 콜백입니다. 타입 : cbError  type cbError = (msg: string, status: number, response: object) =&gt; void;  cbError 발생 시점은     서버 요청 관련 axios error, ajax error 발생시 호출됩니다.   모든 에러 및 예외 발생시 호출됩니다.   var bm = new BindModel();  bm.cbError = function(msg, status, res) {  \tconsole.error('Err: '+ msg);  };     ‘cbError’ 의 기본값을 객체생성시 제공됩니다.   실패 처리   논리적 실패 메시지를 처리합니다. (주로 유효성 검사 실패시 사용합니다.)   타입 : cbFail  type cbFail = (msg: string, valid: MetaView) =&gt; void;  ‘cbFail’ 발생 시점은 execute() 메소드 실행되어     valid(MetaView) 유효성 검사가 실패한 경우 호출됩니다.   ‘cbValid’ / ‘cbBaseValid’ 콜백함수에서 false 반환한 경우 호출됩니다.   var bm = new BindModel();  bm.cbFail = function(msg, valid) {  \tconsole.warn ('Failed. Err:'+ msg);  };     ‘cbFail’ 의 기본값을 객체생성시 제공됩니다.   흐름 제어하기 (hooking)   execute() 실행시 순차적으로 콜백함수가 호출되어\u001d흐름을 제어할 수 있습니다.                  [[41. Callback Lifecycle-B       Refer to: Callback Lifecycle]           1. 기본 시작시 콜백   execute() 호출시 처음으로 호출되는 콜백입니다. 대상 ‘cbBegin’ 이 ‘cbBaseBegin’ 콜백보다 우선순위가 높습니다.   타입 : cbBaseBegin  type cbBaseBegin = (cmd: BindCommand) =&gt; void;  일반적인 활용방안은     url 및 config 의 공통 정보 설정에 활용됩니다.   var bm = new BindModel();  bm.cbBaseBegin = function(cmd) { \tcmd.url = '/member/1'; };  2. 기본 유효성 검사 콜백   execute() 실행시 valid(MetaView) 에 대한 유효성 검사 전에 호출되는 콜백입니다. 대상 ‘cbValid’ 이 ‘cbBaseValid’ 콜백보다 우선순위가 높습니다. 리턴값이 false 이면 ‘cbFail’ 콜백 호출되고 종료합니다. 타입 : cbBaseValid  type cbBaseValid = (valid: MetaView, cmd: BindCommand) =&gt; boolean;  일반적인 활용방안은     서버 요청전 검사에 활용됩니다.   사용자에게 처리결과를 확인하는 용도로 활용됩니다.   var bm = new BindModel();  bm.cbBaseValid = function(view, cmd) {  \treturn view.colums.count &lt;= 0; }; bm.cbBaseValid = function(view, cmd) { \treturn confirm ('Do you want to delete?'); };  3. 기본 서버 요청 콜백   execute() 실행시 bind(MetaView) 컬럼값을 전송하기 전에 호출되는 콜백입니다. 대상 ‘cbBind’ 이 ‘cbBaseBind’ 콜백보다 우선순위가 높습니다.   타입 : cbBaseBind   type cbBaseBind = (view: MetaView, cmd: BindCommand, config: object) =&gt; void;   일반적인 활용방안은     전송타입의 설정에 활용됩니다. (enctype)   통합 로그인 관련 설정에 활용됩니다.   비밀번호 암호화에 활용됩니다.   4. 기본 서버 응답 콜백   execute() 실행시 서버에서 응답을 받은 후에 호출되는 콜백입니다. 대상 ‘cbResult’ 이 ‘cbBaseResult’ 콜백보다 우선순위가 높습니다.   타입 : cbBaseRes  type cbBaseResult = (data: object, cmd: BindCommand, res: object) =&gt; object;   일반적인 활용방안은     응답받은 data 를 MetaView 형식의 스키마로 변경하는 용도로 활용됩니다.   var bm = new BindModel(); // data = { aa: 1, bb: 2 } bm.cbBaseResult = function(data) { \treturn { \t\trows: data \t}; };     리턴값 : { rows: {aa: 1, bb: 2 }}    5. 기본 출력 콜백   응답을 _outputs 컬렉션으로 읽어들인 후에 호출되는 콜백입니다. 대상 ‘cbOutput’ 이 ‘cbBaseOutput’ 콜백보다 우선순위가 높습니다. BindCommand 출력옵션에 따라서 data와 ‘_outputs’ 컬렉션에 가져오는 방식이 달라집니다.                  [24. Bind Command Configuration - C# Type of Output Option (output)       Reference: Type of Output Option]           타입 : cbBaseOutput  type cbBaseOutput = (views: MetaViewColleciton, cmd: BindCommand, res: object) =&gt; void;    일반적인 활용방안은     응답받은 output(MetaView)을 사용하여 화면(html) 바인딩에 활용됩니다.   { \t\"rows\": [ \t\t{ \"u_name\": \"Hong Gildong\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Sungchunhyang\", \"gender\", \"W\" }, \t] }   var bm = new BindModel();  bm.cbBaseOutput = function(views) { \t// views[0] instanceof MetaView \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(i, row['u_name'], row['gender']); \t} } // 0 Hong Gil-dong M // 1. Sung Chunhyang W                 views[0] 은 BindCommand 의 ‘output’ 과 동일합니다.                          [[42. Multi-view (output)-C       Reference: Multi-view (output)]           6. 기본 종료시 콜백   execute() 실행시 마지막으로 호출되는 콜백입니다. 대상 ‘cbEnd’ 이 ‘cbBaseEnd’ 콜백보다 우선순위가 높습니다.   타입 : cbBaseEnd  type cbBaseEnd = (status: number, cmd: BindCommand, res: object) =&gt; void;    일반적인 활용방안은     성공 메세지 전달에 활용합니다.   경로 리다이렉트에 활용합니다.   다른 명령의 execute() 체인 연결에 활용합니다.   var bm = new BindModel();  bm.cbBaseEnd = function(views) { \talert('Normal Processed'); };   명령 추가하기   addCommand() 메소드를 호출해서 BindCommand 객체를 생성합니다. BindCommand 객체는 바인드 모델의 처리 단위이며, ‘valid’, ‘bind’, ‘output’ 속성의 MetaView 를 포함하고 있습니다.   타입 : addCommand()  function addCommand(cmdName: string, outOpt?: number = 0, bTable?: string | MetaTable): BindCommand;     ‘cmdName’ 의 BindCommand 의 별칭을 지정하고 출력옵션으로 추가합니다. (기본값 outOpt = 0)   bTable 을 지정하면, 추가한 BindCommand 의 ‘_baseTable’ 이 설정됩니다.   var bm = new BindModel();  bm.addCommand('create'); bm.addCommand('read', 3);  // bm.command['create'] instanceof BindCommand // bm.command['read'] instanceof BindCommand // bm.command['create'].outputOption == 0  // bm.command['read'].outputOption == 3      outOpt 기본값은 ‘0’ 입니다.   추가한 BindCommand 객체는 ‘command’ 컬렉션으로 접근할 수 있습니다.   ‘command’ 는 ‘cmd’ 별칭을 제공합니다.   예제 : 기본테이블 지정  var bm = new BindModel();  bm.addTable('second');  bm.addCommand('list', 1, 'second'); bm.addCommand('edit', 3, bm.second);  // bm.command['list']._baseTable === bm.second // bm.command['edit']._baseTable === bm.second     BindCommand 추가시 MetaTable 을 지정하면 모든 MetaView 는 ‘baseTable’ 이 설정됩니다.   컬럼 추가하기   컬럼을 추가합니다.   타입 : addColumn(), addColumnValue()  type addColumn = ( \tcolName: string,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;  type addColumnValue = ( \tcolName: string,  \tvalue: any,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;     cmds, views을 생략하면 기본테이블에 컬럼이 추가됩니다.   cmds 와 views 을 지정하면 ‘command’ 의 MetaView 에 참조가 등록됩니다.   cmds 파라메터에 ‘$all’ 지시자를 사용하면, 모든 ‘command’ 에 추가됩니다.   컬럼 추가   기본테이블(_baseTable)에 컬럼을 추가합니다.   var bm = new BindModel(); // Add Column bm.addColumn('aa'); bm.addColumnValue('bb', 'man');  // bm.columns['aa'].value  == '' // bm.columns['bb'].value  == 'man' // bm._baseTable === bm._tables['first'] === bm._tables[0] === bm.first     addColumn() 메소드를 호출하여 ‘aa’ 이름의 컬럼이 추가됩니다.   addColumnValue() 메소드를 호출하여 ‘bb’ 이름의 컬럼이 추가되고 ‘man’ 값이 설정됩니다.   ‘bTable’ 을 지정하여 지정된 MetaTable 에 컬럼에 추가할 수 있습니다.  (기본값 : ‘_baseTable’)   컬럼 추가 및 매핑   기본테이블에 컬럼을 추가하고 대상 BindCommand 에 매핑합니다.   var bm = new BindModel(); // command generation  bm.addCommand('cmd1'); bm.addCommand('cmd2'); bm.addCommand('cmd3'); // Add Column bm.addColumn('aa', 'cmd1'); bm.addColumn('bb', ['cmd2', 'cmd3'], ['valid', 'bind']); bm.addColumn('cc', '$all', 'output');  // bm['first'].columns.count  == 3 ('aa', 'bb', 'cc')  // bm.command['cmd1'].valid.columns.count  == 1 ('aa') // bm.command['cmd1'].bind.columns.count   == 1 ('aa') // bm.command['cmd1'].output.columns.count == 2 ('aa', 'cc')  // bm.command['cmd2'].valid.columns.count  == 1 ('bb') // bm.command['cmd2'].bind.columns.count   == 1 ('bb') // bm.command['cmd2'].output.columns.count == 1 ('cc')  // bm.command['cmd3'].valid.columns.count  == 1 ('bb') // bm.command['cmd3'].bind.columns.count   == 1 ('bb') // bm.command['cmd3'].output.columns.count == 1 ('cc')     addCommand() 메소드로 지정한 이름의 BindCommand 를 추가합니다.   ‘aa’ 이름의 컬럼은 지정한(cmd1) 의 모든 MetaView 에 매핑됩니다.   ‘bb’ 이름의 컬럼은 지정한(cmd2, cmd3) 의 MetaView(valid, bind) 에 매핑됩니다.   ‘cc’ 이름의 컬럼은 전체(cmd1, cmd2, cmd3) 의  MetaView(output) 에 매핑됩니다.   추가한 테이블에 컬럼 추가 및 매핑   지정한 MetaTable 에 컬럼을 추가하고 대상 BindCommand 에 매핑합니다.   var bm = new BindModel(); // Adding Tables and Commands bm.addTable('second'); bm.addCommand('cmd1'); // Adding and mapping columns bm.addColumn('aa', 'cmd1', 'valid'); bm.addColumn('bb', 'cmd1', 'bind', 'second');  // bm['first'].columns.count  == 1 ('aa') // bm['second'].columns.count == 1 ('bb')  // bm.command['cmd1'].valid.columns.count  == 1 ('aa') // bm.command['cmd1'].bind.columns.count   == 1 ('bb') // bm.command['cmd1'].output.columns.count == 0     addTable() 메소드로는 MetaTable 을 ‘_tables’ 컬렉션에 추가합니다.   addCommand() 메소드로 지정한 이름의 BindCommand 를 추가합니다.   ‘aa’ 이름의 컬럼은 기본 테이블에 추가하고  지정한 MetaView(valid) 에 매핑됩니다.   ‘bb’ 이름의 컬럼은 second(MetaTable)에 추가하고  지정한 MetaView(bind)에 매핑됩니다.   테이블 추가하기   addTable() 메소드로 MetaTable 을 추가합니다.   타입 : addTable()  type addTable (tableName: string) =&gt; MetaTable;   일반적인 활용방안은     기본테이블을 변경할 활용합니다.   _baseTable 을 변경하기 위한 테이블을 생성할 때 활용합니다.   ‘command’ 의 MetaView 의 참조 테이블로 지정할 때 활용합니다.   var bm = new BindModelAjax(); // step A bm.addTable('second'); bm.addTable('three'); // step B bm._baseTable = bm.second;  // baseTable 설정 bm.addColumn('aa'); // step C bm.addCommand('cmd1', 0, 'three'); bm.command['cmd1'].addColumn('bb');  // bm['first'] === bm._tables['first'] === bm._tables[0] // bm['second'] === bm._tables['second'] // bm['three'] === bm._tables['three']  // bm['first'].columns.count  == 0 // bm['second'].columns.count == 1 ('aa') // bm['three'].columns.count  == 1 ('bb')  // bm.command['cmd1']._baseTable === bm.second  // bm.command['cmd1'].valid.columns.count  == 1 ('bb') // bm.command['cmd1'].bind.columns.count   == 1 ('bb') // bm.command['cmd1'].output.columns.count == 1 ('bb')     A : addTable() 메소드로 MetaTable 이 ‘_tables’ 컬렉션과 BindModel 객체에 추가됩니다.   B : ‘_baseTable’ 을 지정하여 기본테이블을 second(MetaTable)로 변경하였습니다.   C : addCommand() 메소드에서  ‘cmd1’ 의 ‘_baseTable’ 을 ‘three’ 로 지정하였습니다.   전역 아이템 설정하기 (global column)   ‘items’ 는 컬럼의 원시 정보를 가지고 있습니다.   일반적인 활용방안은     BindModel 에 서비스객체를 주입할때 컬럼의 전역정보를 관리하는데 활용합니다.   하나의 컬럼을 여러 테이블에 공유될때 활용합니다.   ‘selector’ 속성으로 DOM 유효성 검사에 활용합니다.   아이템 추가   아이템의 추가하는 방법으로는 items 컬렉션에서 추가하는 방법과, 서비스객체에서 추가할 수 있습니다.   [[25. 서비스 객체 구성-C#아이템 영역 구성하기| 참조 : 서비스객체의 아이템 구성하기]] 타입 : items.add()  type ColumnType = { \tselector: SelectorType, \tgetter: ()=&gt;any, \tsetter: (val)=&gt;any, \tgetFilter: ()=&gt;any, \tsetFilter: (val)=&gt;any, \tdefault: stirng | number | boolean | null, // 기본값 \tvalue: any, \talias: string, \tcaption: string, \tconstraints: ConstrainstType,  // 제약조건 \trequired: boolean | false, // required }; type ValueType = string | number | boolean | ColumnType;  // items.add() type add = (itemName: string, iType: ValueType) =&gt; void;   var bm = new BindModel(); // Add Item bm.items.add('col1', 1); bm.items.add('col2', ''); bm.items.add('col3', { columnName: 'newCol3'}); bm.items.add('col4', {selector: { key:'#ID', type: 'value'}}); // Create as item column bm._readItem();     ‘col1’ 이름의 아이템에 추가하고 {value: 1} 값을 설정합니다.   col2’ 이름의 아이템에  추가하고 {value: ''} 값을 설정합니다.   ‘col3’ 이름의 아이템에 추가하고 {columnName: 'newCol3'} 값을 설정합니다..   ‘col4’ 이름의 아이템에 추가하고 {selector: { key:'#ID', type: 'value'}} 값을 설정합니다.   _readItem() 메소드를 호출하면 아이템이 기본테이블에 컬럼으로 생성됩니다.   아이템 유효성 검사   checkSelector() 메소드로 items 컬렉션의 selector 속성의 DOM 에서 유효한지 검사할 수 있습니다. 타입 : checkSelector()  type checkSelector = ( \tcollection?: PropertyCollection = this.items,  \tisLog: boolean = false ) =&gt; string[];     ‘collection’  파라메터의 기본값은 this.items 의 컬렉션입니다.   ‘collection’ 으로 items, columns, ['테이블명'].columns, valid.columns, bind.columns, output.columns 으로 지정할 수 있습니다.   isLog = true 을 설정하면, 실패한 ‘selector’ 의 ‘key’ 값이 콘솔창에 출력됩니다.   var bm = new BindModel(); // Add Item bm.items.add('item1', {selector: { key:'#user_name', type: 'value'}}); bm.items.add('item2', {selector: { key:'.sub_name', type: 'text'}}); bm.items.add('item3', {selector: { key:'input[name=gender]', type: 'none'}}); // Selector Examination bm.checkSelector(); // Empty Array Check Successful     checkSelector() 메소드는 ‘items’ 의 ‘selector’ 값이 유효한지 검사합니다.   preCheck 콜백함수를 통해서 서비스객체 주입시 DOM 유효성 검사를 자동으로 처리할 수 있습니다.                  [25. Service Object Configuration-C       Reference: Service Object Configuration]           var bm = new BindModel();  bm.columns.add('item1', {selector: { key:'#user_name', type: 'value'}}); bm.columns.add('item2', {selector: { key:'.sub_name', type: 'text'}}); bm.columns.add('item3', {selector: { key:'input[name=gender]', type: 'none'}});  bm.checkSelector (bm.column, true); // List of failed selector objects     DOM 에서 해당 요소가 존재하는지 검사합니다. &lt; ... id=\"user_name\"&gt;, \\&lt; ... class=\"sub_name\"&gt;, \\&lt;input name=\"gender\"... &gt;   셀렉터 조회하기(selector)   ‘items’ 컬렉션의 ‘selector’ 목록을 얻습니다. 타입 : getSelector(  type KeyType = 'none' | 'value' | 'text' | 'html' | 'prop' | 'attr' | 'css'; type SelectorType = { key: string, type: KeyType };  type getSelector = ( \tcollection?: PropertyCollection = this.items ) =&gt; SelectorType[];     ‘collection’ 파라메터의 기본값은 this.items 컬렉션입니다.   var bm = new BindModel();  bm.columns.add('item1', {selector: {key:'#ID1', type: 'value'}}); bm.columns.add('item2', {selector: {key:'#ID2', type: 'text'}});  bm.getSelector(); // [{key:'#ID1', type: 'value'}, {key:'#ID2', type: 'text'}]  ```     지정한 컬렉션의 ‘selector’ 의 목록을 얻을 수 있습니다.   ","url": "http://localhost:4000/ko/docs/bind-model-config/"
  },{
    "title": "Configure BindModel",
    "excerpt":"‘BindModel’ is the core class of the framework, and its main functions include adding commands, adding columns, adding tables, and injecting service objects.   Key Features      Add command: Add ‘Bindcommand’ object.   Add Column: Add ‘HTML Column’ object.   Add Table: Add ‘MetaTable’ object.   Provides basic callback function—Provides a step-by-step basic callback function.   Inject service object: To construct ‘BindModel’ object by injecting service object.   Key Properties      ‘baseConfig’ : the config setting object of the default axios.   ‘url’ : Path to ‘baseConfig.url’.   ‘column’ : A collection that controls ‘HTML Column’.   ‘command’ : This is a collection that controls ‘Bindcommand’ (aka cmd)   ‘fn’ : A collection that controls user functions.   ‘items’ : A collection that controls the items. (Primary properties of the column)   ‘_tables’ : A collection that controls ‘MetaTable’.   ‘_baseTable’: Default table. (‘column’ = _baseTable.column)   Events      ‘onExecute’ : Commonly called when executing execute() for the first time.   ‘onExecuted’ : Commonly called last when executing execute().   Callback (Properties)      ‘cbBaseBegin’ : This is the default pre-start callback function.   ‘cbBaseValid’ : This is the default validation callback function.   ‘cbBaseBind’ : This is the default server request callback function.   ‘cbBaseResult’ : This is the default server response callback function.   ‘cbBaseOutput’ : Default output callback function.   ‘cbBaseEnd’ : This is the callback function before the default termination.     Key Methods       addcommand(): Create ‘Bindcommand’ object.   addTable(): Add ‘MetaTable’ object.   setService(): Construct the ‘BindModel’ object by injecting the service object.   checkSelector(): DOM validation with ‘selector’ object.   getSelector(): Gets the list of ‘selector’ objects.   addColumn(): Add ‘HTMLColumn’ object.   addColumnValue(): Add ‘HTMLColumn’ object and set ‘value’ value.   setMapping(): Map ‘HTMLColumn’ to ‘MetaView’ object in ‘Bindcommand’   init(): Run ‘preRegister’, ‘preCheck’, and ‘preRedy’ callback functions sequentially.   ‘BindModel’ is a multi-purpose framework that provides the flexibility to add and manage a variety of commands, tables, and columns. This document helps you understand the key features of this class and callbacks and use them effectively.   Setting up a server request   Default Request Path   The url attribute sets the default URL path that requests from the server. If you set the url path for the Bindcommand object, the url path for the BindModel is ignored.   var bm = new BindModel();  bm.url  = '/user';   Set dynamic url   If you need to dynamically change the request path according to a specific command, you can easily set up URLs using the callback function of the BindModel object.    var idx = 1;  bm.cbBegin = function(cmd) { \tcmd._model.url = `/user/${idx}`;  };     ‘cmd._model’ refers to the BindModel with Bindcommand.   Default Request Environment Settings (axios)   You can configure the request environment through the default settings in axios for HTTP communication.   var bm = new BindModel(); // Axios Preference Example bm.baseConfig.baseURL = 'https://api.example.com'; bm.baseConfig.timeout = 10000; // 10초 bm.baseConfig.headers.common['Authorization'] = 'Bearer YOUR_TOKEN'; bm.baseConfig.headers.post['Content-Type'] = 'application/json';     baseURL —Set the default URL to be common to all requests.   timeout : Sets the maximum wait time for a request.   headers —Set the default header to use on request; for example, you can set the authentication token or specify the type of content.   Setting up the Run Event   Global event that is called upon execution() of all commands. 타입 : onExecute, onExecuted  type onExecute = (model: BindModel, cmd: BindCommand) =&gt; void;  type onExecuted = (model: BindModel, cmd: BindCommand) =&gt; void;      The ‘onExecute’ event is called for the first time on all exec() runs.   The ‘onExecuted’ event is last called at all exec() runs.   var bm = new BindModel(); bm.addCommand('read'); // Global Event Settings bm.onExecute = () =&gt; {  \tconsole.log('model 에서 onExecute 호출') }; bm.onExecuted = () =&gt; {  \tconsole.log('model 에서 onExecuted 호출') }; // Execute bm.command['read'].execute();  // Output results: // Call onExecute from model // Call onExecuted in model  Handling errors and failures   error handling   Callback called upon all errors and exceptions. Type: cbError  type cbError = (msg: string, status: number, response: object) =&gt; void;   The cbError occurrence time is     Called in case of an axios error or ajax error related to a server request.   Called in case of all errors and exceptions.   var bm = new BindModel();  bm.cbError = function(msg, status, res) {  \tconsole.error('Err: '+ msg);  };     The default value of ‘cbError’ is provided at the time of object creation.     Dealing with Failure       Processes logical failure messages (mainly used in the event of a validation failure) Type: cbFail  type cbFail = (msg: string, valid: MetaView) =&gt; void;   When “cbFail” occurred, the execute() method was executed     Called when the ‘valid(MetaView)’ validation fails.   Called when a false return is made from the ‘cbValid’ / ‘cbBaseValid’ callback function.   var bm = new BindModel();  bm.cbFail = function(msg, valid) {  \tconsole.warn ('Failed. Err:'+ msg);  };     The default value of ‘cbFail’ is provided at the time of object creation.   Flow control (hooking)   When execute(), the callback function can be called sequentially to control the flow.                  [[41. Callback Lifecycle-B       Refer to: Callback Lifecycle]           1. Callback at base start   The first callback to be called upon execution(). Target ‘cbBegin’ has higher priority than callback ‘cbBaseBegin’. Type: cbBase Begin  type cbBaseBegin = (cmd: BindCommand) =&gt; void;   The general application plan is     Utilized for setting common information in url and config.   var bm = new BindModel();  bm.cbBaseBegin = function(cmd) { \tcmd.url = '/member/1'; };  2. Basic Validation Callback   Callback called before validation for ‘valid(MetaView)’ when executing execute(). Destination ‘cbValid’ has higher priority than callback ‘cbBaseValid’. If the return value is false, the callback ‘cbFail’ is called and terminated. Type: cbBaseValid  type cbBaseValid = (valid: MetaView, cmd: BindCommand) =&gt; boolean;   The general application plan is     Used for inspection before requesting a server.   It is used to check the processing results from the user.   var bm = new BindModel();  bm.cbBaseValid = function(view, cmd) {  \treturn view.colums.count &lt;= 0; }; bm.cbBaseValid = function(view, cmd) { \treturn confirm ('Do you want to delete?'); };   3. Default Server Request Callback   Callback called before sending the ‘bind(MetaView)’ column value when executing execute(). Target ‘cbBind’ has higher priority than callback ‘cbBaseBind’.   Type: cbBaseBind  type cbBaseBind = (view: MetaView, cmd: BindCommand, config: object) =&gt; void;   The general application plan is     Used to set the transport type. (encttype)   Utilized for integrated login-related settings.   Used for password encryption.   4. Default Server Response Callback   Callback called after receiving a response from the server when executing execute(). Destination ‘cbResult’ has higher priority than callback ‘cbBaseResult’. 타입 : cbBaseResult  type cbBaseResult = (data: object, cmd: BindCommand, res: object) =&gt; object;   The general application plan is     It is used to change the responded data to a schema in the form of ‘MetaView’.   var bm = new BindModel(); // data = { aa: 1, bb: 2 } bm.cbBaseResult = function(data) { \treturn { \t\trows: data \t}; };     Return value: ‘{aa: 1, bb:2}’   5. Default Output Callback   Callback called after the response is read into the _outputs collection. Destination ‘cbOutput’ has higher priority than callback ‘cbBaseOutput’. Depending on the ‘Bindcommand’ output option, the data and the ‘_outputs’ collection are imported differently.                  [24. Bind Command Configuration - C# Type of Output Option (output)       Reference: Type of Output Option]           타입 : cbBaseOutput  type cbBaseOutput = (views: MetaViewColleciton, cmd: BindCommand, res: object) =&gt; void;    The general application plan is     It is utilized for screen (html) binding using the ‘output(MetaView)’ responded.   { \t\"rows\": [ \t\t{ \"u_name\": \"Hong Gildong\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Sungchunhyang\", \"gender\", \"W\" }, \t] }   var bm = new BindModel();  bm.cbBaseOutput = function(views) { \t// views[0] instanceof MetaView \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(i, row['u_name'], row['gender']); \t} } // 0 Hong Gil-dong M // 1. Sung Chunhyang W   [[42. Multi-view (output)-C | Reference: Multi-view (output)]  6. Callback at Default Termination   The last callback to be called when execute(). Target ‘cbEnd’ has higher priority than callback ‘cbBaseEnd’.   Type: cbBaseEnd  type cbBaseEnd = (status: number, cmd: BindCommand, res: object) =&gt; void;    The general application plan is     Use it to deliver success messages.   Utilizes for path redirection.   Use to link the execute() chain of other commands.   var bm = new BindModel();  bm.cbBaseEnd = function(views) { \talert('Normal Processed'); };   To add a command   Create a ‘Bindcommand’ object by invoking the addcommand() method. The ‘Bindcommand’ object is the processing unit of the bound model and contains the ‘MetaView’ of the ‘valid’, ‘bind’, and ‘output’ attributes.   Type: addcommand()  function addCommand(cmdName: string, outOpt?: number = 0, bTable?: string | MetaTable): BindCommand;     Specify the alias for ‘Bindcommand’ of ‘cmdName’ and add it as an output option. (Default outOpt = 0)   If bTable is specified, ‘_baseTable’ of the added ‘Bindcommand’ is set.   var bm = new BindModel();  bm.addCommand('create'); bm.addCommand('read', 3);  // bm.command['create'] instanceof BindCommand // bm.command['read'] instanceof BindCommand // bm.command['create'].outputOption == 0  // bm.command['read'].outputOption == 3      The default value for outOpt is ‘0’.   The ‘Bindcommand’ object you added can be accessed by the ‘command’ collection.   ‘command’ provides a ‘cmd’ alias.   Example: Specify the Default Table  var bm = new BindModel();  bm.addTable('second');  bm.addCommand('list', 1, 'second'); bm.addCommand('edit', 3, bm.second);  // bm.command['list']._baseTable === bm.second // bm.command['edit']._baseTable === bm.second     If ‘MetaTable’ is specified when ‘Bind Command’ is added, ‘baseTable’ is set for all ‘MetaView’.   To add a column   Add a column.   타입 : addColumn(), addColumnValue()  type addColumn = ( \tcolName: string,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;  type addColumnValue = ( \tcolName: string,  \tvalue: any,  \tcmds?: string | string[],  \tviews?: string | string[],  \tbTable?: string | MetaTable ) =&gt; BindCommand;     omitting cmds, views adds columns to the base table.   If you specify cmds and views, the reference is registered in MetaView in ‘command’.   If you use the ‘$all’ indicator in the cmds parameter, it is added to all ‘command’.   ‘views[0]’ is the same as ‘output’ of ‘Bindcommand’.   Add Column   Add a column to the main table (_baseTable).   var bm = new BindModel(); // Add Column bm.addColumn('aa'); bm.addColumnValue('bb', 'man');  // bm.columns['aa'].value  == '' // bm.columns['bb'].value  == 'man' // bm._baseTable === bm._tables['first'] === bm._tables[0] === bm.first     A column named ‘aaa’ is added by invoking the addColumn() method.   The addColumnValue() method is called to add a column named ‘bbb’ and the value ‘man’ is set.   You can add ‘bTable’ to the specified ‘MetaTable’ column. (Default: ‘_baseTable’)     Adding and mapping columns       Add a column to the base table and map it to the target ‘Bindcommand’.   var bm = new BindModel(); // command generation  bm.addCommand('cmd1'); bm.addCommand('cmd2'); bm.addCommand('cmd3'); // Add Column bm.addColumn('aa', 'cmd1'); bm.addColumn('bb', ['cmd2', 'cmd3'], ['valid', 'bind']); bm.addColumn('cc', '$all', 'output');  // bm['first'].columns.count  == 3 ('aa', 'bb', 'cc')  // bm.command['cmd1'].valid.columns.count  == 1 ('aa') // bm.command['cmd1'].bind.columns.count   == 1 ('aa') // bm.command['cmd1'].output.columns.count == 2 ('aa', 'cc')  // bm.command['cmd2'].valid.columns.count  == 1 ('bb') // bm.command['cmd2'].bind.columns.count   == 1 ('bb') // bm.command['cmd2'].output.columns.count == 1 ('cc')  // bm.command['cmd3'].valid.columns.count  == 1 ('bb') // bm.command['cmd3'].bind.columns.count   == 1 ('bb') // bm.command['cmd3'].output.columns.count == 1 ('cc')     Add ‘Bindcommand’ with the name specified by the addcommand() method.   The column named ‘aaa’ is mapped to all ‘MetaView’ in the specified (cmd1).   The column named ‘bbb’ maps to the specified (cmd2, cmd3) ‘MetaView (valid, bind’   Columns named ‘cc’ are mapped to the ‘MetaView (output)’ of the whole (cmd1, cmd2, cmd3).   Adding and mapping columns to tables you have added   Add a column to the specified ‘MetaTable’ and map it to the target ‘Bind Command’.   var bm = new BindModel(); // Adding Tables and Commands bm.addTable('second'); bm.addCommand('cmd1'); // Adding and mapping columns bm.addColumn('aa', 'cmd1', 'valid'); bm.addColumn('bb', 'cmd1', 'bind', 'second');  // bm['first'].columns.count  == 1 ('aa') // bm['second'].columns.count == 1 ('bb')  // bm.command['cmd1'].valid.columns.count  == 1 ('aa') // bm.command['cmd1'].bind.columns.count   == 1 ('bb') // bm.command['cmd1'].output.columns.count == 0     As an addTable() method, add ‘MetaTable’ to the ‘_tables’ collection.   Add ‘Bindcommand’ with the name specified by the addcommand() method.   Columns named ‘aaa’ are added to the base table and mapped to the specified ‘MetaView (valid).   The column named ‘bbb’ is added to ‘second(MetaTable)’ and mapped to the specified ‘MetaView(bind).     Add Column       Add a column to the main table (_baseTable).   var bm = new BindModel(); // Add Column bm.addColumn('aa'); bm.addColumnValue('bb', 'man');  // bm.columns['aa'].value  == '' // bm.columns['bb'].value  == 'man' // bm._baseTable === bm._tables['first'] === bm._tables[0] === bm.first     A column named ‘aaa’ is added by invoking the addColumn() method.   The addColumnValue() method is called to add a column named ‘bbb’ and the value ‘man’ is set.   You can add ‘bTable’ to the specified ‘MetaTable’ column. (Default: ‘_baseTable’)     Adding and mapping columns       Add a column to the base table and map it to the target ‘Bindcommand’.   var bm = new BindModel(); // command generation  bm.addCommand('cmd1'); bm.addCommand('cmd2'); bm.addCommand('cmd3'); // Add Column bm.addColumn('aa', 'cmd1'); bm.addColumn('bb', ['cmd2', 'cmd3'], ['valid', 'bind']); bm.addColumn('cc', '$all', 'output');  // bm['first'].columns.count  == 3 ('aa', 'bb', 'cc')  // bm.command['cmd1'].valid.columns.count  == 1 ('aa') // bm.command['cmd1'].bind.columns.count   == 1 ('aa') // bm.command['cmd1'].output.columns.count == 2 ('aa', 'cc')  // bm.command['cmd2'].valid.columns.count  == 1 ('bb') // bm.command['cmd2'].bind.columns.count   == 1 ('bb') // bm.command['cmd2'].output.columns.count == 1 ('cc')  // bm.command['cmd3'].valid.columns.count  == 1 ('bb') // bm.command['cmd3'].bind.columns.count   == 1 ('bb') // bm.command['cmd3'].output.columns.count == 1 ('cc')     Add ‘Bindcommand’ with the name specified by the addcommand() method.   The column named ‘aaa’ is mapped to all ‘MetaView’ in the specified (cmd1).   The column named ‘bbb’ maps to the specified (cmd2, cmd3) ‘MetaView (valid, bind’   Columns named ‘cc’ are mapped to the ‘MetaView (output)’ of the whole (cmd1, cmd2, cmd3).   Adding and mapping columns to tables you have added   Add a column to the specified ‘MetaTable’ and map it to the target ‘Bind Command’.   var bm = new BindModel(); // Adding Tables and Commands bm.addTable('second'); bm.addCommand('cmd1'); // Adding and mapping columns bm.addColumn('aa', 'cmd1', 'valid'); bm.addColumn('bb', 'cmd1', 'bind', 'second');  // bm['first'].columns.count  == 1 ('aa') // bm['second'].columns.count == 1 ('bb')  // bm.command['cmd1'].valid.columns.count  == 1 ('aa') // bm.command['cmd1'].bind.columns.count   == 1 ('bb') // bm.command['cmd1'].output.columns.count == 0     As an addTable() method, add ‘MetaTable’ to the ‘_tables’ collection.   Add ‘Bindcommand’ with the name specified by the addcommand() method.   Columns named ‘aa’ are added to the base table and mapped to the specified ‘MetaView (valid).   The column named ‘bb’ is added to ‘second(MetaTable)’ and mapped to the specified ‘MetaView(bind).   To add a table   Add ‘MetaTable’ as an addTable() method.   Type: addTable()  type addTable (tableName: string) =&gt; MetaTable;   The general application plan is     Utilizes changes to the default table.   Use to create tables to change _baseTable.   Use when designating as a reference table for ‘MetaView’ in ‘command’.   var bm = new BindModel(); // step A bm.addTable('second'); bm.addTable('three'); // step B bm._baseTable = bm.second;  // baseTable 설정 bm.addColumn('aa'); // step C bm.addCommand('cmd1', 0, 'three'); bm.command['cmd1'].addColumn('bb');  // bm['first'] === bm._tables['first'] === bm._tables[0] // bm['second'] === bm._tables['second'] // bm['three'] === bm._tables['three']  // bm['first'].columns.count  == 0 // bm['second'].columns.count == 1 ('aa') // bm['three'].columns.count  == 1 ('bb')  // bm.command['cmd1']._baseTable === bm.second  // bm.command['cmd1'].valid.columns.count  == 1 ('bb') // bm.command['cmd1'].bind.columns.count   == 1 ('bb') // bm.command['cmd1'].output.columns.count == 1 ('bb')     A: ‘MetaTable’ is added to the ‘_tables’ collection and ‘BindModel’ objects in the addTable() method.   B: We changed the base table to ‘second(MetaTable)’ by specifying ‘_baseTable’.   C: The addcommand() method designated ‘_baseTable’ of ‘cmd1’ as ‘three’.   Setting global items (global column)   ‘items’ has raw information from the column.   The general application plan is     When injecting service objects into ‘BindModel’, it is used to manage the global information of the column.   Utilizes a column when it is shared across multiple tables.   It is a ‘selector’ attribute and is used for DOM validation.   Add Item   As a way to add items, you can add them from the items collection and from the service object.   [25. Service Object Configuration - C# Item Area Configuration | Refer to: Service Object Configuration] Type: items.add()  type ColumnType = { \tselector: SelectorType, \tgetter: ()=&gt;any, \tsetter: (val)=&gt;any, \tgetFilter: ()=&gt;any, \tsetFilter: (val)=&gt;any, \tdefault: stirng | number | boolean | null, // 기본값 \tvalue: any, \talias: string, \tcaption: string, \tconstraints: ConstrainstType,  // 제약조건 \trequired: boolean | false, // required }; type ValueType = string | number | boolean | ColumnType;  // items.add() type add = (itemName: string, iType: ValueType) =&gt; void;   var bm = new BindModel(); // Add Item bm.items.add('col1', 1); bm.items.add('col2', ''); bm.items.add('col3', { columnName: 'newCol3'}); bm.items.add('col4', {selector: { key:'#ID', type: 'value'}}); // Create as item column bm._readItem();     Add to the item named ‘col1’ and set the value ‘{value:1}’.   Add to the item named ‘col2’ and set the value ‘{value: ‘}’.   Add to the item named ‘col3’ and set the value ‘{columnName: ‘newCol3’}..   Add to the item named ‘col4’ and set the value ‘{selector: {key:’#ID’, type: ‘value’}’   Calling the _readItem() method creates an item as a column in the default table.   Item Validation   The checkSelector() method allows you to check whether the DOM of the selector property in the items collection is valid. 타입 : checkSelector()  type checkSelector = ( \tcollection?: PropertyCollection = this.items,  \tisLog: boolean = false ) =&gt; string[];     The default value of the ‘collection’ parameter is the collection of ‘this.items’.   ‘collection’ can be designated as items, columns, ‘[table name]’.column, ‘valid.column’, ‘bind.column’, and ‘output.column’.   If you set isLog = true, the ‘key’ value of the failed ‘selector’ is displayed in the console window.   var bm = new BindModel(); // Add Item bm.items.add('item1', {selector: { key:'#user_name', type: 'value'}}); bm.items.add('item2', {selector: { key:'.sub_name', type: 'text'}}); bm.items.add('item3', {selector: { key:'input[name=gender]', type: 'none'}}); // Selector Examination bm.checkSelector(); // Empty Array Check Successful     The checkSelector() method checks whether the ‘selector’ value of ‘items’ is valid.   The preCheck callback function automatically handles DOM validation when injecting service objects. [25. Service Object Configuration-C | Reference: Service Object Configuration]   var bm = new BindModel();  bm.columns.add('item1', {selector: { key:'#user_name', type: 'value'}}); bm.columns.add('item2', {selector: { key:'.sub_name', type: 'text'}}); bm.columns.add('item3', {selector: { key:'input[name=gender]', type: 'none'}});  bm.checkSelector (bm.column, true); // List of failed selector objects     Examine the DOM for the presence of the element. &lt; ... id=\"user_name\"&gt;, \\&lt; ... class=\"sub_name\"&gt;, \\&lt;input name=\"gender\"... &gt;   To look up the selector (selector)   Obtain a list of ‘selectors’ in the ‘items’ collection. Type: getSelector()  type KeyType = 'none' | 'value' | 'text' | 'html' | 'prop' | 'attr' | 'css'; type SelectorType = { key: string, type: KeyType };  type getSelector = ( \tcollection?: PropertyCollection = this.items ) =&gt; SelectorType[];     The default for the ‘collection’ parameter is this.items collection.   var bm = new BindModel();  bm.columns.add('item1', {selector: {key:'#ID1', type: 'value'}}); bm.columns.add('item2', {selector: {key:'#ID2', type: 'text'}});  bm.getSelector(); // [{key:'#ID1', type: 'value'}, {key:'#ID2', type: 'text'}]     You can obtain a list of ‘selectors’ for the specified collection.   ","url": "http://localhost:4000/en/docs/bind-model-config/"
  },{
    "title": "Callback Lifecycle",
    "excerpt":"execute() Lifecycle         The ‘onExecute’ event is the first event to be called when the execute() method is executed.   ‘cbBegin’ callback is called for the first time; it is used to set the initial value.   Callback ‘cbValid’ is called before validation for validation of valid (MetaView).  Utilization: Use for confirm() before deletion, user validation   Validates columns of validation (MetaView).column.valid(value)   The cbFail callback handles logical failures.   ‘cbBind’ callback controls the http transfer style for special processing (image, integrated login)   bind (MetaView) requests bind.columns from the http server.   The ‘cbResult’ callback is used for processing response results.   Binds data and values to output (MetaView) according to outputOptions.   The ‘cbOutput’ callback performs output-related processing, such as html, as a response result or output.   Callback ‘cbError’ is called when an error or exception occurs after cbBind.   Callback ‘cbEnd’ is called last. Utilization: redirect, success message, other command.example() chain connection   The ‘onExecuted’ event is the last event called when the execute() method is executed.  ","url": "http://localhost:4000/en/docs/callback-lifecycle/"
  },{
    "title": "콜백 라이프사이클",
    "excerpt":"execute() Lifecycle         onExecute 이벤트는 execute() 메소드 실행시 처음으로 호출되는 이벤트입니다.   cbBegin 콜백은 처음으로 호출됩니다. 초기값 설정하는데 활용됩니다.   cbValid 콜백은 valid(MetaView) 에 대한 유효성 검사전에 호출합니다.  활용 : 삭제전 confirm() 에 활용, 사용자 유효성 검사   valid(MetaView)의 columns 의 유효성 검사를 합니다. column.valid(value)   cbFail 콜백은 논리적인 실패를 처리합니다.   cbBind 콜백은 http 전송 스타일을 제어하여 특별한 처리에 활용합니다. (이미지, 통합로그인)   bind(MetaView)은 bind.columns 을 http 서버에 요청합니다.   cbResult 콜백은 response 결과에 대한 가공에 활용합니다.   outputOption 에 따라서 output(MetaView)에 데이터 및 값을 바인딩 합니다.   cbOutput 콜백은 response 결과 또는 output 으로 html 과 같이 출력 관련된 처리를 합니다.   cbError 콜백은 cbBind 이후의 오류 또는 예외 발생시 호출합니다.   cbEnd 콜백은 마지막에 호출합니다. 활용 : 리다렉트, 성공 메세지, 다른 command.exetue() 체인 연결   onExecuted 이벤트는 execute() 메소드 실행시 마지막으로 호출되는 이벤트입니다.  ","url": "http://localhost:4000/ko/docs/callback-lifecycle/"
  },{
    "title": "핵심 개념",
    "excerpt":"BindModel의 핵심은 MetaTable과 MetaView의 조합으로 이루어져 있습니다. 이 두 가지 요소는 BindModel의 기능을 구성하는 중요한 기반이며, 실 프로젝트에서 중복을 최소화하고 다양한 사례를 수용할 수 있도록 설계되었습니다.   MetaTable 클래스   MetaTable 클래스는 데이터를 테이블 형식으로 쉽게 표현하고 다양한 기능을 제공합니다. 이 클래스는 .NET의 DataTable과 유사한 기능을 제공하여, .NET 경험자들이 익숙하게 사용할 수 있습니다. MetaTable은 컬럼과 행을 관리하는 두 가지 주요 속성(columns와 rows)을 통해 데이터를 효율적으로 처리할 수 있습니다.                  [55. MetaTable Class-B       - Reference: MetaTable Class]           MetaTable.columns 속성 (컬렉션)   MetaTable 의 ‘columns’ 컬렉션은 컬럼(MetaColumn)의 추가/제거의 기능을 제공합니다. 이 컬렉션은 테이블 구조를 정의하며, 각 컬럼은 고유한 키(컬럼명)와 인덱스를 가집니다. 이를 통해 컬럼에 대한 접근을 쉽게 할 수 있습니다.   var table1 = new MetaTabe('t1');  table1.columns.add('age'); table1.columns.add('gender');  // Access to a column // table1.columns['age'] === table1.columns[0] // table1.columns['gender'] === table1.columns[1] // table1.colmmns.count === 2  제약조건  MetaTable에 MetaRow가 rows 컬렉션에 추가된 이후에는 columns 컬렉션에 컬럼을 추가하거나 제거할 수 없습니다. 이는 데이터의 일관성을 유지하기 위한 제약입니다. 컬럼 정의는 데이터를 삽입하기 전에 완료되어야 합니다.   MetaTable.rows 속성 (컬렉션)   MetaTable의 rows 속성은 데이터(MetaRow)를 추가하거나 제거할 수 있는 컬렉션입니다. 새로운 행은 newRow() 메서드를 통해 생성되며, 생성된 MetaRow 객체는 rows 컬렉션에 추가될 수 있습니다.   var table1 = new MetaTabe('t1'); var row = table1.newRow();  row['age'] = 20; row['gender'] = 'man';  table1.rows.add(row);  // Access to data // row.count == 2 // table1.rows[0]['age'] == 20 // table1.rows[0]['gender'] == 'man' // table1.rows.count == 1     rows 컬렉션에 추가된 MetaRow는 연속된 인덱스를 제공합니다.   MetaView 클래스   MetaView 클래스는 MetaTable과 유사한 역할을 수행하지만, 중요한 차이점은 MetaView의 columns 컬렉션에 컬럼(MetaColumn)을 직접 추가하는 대신, 참조값을 통해 추가할 수 있다는 점입니다. 이는 MetaView가 기존 데이터 구조를 기반으로 다양한 뷰(View)를 정의하고 활용할 수 있습니다.                  [56. MetaView Class-B       Reference       -Reference: MetaView Class]           전체 컬럼을 참조 컬럼으로 등록   MetaView의 _baseEntity 속성을 설정한 후, MetaView에 컬럼을 추가하면 해당 컬럼은 _baseEntity에 실제로 추가되고, MetaView에는 참조값만 등록됩니다. 이 방식은 기존 테이블(MetaTable)의 구조를 그대로 활용하면서도 별도의 뷰를 정의하고 사용할 수 있게 합니다.   var table1 = new MetaTabe('t1'); var view1 = new MetaView('v1', table1);  view1.columns.add('age'); view1.columns.add('gender');  // table1.colmmns.count === 2 // view1.colmmns.count === 2 // view1.columns['age'] === table1.columns['age'] // view1.columns['gender'] === table1.columns['gender']     컬럼 추가시 기존 컬럼명의 컬렉션이 존재하면, 참조값을 등록합니다.   개별 컬럼을 참조 컬럼으로 등록   MetaView는 특정 컬럼만 _baseEntity에 참조값으로 등록할 수 있습니다. 이는 MetaView가 필요한 특정 데이터만 선택적으로 참조하여 사용할 수 있도록 해줍니다.   var table1 = new MetaTabe('t1'); var view1 = new MetaView('v1');  view1.columns.add('age'); view1.columns.add('gender', table1);  // table1.colmmns.count === 1 // view1.colmmns.count === 2 // view1.columns['gender'] === table1.columns['gender']     ‘_baseEntity’ 대상이 MetaView 일 경우 순환규칙을 따르게됩니다.   HTMLColumn 클래스   HTMLColumn은 MetaColumn의 자식 클래스이며, HTML 요소와 데이터를 연동하는 기능을 제공합니다. 특히 value 속성을 통해 컬럼의 현재 값을 관리할 수 있으며, 다양한 프로퍼티를 통해 값의 설정과 조회를 유연하게 제어할 수 있습니다. HTMLColumn의 주요 프로퍼티로는 selector, setter/getter, setFilter/getFilter 등이 있습니다.                  [54. HTML Column Class-B       - Reference: Column Configuration]           MetaRow 로 컬럼 value 값 설정하기   setValue() 메서드를 사용하여 MetaRow 객체로부터 데이터를 가져와 컬럼의 value 값에 설정할 수 있습니다.   var table1 = new MetaTabe('t1'); var row = table1.newRow();  row['age'] = 30; row['gender'] = 'man';  tables.setValue(row);  // table1.columns['age'].value == 30 // table1.columns['gender'].value == 'man'   컬럼의 value 값을 MetaRow 로 가져오기   getValue() 메서드를 사용하여 컬럼의 value 값을 MetaRow 타입으로 반환받을 수 있습니다.   var table1 = new MetaTabe('t1');  table1.columns['age'].value = 40; table1.columns['gender'].value = 'man';  var row = tables.getValue();  // row['age'].value == 40 // row['gender'].value == 'man'   컬럼의 value 값 조회하기   HTMLColumn의 value 값을 조회할 때, 설정된 우선순위에 따라 하나의 값이 선택되어 반환됩니다.   우선순위     getter 리턴값 : getter가 설정되어 있다면, 이 값이 최우선으로 반환됩니다.   getFillter 리턴값 : getFilter가 설정되어 있다면, selector 값이 매개변수로 전달되며 가공된 값이 반환됩니다.   selector 조회값 :  selector에 설정된 타입(text, value, attr, prop, html)에 따라 값이 반환됩니다.   내부값 : getter, getFilter, selector 설정이 없을 경우, 내부에 저장된 값이 반환됩니다.   default 값 : 위의 설정이 모두 없으며 초기값이 Empty일 경우, 기본값이 반환됩니다.  (초기값은 null 또는 빈 문자열)                  [54. HTML Column Class-B#getter Internal Structure       - Reference: getter Internal Structure]           예제 : getter 설정 시  column.getter = function(sVal) { \treturn 'user value'; };  // column.value == 'user value'   Example: When setting up getFilter  column.getFilter = function(sVal) { \treturn $('input[name=type_cd]:checked').val(); // Blue };  // column.value == 'Blue'  예제 : getFilter 설정 시  column.selector = { key: '#u_name', type: 'value' }; // Cat column.getFilter = function(sVal) { \treturn $('input[name=type_cd]:checked').val() +'-'+ sVal; // Blue };  // column.value == 'Blue-Cat'     selector 의 값이 getFilter 에 전달되고, getFilter 에서 가공 후 전달 됩니다.   예제 : selector 설정 시  column.selector = { key: '#u_name', type: 'value' };   참조  getter 와 getFilter 는 비슷한 역할을 하지만, 차이점이 있습니다. getter 는 단일 설정값을 반환하는 데 사용되며, getFilter 는 내부 값(원시값)을 기반으로 여러 HTMLElement 의 값을 설정하거나 가공하는 역할을 합니다.   컬럼의 value 값 설정   HTMLColumn의 value 값을 설정할 때, 설정된 순서에 따라 값을 저장하고 전달합니다. 설정 순서는 다음과 같습니다.   설정 순서     setter : 설정하려는 값이 첫 번째로 저장됩니다.   내부 : setter가 반환값을 가지면 그 값을 저장하고, 반환값이 없으면 설정값을 내부에 저장합니다.   setFilter : 내부값을 매개변수로 전달하여 값을 설정합니다.   selector : setFilter의 반환값이 있으면 그 값을 설정하고, 반환값이 없으면 내부값을 설정합니다.                  [54. HTML Column Class-B#setter Internal Structure       - Reference: setter Internal Structure]           예제 : setter 만 설정 시  var temp;  column.setter = function(val) { \ttemp = val; };  column.value = 'user value'; // temp == 'user value' // column.$value == 'user value'  예제 : setter 와 setFilter 설정 시  var temp;  column.setter = function(val) { \ttemp = val * 10; }; column.setFilter = function(val) { \t$('input[name=active_yn][value='+ val + ']').prop('checked', true); };  column.value = 2; // temp == 20 // &lt;input type=\"checkbox\" name=\"action_yn\" value=\"2\"/&gt; // column.$value == 2     setFilter 의 매개변수는 setter 가 반환값이 전달하고, 반환값이 없으면 내부값을 전달합니다.   예제 : setter 와 selector 설정 시  column.setter = function(val) { \treturn temp = val * 10; }; column.selector = { key: '#u_name', type: 'value' }; // Cat  column.value = 2; // temp == 20 // &lt;input type=\"text\" name=\"u_name\" value=\"20\"/&gt; // column.$value == 20     setter 리턴값을 반환값으로 내부값에 저장됩니다.   selector 의 값은 내부값이 설정됩니다.   예제 : selector 만 설정 시  column.selector = { key: '#u_name', type: 'value' };  column.value = 2; // &lt;input type=\"text\" name=\"u_name\" value=\"2\"/&gt; // column.$value == 2   참조  setter 와 setFilter 는 비슷한 역할을 하지만, 차이가 있습니다. setter는 단일 값을 설정하는 데 사용되고, setFilter는 내부 값(원시값)을 기반으로 여러 HTMLElement의 값을 설정하거나 가공하는 역할을 합니다. 예를 들어, 통화 단위를 표현할 때, 내부 값이 1000 이라면 화면에는 ‘1,000’으로 출력하는 식입니다.   BindModel 구조의 이해   BindModel 은 하나의 MetaTable(이름: first)을 자동으로 생성하며, 이 구조 내에서 추가된 각 BindCommand 객체는 세 개의 MetaView(valid, bind, output)를 포함합니다.                  [[52. BindModel class-B#Main structure       - Reference: BindModel’s main structure]                 [53. Bind Command Class-B#Main Structure       - Reference: BindComand Main Structure]           BindModel 의 엔티티의 구조 요약   다음은 BindModel의 내부 엔티티 구조(MetaTable, MetaView)를 요약한 코드입니다:   function createCommand(baseTable) { \treturn { \t\tvalid: new MetaView('valid', baseTable), \t\tbind: new MetaView('bind', baseTable), \t\toutput: new MetaView('output', baseTable) \t}; }  var table1 = new MetaTabe('first'); var cmd1 = createCommand(table1);  cmd1.bind.columns.add('aa'); cmd1.output.columns.add('bb');  // table1.colmmns.count === 2 ('aa','bb') // table1.columns['aa'] === view2.columns['aa'] // table1.columns['bb'] === view3.columns['bb']  // view1.colmmns.count === 0 // view2.colmmns.count === 1 ('aa') // view3.colmmns.count === 1 ('bb')     MetaView 에 컬럼을 추가하면, 해당 컬럼은 MetaView의_baseEntity로 지정된 MetaTable에 추가됩니다. 이때 MetaView에는 컬럼의 참조만 등록됩니다.   MetaTable 에 직접 컬럼을 추가하면, 해당 컬럼은 독립적으로 추가됩니다. MetaView와는 달리 다른 뷰에서 참조하지 않습니다.   BindModel을 생성하면, 기본적으로 first라는 이름의 MetaTable이 자동으로 생성됩니다. 각 BindCommand 객체는 자동으로 valid, bind, output이라는 이름의 MetaView를 포함합니다.   BindModelAjax에서 execute() 메소드를 실행하면, MetaTable과 MetaView의 구조에 따라 컬럼과 데이터가 설정됩니다. 이 과정을 통해 다양한 사용자 요구사항에 맞게 커스터마이징할 수 있습니다.  ","url": "http://localhost:4000/ko/docs/core/"
  },{
    "title": "Core concept",
    "excerpt":"The core of BindModel is a combination of MetaTable and MetaView, which are important components of BindModel’s functionality and are designed to minimize duplication and accommodate different cases in real-world projects.   MetaTable Class   The MetaTable class easily represents data in a table format and provides a variety of features. The class offers features similar to DataTable in .NET, which is familiar to .NET experiences. MetaTable has two main attributes (columns and rows) that manage columns and rows to efficiently process data.                  [55. MetaTable Class-B       - Reference: MetaTable Class]           MetaTable.column property (collection)   The ‘column’ collection of ‘MetaTable’ provides additional/removal of columns. This collection defines the table structure, and each column has its own key (column name) and index. This allows easy access to the column.   var table1 = new MetaTabe('t1');  table1.columns.add('age'); table1.columns.add('gender');  // Access to a column // table1.columns['age'] === table1.columns[0] // table1.columns['gender'] === table1.columns[1] // table1.colmmns.count === 2   Constraints  You cannot add or remove columns from the columns collection after MetaRow has been added to the rows collection in MetaTable. This is a constraint to maintain data consistency. The column definition must be completed before data can be inserted.   MetaTable.rows Properties (Collection)   Therows property of MetaTable is a collection that allows you to add or remove data (MetaRow). New rows are created through the newRow() method, and the created MetaRow objects can be added to therows collection.   var table1 = new MetaTabe('t1'); var row = table1.newRow();  row['age'] = 20; row['gender'] = 'man';  table1.rows.add(row);  // Access to data // row.count == 2 // table1.rows[0]['age'] == 20 // table1.rows[0]['gender'] == 'man' // table1.rows.count == 1     MetaRow, added to the rows collection, provides a continuous index.   MetaView Class   The MetaView class performs a similar role to MetaTable, but an important difference is that, instead of adding columns directly to MetaView’s columns collection, you can add them through references. This allows MetaView to define and leverage different views based on existing data structures.                  [56. MetaView Class-B       Reference       -Reference: MetaView Class]           Register a full column as a reference column   Once you have set the _baseEntity property for MetaView, the column is actually added to _baseEntity and only the reference value is registered for MetaView, which allows you to define and use separate views while still taking advantage of the structure of the existing table.   var table1 = new MetaTabe('t1'); var view1 = new MetaView('v1', table1);  view1.columns.add('age'); view1.columns.add('gender');  // table1.colmmns.count === 2 // view1.colmmns.count === 2 // view1.columns['age'] === table1.columns['age'] // view1.columns['gender'] === table1.columns['gender']     If a collection of existing column names exists when adding columns, register the reference value.   Register an individual column as a reference column   MetaView can register only certain columns as reference values in _baseEntity, which allows MetaView to selectively reference and use only certain data that is required.   var table1 = new MetaTabe('t1'); var view1 = new MetaView('v1');  view1.columns.add('age'); view1.columns.add('gender', table1);  // table1.colmmns.count === 1 // view1.colmmns.count === 2 // view1.columns['gender'] === table1.columns['gender']     If the target ‘_baseEntity’ is ‘MetaView’, it follows the cycle rule.   HTML Column Classes   HTMLColumn is a child class of MetaColumn that provides the ability to associate HTML elements with data. In particular, the value attribute allows you to manage the current value of the column, and various properties allow you to flexibly control the setting and query of values. HTMLColumn’s main properties include selector, setter/getter, and setFilter/getFilter.                  [54. HTML Column Class-B       - Reference: Column Configuration]           Set column value in MetaRow   You can use the setValue() method to import data from the MetaRow object and set it to the value in the column.   var table1 = new MetaTabe('t1'); var row = table1.newRow();  row['age'] = 30; row['gender'] = 'man';  tables.setValue(row);  // table1.columns['age'].value == 30 // table1.columns['gender'].value == 'man'   Import value of column to MetaRow   You can use the getValue() method to return the value value of the column to the MetaRow type.   var table1 = new MetaTabe('t1');  table1.columns['age'].value = 40; table1.columns['gender'].value = 'man';  var row = tables.getValue();  // row['age'].value == 40 // row['gender'].value == 'man'   Inquire the value of a column   When querying HTML Column’s value value, one value is selected and returned according to the set priority.   Priorities     getter return value: If getter is set, this value is returned to the highest priority.   getFilter return value: If getFilter is set, the selector value is passed to the parameter and the processed value is returned.   selector lookup value: The value is returned depending on the type set in the selector (text, value, attr, prop, html).   Internal value: If there are no getter, getFilter, or selector settings, the values stored inside will be returned.   default value: If none of the above settings are present and the initial value is Empty, the default is returned.  (Initial value is null or empty string)                  [54. HTML Column Class-B#getter Internal Structure       - Reference: getter Internal Structure]           Example: When setting getter  column.getter = function(sVal) { \treturn 'user value'; };  // column.value == 'user value'   Example: When setting up getFilter  column.getFilter = function(sVal) { \treturn $('input[name=type_cd]:checked').val(); // Blue };  // column.value == 'Blue'   Example: When setting up getFilter and selector  column.selector = { key: '#u_name', type: 'value' }; // Cat column.getFilter = function(sVal) { \treturn $('input[name=type_cd]:checked').val() +'-'+ sVal; // Blue };  // column.value == 'Blue-Cat'     The value of the selector is transmitted to the getFilter, and it is transmitted after processing in the getFilter.   Example: When setting up selector  column.selector = { key: '#u_name', type: 'value' };   Refer to  getter and getFilter play similar roles, but there is a difference. getter is used to return a single set, and getFilter is responsible for setting or processing values for several HTML elements based on internal values (original values).   Set value for column   When setting the value of HTML Column, save and pass the value in the order set. The setup procedure is as follows.   Setting Order     setter: The value you want to set is saved first.   Internal: If the setter has a return value, save the set value, and if there is no return value, store the set value internally.   setFilter: Set the value by passing the internal value as a parameter.   selector: Set the setFilter return value if there is no return value, and set the internal value if there is no return value.                  [54. HTML Column Class-B#setter Internal Structure       - Reference: setter Internal Structure]           Example: When setting only the setter  var temp;  column.setter = function(val) { \ttemp = val; };  column.value = 'user value'; // temp == 'user value' // column.$value == 'user value'   Example: Set up setter and setFilter  var temp;  column.setter = function(val) { \ttemp = val * 10; }; column.setFilter = function(val) { \t$('input[name=active_yn][value='+ val + ']').prop('checked', true); };  column.value = 2; // temp == 20 // &lt;input type=\"checkbox\" name=\"action_yn\" value=\"2\"/&gt; // column.$value == 2     The parameter in setFilter is setter carries a return value, and if there is no return value, it carries an internal value.   Example: When setting the setter and selector  column.setter = function(val) { \treturn temp = val * 10; }; column.selector = { key: '#u_name', type: 'value' }; // Cat  column.value = 2; // temp == 20 // &lt;input type=\"text\" name=\"u_name\" value=\"20\"/&gt; // column.$value == 20     The setter return value is stored in the internal value as the return value.   The selector’s value is set to an internal value.   Example: When setting selector only  column.selector = { key: '#u_name', type: 'value' };  column.value = 2; // &lt;input type=\"text\" name=\"u_name\" value=\"2\"/&gt; // column.$value == 2   Refer to  setter and setFilter play similar roles, but there is a difference. setter is used to set a single value, and setFilter is responsible for setting or processing the values of several HTML elements based on the internal value (original value). For example, when expressing a unit of currency, if the internal value is 1000, the screen outputs ‘1000’.   Understanding the BindModel Structure   BindModel automatically creates one MetaTable (name first), and each Bindcommand object added within this structure contains three MetaViews (valid, bind, and output).                  [[52. BindModel class-B#Main structure       - Reference: BindModel’s main structure]                 [53. Bind Command Class-B#Main Structure       - Reference: BindComand Main Structure]           Summary of BindModel’s Entities’ Structures   Here is the code that summarizes BindModel’s internal entity structure (MetaTable, MetaView):   function createCommand(baseTable) { \treturn { \t\tvalid: new MetaView('valid', baseTable), \t\tbind: new MetaView('bind', baseTable), \t\toutput: new MetaView('output', baseTable) \t}; }  var table1 = new MetaTabe('first'); var cmd1 = createCommand(table1);  cmd1.bind.columns.add('aa'); cmd1.output.columns.add('bb');  // table1.colmmns.count === 2 ('aa','bb') // table1.columns['aa'] === view2.columns['aa'] // table1.columns['bb'] === view3.columns['bb']  // view1.colmmns.count === 0 // view2.colmmns.count === 1 ('aa') // view3.colmmns.count === 1 ('bb')     When you add a column to a MetaView, it is added to the MetaTable specified in the MetaView as_baseEntity, where only the reference to the column is registered.   When you add a column directly to the MetaTable, it is added independently; unlike MetaView, it is not referenced by any other view.   When you create a BindModel, by default, a MetaTable named first is automatically created. Each Bind Command object automatically contains a MetaView named valid, bind, and output.   When you run the execute() method in BindModel, the column and data are set according to the structure of MetaTable and MetaView, which can be customized to meet a variety of user requirements.  ","url": "http://localhost:4000/en/docs/core/"
  },{
    "title": "How to create objects",
    "excerpt":"‘BindModel’ offers a number of creation methods to suit the needs of the user, understand the pros and cons of each method and choose the appropriate method as needed.   1. Creation by service objects   Service objects can be managed separately to increase productivity. Define the items and commands needed to create objects at once.   var bm = new BindModel({ \titems: { \t\taa: 10, \t\tbb: 20, \t\tcc: 30, \t\tdd: 40 \t}, \tcommand: { \t\tcreate: {}, \t\tread: { \t\t\toutputOption: 3 \t\t} \t}, \tmapping: { \t\taa: { create: 'valid'}, \t\tbb: { read: ['bind', 'output']}, \t\tcc: { $all: 'output'} \t} });  // Check it out // bm.command['create'].valid.columns.count   == 1 ('aa') // bm.command['create'].bind.columns.count    == 0 //  bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 2 ('bb','cc') // bm.columns.count  // 3 ('aa','bb','cc')   2. Map after adding to items   Specifies a commonly managed item, which is useful if columns are used for multiple commands.   var bm = new BindModel();  // Add command bm.addCommand('create'); bm.addCommand('read', 3);  // Add Item bm.items.add('aa', 10); bm.items.add('bb', 20); bm.items.add('cc', 30); bm.items.add('dd', 40);  // mapping bm.setMapping({ \taa: { create: 'valid' }, \tbb: { read: 'bind' }, \tcc: { $all: ['output'] }   // $all = all command });  // Check it out // bm.command['create'].valid.columns.count  == 1 ('aa') // bm.command['create'].bind.columns.count   == 0 // bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 1 ('cc')  // bm.columns.count  == 3 ('aa','bb')  // bm.columns['aa'].value; == 10 // bm.columns['bb'].value; == 20 // bm.columns['cc'].value; == 30  3. Setting commands when adding columns   This is how you specify the command at the time of column generation. It is effective when you gradually expand the functionality.   var bm = new BindModel();  // Add command bm.addCommand('create'); bm.addCommand('read', 3);  // Add Column and Set Commands bm.addColumn('aa', 'create', 'valid'); bm.addColumn('bb', 'read', 'bind'); bm.addColumn('cc', '$all', 'output');     // Check it out // bm.command['create'].valid.columns.count  == 1 ('aa') // bm.command['create'].bind.columns.count   == 0 // bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 1 ('cc')  // bm.columns.count  // 3 'aa','bb'   4. Set to command after adding column   It is a method of creating a column to be managed in advance and setting it up and using it in the necessary command. You can reduce code duplication by managing tables separately or generating common columns in advance.   var bm = new BindModel();  // Add command bm.addCommand('create'); bm.addCommand('read', 3);  // Add a column to the default columns bm.columns.addValue('aa', 10); bm.columns.addValue('bb', 20); bm.columns.addValue('cc', 30);  // Set to Command bm.command['create'].setColumn('aa', 'valid'); bm.command['create'].setColumn('cc', 'output'); bm.command['read'].setColumn('bb', ['bind']); bm.command['read'].setColumn('cc', ['output']);  // Check it out // bm.command['create'].valid.columns.count  == 1 ('aa') // bm.command['create'].bind.columns.count   == 0 // bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 1 ('cc')  // bm.columns.count  // 3 ('aa','bb')   5. Register column by command   It is a method of generating columns for each command, which is useful if you manage them as independent columns for each command.   var bm = new BindModel(); bm.addCommand('create'); bm.addCommand('read'); bm.command['create'].addColumn('aa', 'valid'); bm.command['read'].addColumn('bb', ['bind', 'output']);  // Check it out // bm.command['create'].valid.count  == 1 ('aa') // bm.command['create'].bind.count   == 0 // bm.command['create'].output.count == 0  // bm.command['read'].valid.count    == 0 // bm.command['read'].bind.count     == 1 ('bb') // bm.command['read'].output.count   == 1 ('bb')  // bm.columns.count  == 2 ('aa','bb')   This variety of object generation methods allow us to flexibly utilize BindModel, and it is important to consider the advantages and disadvantages of each method and choose the appropriate method.  ","url": "http://localhost:4000/en/docs/create-method/"
  },{
    "title": "객체 생성 방식",
    "excerpt":"BindModelAjax는 사용자의 다양한 요구에 맞게 여러 가지 생성 방식을 제공합니다. 각 방식의 장단점을 이해하고 필요에 따라 적절한 방법을 선택하여 사용할 수 있습니다.   1. 서비스 객체를 통한 생성   서비스 객체를 별도로 분리하여 관리할 수 있어 생산성을 향상시킵니다. 객체 생성 시 필요한 항목과 명령을 한 번에 정의합니다.   var bm = new BindModel({ \titems: { \t\taa: 10, \t\tbb: 20, \t\tcc: 30, \t\tdd: 40 \t}, \tcommand: { \t\tcreate: {}, \t\tread: { \t\t\toutputOption: 3 \t\t} \t}, \tmapping: { \t\taa: { create: 'valid'}, \t\tbb: { read: ['bind', 'output']}, \t\tcc: { $all: 'output'} \t} });  // Check it out // bm.command['create'].valid.columns.count   == 1 ('aa') // bm.command['create'].bind.columns.count    == 0 //  bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 2 ('bb','cc') // bm.columns.count  // 3 ('aa','bb','cc')   2. items 에 추가 후 매핑   공통으로 관리되는 item을 지정하고, 여러 명령에 컬럼이 사용될 경우 유용합니다.   var bm = new BindModel();  // command 추가 bm.addCommand('create'); bm.addCommand('read', 3);  // 아이템 추가 bm.items.add('aa', 10); bm.items.add('bb', 20); bm.items.add('cc', 30); bm.items.add('dd', 40);  // 매핑 bm.setMapping({ \taa: { create: 'valid' }, \tbb: { read: 'bind' }, \tcc: { $all: ['output'] }   // $all = all command });  // Check it out // bm.command['create'].valid.columns.count  == 1 ('aa') // bm.command['create'].bind.columns.count   == 0 // bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 1 ('cc')  // bm.columns.count  == 3 ('aa','bb')  // bm.columns['aa'].value; == 10 // bm.columns['bb'].value; == 20 // bm.columns['cc'].value; == 30   3. 컬럼 추가 시 명령 설정   컬럼 생성 시점에 command를 지정하는 방식입니다. 점진적으로 기능을 확장할 때 효과적입니다.   var bm = new BindModel();  // command 추가 bm.addCommand('create'); bm.addCommand('read', 3);  // 컬럼 추가 및 명령 설정 bm.addColumn('aa', 'create', 'valid'); bm.addColumn('bb', 'read', 'bind'); bm.addColumn('cc', '$all', 'output');     // Check it out // bm.command['create'].valid.columns.count  == 1 ('aa') // bm.command['create'].bind.columns.count   == 0 // bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 1 ('cc')  // bm.columns.count  // 3 'aa','bb'   4. 컬럼 추가 후 명령에 설정   관리해야 할 컬럼을 사전에 생성하여, 필요한 command에서 설정해서 사용하는 방식입니다. 테이블을 별도로 관리하거나 공통 컬럼을 사전에 생성하므로 코드 중복을 줄일 수 있습니다.   var bm = new BindModel();  // Add command bm.addCommand('create'); bm.addCommand('read', 3);  // Add a column to the default columns bm.columns.addValue('aa', 10); bm.columns.addValue('bb', 20); bm.columns.addValue('cc', 30);  // Set to Command bm.command['create'].setColumn('aa', 'valid'); bm.command['create'].setColumn('cc', 'output'); bm.command['read'].setColumn('bb', ['bind']); bm.command['read'].setColumn('cc', ['output']);  // Check it out // bm.command['create'].valid.columns.count  == 1 ('aa') // bm.command['create'].bind.columns.count   == 0 // bm.command['create'].output.columns.count == 1 ('cc')  // bm.command['read'].valid.columns.count    == 0 // bm.command['read'].bind.columns.count     == 1 ('bb') // bm.command['read'].output.columns.count   == 1 ('cc')  // bm.columns.count  // 3 ('aa','bb')   5. 명령별 컬럼 등록   각각의 command별로 컬럼을 생성하는 방식이며, command 별로 독립된 컬럼으로 관리할 경우 유용합니다.   var bm = new BindModel(); bm.addCommand('create'); bm.addCommand('read'); bm.command['create'].addColumn('aa', 'valid'); bm.command['read'].addColumn('bb', ['bind', 'output']);  // Check it out // bm.command['create'].valid.count  == 1 ('aa') // bm.command['create'].bind.count   == 0 // bm.command['create'].output.count == 0  // bm.command['read'].valid.count    == 0 // bm.command['read'].bind.count     == 1 ('bb') // bm.command['read'].output.count   == 1 ('bb')  // bm.columns.count  == 2 ('aa','bb')   이렇게 다양한 객체 생성 방식을 통해 BindModelAjax를 유연하게 활용할 수 있으며, 각 방식의 장단점을 고려하여 적절한 방법을 선택하는 것이 중요합니다.  ","url": "http://localhost:4000/ko/docs/create-method/"
  },{
    "title": "CRUD + L 예제",
    "excerpt":"CRUDL은 전통적인 데이터 처리 기능인 Create, Read, Update, Delete에 List를 추가한 개념입니다. 이는 데이터베이스와 상호작용을 단순화하고 효율적으로 관리하는 데 유용합니다. BindModel은 데이터베이스와의 상호작용을 위한 유용한 도구로, CRUDL 관점의 설계를 지향합니다.   등록 (Create)   Create는 데이터베이스에 새로운 레코드를 삽입하는 작업을 의미하며, REST API에서는 POST 요청에 해당합니다.   var bm = new BindModel(); // url 설정 및 command 생성 bm.url = '/user' bm.addCommand('create'); // 컬럼 추가 bm.addColumn('user_name', 'create', ['valid', 'bind']); bm.addColumn('tel', 'create', 'bind'); // 실행 bm.command['create'].execute();     bm.command['create'].valid.columns : 유효성 검사 대상의 컬럼들            “user_name” 컬럼의 유효성 검사를 합니다.           bm.command['create'].bind.columns  : HTTP 전송 대상의 컬럼들            “user_name, tel” 컬럼값은 /user 로 전송합니다.           POST 요청을 전송할 경우, bm.baseConfig.method = 'post'를 설정합니다.   읽기 (Read)   Read는 데이터베이스에서 특정 레코드를 조회하는 작업을 의미하며, REST API에서는 GET 요청에 해당합니다.   var bm = new BindModel(); // Create command bm.addCommand('read', 3); // Add Column bm.addColumn('idx','read', ['valid', 'bind']); bm.addColumn('tel','read', 'output'); // Setting and executing commands bm.command['read'].url = '/user/1' bm.command['read'].execute();     bm.command['read'].valid.columns : 유효성 검사 대상의 컬럼들            “idx” 컬럼의 유효성 검사를 합니다.           bm.command['read'].bind.columns  : HTTP 전송 대상의 컬럼들            “idx” 컬럼값은 /user 로 전송합니다.           bm.command['read'].output.columns  : HTTP 응답에서 받아올 컬럼들            “tel” 컬럼값은 /user 로 전송합니다.           RESTful 요청의 URL 수정은 cbBegin 콜백에서 설정할 수 있습니다.   수정 (Update)  Update는 데이터베이스의 기존 레코드를 수정하는 작업을 의미하며, REST API에서는 PUT 또는 PATCH 요청에 해당합니다.   var bm = new BindModel(); // url 설정 및 command 생성 bm.url = '/user' bm.addCommand('update'); // Add Column bm.addColumn ('idx', 'update', ['valid', 'bind']); // Check Required Values bm.addColumn('tel', 'update', 'bind'); // Execute bm.command['update'].execute();     bm.command['update'].valid.columns : 유효성 검사 대상의 컬럼들            “idx” 컬럼의 유효성 검사를 합니다.           bm.command['update'].bind.columns  : HTTP 전송 대상의 컬럼들            “idx, tel” 컬럼값은 /user 로 전송합니다.           PATCH 요청을 전송할 경우, bm.baseConfig.method = 'patch'를 설정합니다.   삭제 (Delete)   Delete는 데이터베이스의 특정 레코드를 삭제하는 작업을 의미하며, REST API에서는 DELETE 요청에 해당합니다.   var bm = new BindModel(); // url 설정 및 command 생성 bm.url = '/user'; bm.addCommand('delete'); // Add Column bm.addColumn ('idx', 'delete', ['valid', 'bind']); // Required value check // Execute bm.command['update'].execute();     bm.command['update'].valid.columns : 유효성 검사 대상의 컬럼들            “idx” 컬럼의 유효성 검사를 합니다.           bm.command['update'].bind.columns  : HTTP 전송 대상의 컬럼들            “idx” 컬럼값은 /user 로 전송합니다.           DELETE 요청을 전송할 경우, bm.baseConfig.method = 'delete'를 설정합니다.   조회 (List)   List는 데이터베이스에서 여러 레코드를 조회하는 작업을 의미하며, REST API에서는 GET 또는 POST 요청에 해당합니다.   { \t\"rows\": [ \t\t{ \"u_name\": \"Hong Gildong\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Sungchunhyang\", \"gender\", \"W\" }, \t] }   var bm = new BindModel(); // url 설정 및 command 생성 bm.url = '/user/list' bm.addCommand('list', 2); // 컬럼 추가 bm.addColumn('user_name', 'list', 'output'); bm.addColumn('gender', 'list', 'output'); // 출력 콜백 설정 bm.command['list'].cbOutput = function(views){ \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(i, row['user_name'], row['gender']); \t\t// 0 Hong Gil-dong M \t\t// 1. Sung Chunhyang W \t} } // Execute bm.command['list'].execute();     bm.command['update'].valid.columns : 유효성 검사 대상의 컬럼들            “idx” 컬럼의 유효성 검사를 합니다.           bm.command['update'].bind.columns  : HTTP 전송 대상의 컬럼들            “idx” 컬럼값은 /user 로 전송합니다.           cbOutput 콜백에서 화면 출력 관련 작업을 작성합니다.   이와 같이 CRUDL은 전통적인 CRUD 기능에 조회(List)를 추가하여 보다 유연하고 강력한 데이터 조작 기능을 제공합니다. BindModel을 사용하면 이러한 CRUDL 작업을 간편하게 수행할 수 있습니다.   등록 / 읽기 / 수정 / 삭제 / 조회 예제   다음은 Create, Read, Update, Delete, List 전체 예제를 포함한 예제입니다.   서버 데이터  { \t\"rows\": [ \t\t{ \"u_name\": \"Neo\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Seri\", \"gender\", \"W\" }, \t] }  컬럼을 command 에서 공유되어서 컬럼을 등록 후 설정하는 방식을 선택했습니다.   예제 : 메소드 호출 방식  var bm = new BindModel();  // setting url bm.url = '/user'  // command registration bm.addCommand('create'); bm.addCommand('read', 3); bm.addCommand('update'); bm.addCommand('delete'); bm.addCommand('list', 2);  // Register a column bm.addColumn('user_name'); bm.addColumn('tel'); bm.addColumn('idx'); bm.addColumn('gender');  // create command setting bm.command['create'].seColumn('user_name', ['valid', 'bind']); bm.command['create'].seColumn('tel', 'bind');  // read command setting bm.command['read'].seColumn('idx', ['valid', 'bind']); bm.command['read'].seColumn('tel', 'output'); bm.command['read'].url = '/user/1';  // update command setting bm.command['update'].seColumn('idx', ['valid', 'bind']); bm.command['update'].seColumn('tel', 'bind');  // delete command setting bm.command['delete'].seColumn('idx', ['valid', 'bind']);  // list command setting bm.command['list'].seColumn('user_name', 'output'); bm.command['list'].seColumn('gender', 'output');  bm.command['list'].url = '/user/list'; bm.command['list'].cbOutput = function(views){ \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(i, row['user_name'], row['gender']); \t\t// 0 Hong Gil-dong M \t\t// 1. Sung Chunhyang W \t} };  // Execute bm.command['create'].execute(); bm.command['read'].execute(); bm.command['update'].execute(); bm.command['delete'].execute(); bm.command['list'].execute();   예제 : 서비스객체 주입 방식  var bm = new BindModel({ \turl: '/user', \titems: { \t\tuser_name: '', \t\ttel: '', \t\tidx: '', \t\tgender: '', \t}, \tcommand: { \t\tcreate: {}, \t\tread: { \t\t\toutputOption: 3, \t\t\turl: '/user/1' \t\t}, \t\tupdate: {}, \t\tdelete: {}, \t\tlist: { \t\t\toutputOption: 2, \t\t\turl: '/user/list', \t\t\tcbOutput = function(views){ \t\t\t\tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\t\t\t\tvar row = views['first'].rows[i]; \t\t\t\t\tconsole.log(i, row['user_name'], row['gender']); \t\t\t\t\t// 0 Hong Gil-dong M \t\t\t\t\t// 1. Sung Chunhyang W \t\t\t\t} \t\t\t} \t\t}, \t}, \tmapping: { \t\tuser_name: {  \t\t\tcreate: ['valid', 'bind'],  \t\t\tlist: 'output'  \t\t}, \t\ttel: {  \t\t\tcreate: 'bind',  \t\t\tread: 'bind',  \t\t\tupdate: 'bind' \t\t}, \t\tidx: {  \t\t\tread: ['valid', 'bind'],  \t\t\tupdate: ['valid', 'bind'],  \t\t\tdelete: ['valid', 'bind'] }, \t\t}, \t\tgender: {  \t\t\tlist: 'output'  \t\t} \t} });  // Execute bm.command['create'].execute(); bm.command['read'].execute(); bm.command['update'].execute(); bm.command['delete'].execute(); bm.command['list'].execute();   이 두 가지 예제는 CRUDL 작업을 효율적으로 수행하기 위한 방법을 보여줍니다. 메소드 호출 방식과 서비스 객체 주입 방식을 사용하여 각 명령어를 설정하고 실행하는 방법을 설명하고 있습니다.  ","url": "http://localhost:4000/ko/docs/crudl-example/"
  },{
    "title": "CRUD + List Example",
    "excerpt":"CRUDL is a concept that adds List to the traditional data processing capabilities of Create, Read, Update, and Delete. It is useful for simplifying and efficiently managing database interactions. BindModel is a useful tool for interacting with databases, aiming to design from a CRUDL perspective.   Register (Create)   Create refers to the task of inserting new records into the database, and the REST API corresponds to a POST request.   var bm = new BindModel(); // Create url settings and commands bm.url = '/user' bm.addCommand('create'); // Add Column bm.addColumn('user_name', 'create', ['valid', 'bind']); bm.addColumn('tel', 'create', 'bind'); // Execute bm.command['create'].execute();     ‘bm.command[‘create’.valid.column’ : columns subject to validation            Validates the “user_name” column.           ‘bm.command[‘create’].bind.column’ : columns for HTTP transmission            The value of the “user_name, tel” column is sent to ‘/user’.           When sending a POST request, set ‘bm.baseConfig.method = ‘post’.   Read (Read)   Read refers to the task of querying a specific record in a database, and in REST API, it is a GET request.   var bm = new BindModel(); // Create command bm.addCommand('read', 3); // Add Column bm.addColumn('idx','read', ['valid', 'bind']); bm.addColumn('tel','read', 'output'); // Setting and executing commands bm.command['read'].url = '/user/1' bm.command['read'].execute();     ‘bm.command[‘read’].valid.column’ : columns subject to validation            Validates the “idx” column.           ‘bm.command[‘read’].bind.column’ : columns for HTTP transmission            The value of the “idx” column is sent to ‘/user’.           ‘bm.command[‘read’].output.column’: Columns to receive from HTTP response            Send the value of the “tel” column to ‘/user’.           URL modification of RESTful requests can be set in cbBegin callback.   Modified (Update)  Update refers to the task of modifying an existing record in a database, and the REST API corresponds to a PUT or PATCH request.   var bm = new BindModel(); // Create url settings and commands bm.url = '/user' bm.addCommand('update'); // Add Column bm.addColumn ('idx', 'update', ['valid', 'bind']); // Check Required Values bm.addColumn('tel', 'update', 'bind'); // Execute bm.command['update'].execute();     ‘bm.command[‘update’.valid.column’ : columns subject to validation            Validates the “idx” column.           ‘bm.command[‘update’].bind.column’: Columns to HTTP transmission            The value of the “idx, tel” column is sent to ‘/user’.           When sending a PATCH request, set ‘bm.baseConfig.method = ‘patch’.   Delete   Delete refers to the action of deleting a specific record in a database, and the REST API corresponds to a DELETE request.   var bm = new BindModel(); // Create url settings and commands bm.url = '/user'; bm.addCommand('delete'); // Add Column bm.addColumn ('idx', 'delete', ['valid', 'bind']); // Required value check // Execute bm.command['update'].execute();     ‘bm.command[‘update’.valid.column’ : columns subject to validation            Validates the “idx” column.           ‘bm.command[‘update’].bind.column’: Columns to HTTP transmission            The value of the “idx” column is sent to ‘/user’.           If sending a DELETE request, set ‘bm.baseConfig.method = ‘delete’.   Inquiry (List)   List refers to the task of querying multiple records in a database, and the REST API corresponds to a GET or POST request.   { \t\"rows\": [ \t\t{ \"u_name\": \"Hong Gildong\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Sungchunhyang\", \"gender\", \"W\" }, \t] }   var bm = new BindModel(); // Create url settings and commands bm.url = '/user/list' bm.addCommand('list', 2); // Add Column bm.addColumn('user_name', 'list', 'output'); bm.addColumn('gender', 'list', 'output'); // Output callback settings bm.command['list'].cbOutput = function(views){ \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(i, row['user_name'], row['gender']); \t\t// 0 Hong Gil-dong M \t\t// 1. Sung Chunhyang W \t} } // Execute bm.command['list'].execute();     ‘bm.command[‘update’.valid.column’ : columns subject to validation            Validates the “idx” column.           ‘bm.command[‘update’].bind.column’: Columns to HTTP transmission            The value of the “idx” column is sent to ‘/user’.           Create a screen output related task in the cbOutput callback.   As such, CRUDL provides more flexible and powerful data manipulation capabilities by adding a list to traditional CRUD capabilities. With BindModel, these CRUDL tasks are simple to perform.   Registration / Read / Correct / Delete / Lookup Example   The following example includes the complete examples of Create, Read, Update, Delete, and List.   Server data  { \t\"rows\": [ \t\t{ \"u_name\": \"Neo\", \"gender\", \"M\" }, \t\t{ \"u_name\": \"Seri\", \"gender\", \"W\" }, \t] }   The column was shared in the command, so you selected how to register and set the column.   Example: Method Call Method  var bm = new BindModel();  // setting url bm.url = '/user'  // command registration bm.addCommand('create'); bm.addCommand('read', 3); bm.addCommand('update'); bm.addCommand('delete'); bm.addCommand('list', 2);  // Register a column bm.addColumn('user_name'); bm.addColumn('tel'); bm.addColumn('idx'); bm.addColumn('gender');  // create command setting bm.command['create'].seColumn('user_name', ['valid', 'bind']); bm.command['create'].seColumn('tel', 'bind');  // read command setting bm.command['read'].seColumn('idx', ['valid', 'bind']); bm.command['read'].seColumn('tel', 'output'); bm.command['read'].url = '/user/1';  // update command setting bm.command['update'].seColumn('idx', ['valid', 'bind']); bm.command['update'].seColumn('tel', 'bind');  // delete command setting bm.command['delete'].seColumn('idx', ['valid', 'bind']);  // list command setting bm.command['list'].seColumn('user_name', 'output'); bm.command['list'].seColumn('gender', 'output');  bm.command['list'].url = '/user/list'; bm.command['list'].cbOutput = function(views){ \tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\tvar row = views['first'].rows[i]; \t\tconsole.log(i, row['user_name'], row['gender']); \t\t// 0 Hong Gil-dong M \t\t// 1. Sung Chunhyang W \t} };  // Execute bm.command['create'].execute(); bm.command['read'].execute(); bm.command['update'].execute(); bm.command['delete'].execute(); bm.command['list'].execute();   Example: Service Object Injection Method  var bm = new BindModel({ \turl: '/user', \titems: { \t\tuser_name: '', \t\ttel: '', \t\tidx: '', \t\tgender: '', \t}, \tcommand: { \t\tcreate: {}, \t\tread: { \t\t\toutputOption: 3, \t\t\turl: '/user/1' \t\t}, \t\tupdate: {}, \t\tdelete: {}, \t\tlist: { \t\t\toutputOption: 2, \t\t\turl: '/user/list', \t\t\tcbOutput = function(views){ \t\t\t\tfor(var i = 0; i &lt; views[0].rows.count; i++) { \t\t\t\t\tvar row = views['first'].rows[i]; \t\t\t\t\tconsole.log(i, row['user_name'], row['gender']); \t\t\t\t\t// 0 Hong Gil-dong M \t\t\t\t\t// 1. Sung Chunhyang W \t\t\t\t} \t\t\t} \t\t}, \t}, \tmapping: { \t\tuser_name: {  \t\t\tcreate: ['valid', 'bind'],  \t\t\tlist: 'output'  \t\t}, \t\ttel: {  \t\t\tcreate: 'bind',  \t\t\tread: 'bind',  \t\t\tupdate: 'bind' \t\t}, \t\tidx: {  \t\t\tread: ['valid', 'bind'],  \t\t\tupdate: ['valid', 'bind'],  \t\t\tdelete: ['valid', 'bind'] }, \t\t}, \t\tgender: {  \t\t\tlist: 'output'  \t\t} \t} });  // Execute bm.command['create'].execute(); bm.command['read'].execute(); bm.command['update'].execute(); bm.command['delete'].execute(); bm.command['list'].execute();   These two examples illustrate how to perform CRUDL tasks efficiently. It explains how to set up and execute each command using the method call method and the service object injection method.  ","url": "http://localhost:4000/en/docs/crudl-example/"
  },{
    "title": "Main Features",
    "excerpt":"BindModel is both a framework and a library feature. It uses commands and entities that are not based on trendy UI components for higher productivity. Client-to-server communication can be easily implemented through the BindModel class.   Manage Entities   BindModel manages all data as an entity (MetaTable, MetaView) to support structured data processing, enabling consistent and efficient data management.   Transaction Support  MetaTable supports transactions to maintain data consistency and integrity.   Flexible Data Manipulation  MetaTable provides the ability to add, modify, delete, and query data to facilitate data manipulation.   Flexible UI Configuration  MetaView can easily work with a variety of UI elements to create a dynamic and flexible user interface.   MetaTable is an entity that manages data in a table format. It is designed with a structure that is very familiar to people who have used DotNet’s DataTable.   %% All data is managed by an entity (MetaTable, MetaView). Familiar to anyone who has used DotNet’s DataTable, and supports transactions.%   command-based processor   BindModel provides a command-based processor to support a consistent development pattern. This structure provides a systematic and easy-to-maintain approach to command processing and data management for applications.   a structural approach  Command-based processors help to clearly structure an application’s business logic. Each command is managed independently and can be easily modified or expanded as needed.  Reusable  Similar tasks can be handled in multiple locations by reusing commands, which reduce redundant code writing and maintain code consistency.   Simplicity and Productivity   BindModel increases the intuitive nature of code by minimizing specific grammar or indicators and eliminating unnecessary components. OOP-based design minimizes code duplication by utilizing inheritance and provides simplicity and high productivity to users by designing based on frequency of use in projects.   Minimize code duplication  It provides an efficient structure to avoid the need for repeated code writing, increasing maintenance and scalability.   User-friendly  It is designed to make it easy for beginners to learn, and users with experience in web development can create a website with two to three hours of learning.   Low design burden  There is less pressure on file and screen component division, so you don’t have to spend a lot of time designing the project’s initial design.   efficient development  With BindModel, you can significantly reduce the number of files, code lines, code complexity, and development time, so you can experience more than five times more productivity.   Independent View   BindModel serves as a controller of the MVC pattern and is completely separate from View, making it very easy to replace and manage the screen. This design allows developers to manage the logic of applications with minimal impact on UI changes.   Inject service objects   By supporting service object injection, BindModel can maximize the flexibility of the framework and increase the reuse of objects. Through service object injection, common functions of applications can be modularized and dependency management can be simplified.   object serialization   BindModel supports object serialization, allowing for efficient transfer and remote control of objects. Object serialization plays an important role in storing the state of an object or in communicating with other systems.   backward compatibility   BindModel is built in JavaScript ECMAScript 5 (ES5) grammar to ensure backward compatibility. It works reliably in a variety of environments and ensures compatibility with existing JavaScript code.   TypeScript support   BindModel provides TypeScript type information in development environments, helping developers write codes more safely and efficiently. TypeScript’s static type checks prevent code errors and greatly improve development productivity through code completion.   Promise Support   BindModel provides Promise per command, helping you to process asynchronous tasks more easily. Promise provides the methods needed to process the results of asynchronous tasks (then, catch, finally), greatly improving the readability and maintenance of code.   Integrated Library   It is a harmonious collection of libraries needed for web development, such as routing, form management, and client-server communication.   ","url": "http://localhost:4000/en/docs/feature/"
  },{
    "title": "주요 특징",
    "excerpt":"BindModel은 프레임워크이면서 라이브러리의 특징을 가집니다. 최신 유행하는 UI 컴포넌트 기반이 아닌 명령과 엔티티를 사용하여 더 높은 생산성을 제공합니다. BindModelAjax 클래스를 통해 클라이언트-서버 간의 통신을 손쉽게 구현할 수 있습니다.   엔티티 관리   BindModel은 모든 데이터를 엔티티(MetaTable, MetaView)로 관리하여 구조화된 데이터 처리를 지원합니다. 이를 통해 데이터 관리를 일관되고 효율적으로 수행할 수 있습니다.   트랜잭션 지원  MetaTable은 데이터의 일관성과 무결성을 유지하기 위해 트랜잭션을 지원합니다.   유연한 데이터 조작  MetaTable은 데이터를 추가, 수정, 삭제, 조회하는 기능을 제공하여 데이터 조작을 용이하게 합니다.   유연한 UI 구성  MetaView는 다양한 UI 요소와 쉽게 연동될 수 있으며, 이를 통해 동적이고 유연한 사용자 인터페이스를 구축할 수 있습니다.   MetaTable은 데이터를 테이블 형식으로 관리하는 엔티티입니다. 닷넷의 DataTable을 사용해본 사람에게 매우 익숙한 구조로 설계되었습니다.   명령기반 프로세서   BindModel은 명령(BindCommand) 기반의 프로세서를 제공하여 일관된 개발 패턴을 지원합니다. 이 구조는 애플리케이션의 명령 처리와 데이터 관리에 있어 체계적이고 유지보수하기 쉬운 접근 방식을 제공합니다.   구조적 접근  명령 기반 프로세서는 애플리케이션의 비즈니스 로직을 명확하게 구조화할 수 있게 도와줍니다. 각 명령은 독립적으로 관리되며, 필요에 따라 쉽게 수정하거나 확장할 수 있습니다.  재사용성  명령을 재사용하여 비슷한 작업을 여러 곳에서 처리할 수 있습니다. 이를 통해 중복된 코드 작성을 줄이고, 코드의 일관성을 유지할 수 있습니다.   단순함과 생산성   BindModel은 특정 문법이나 지시자를 최소화하고, 불필요한 컴포넌트 요소를 배제하여 코드의 직관성을 높였습니다. OOP 기반의 설계를 통해 상속을 활용함으로써 코드의 중복을 최소화하고, 프로젝트에서 사용빈도를 토대로 설계하여 사용자에게 단순함과 높은 생산성을 제공합니다.   코드 중복 최소화  반복되는 코드 작성이 필요 없도록 효율적인 구조를 제공하여, 유지보수와 확장성을 높였습니다.   사용자 친화적  초보자도 쉽게 배울 수 있도록 설계되어 있으며, 웹 개발 경험이 있는 사용자는 2~3시간의 학습으로 웹사이트를 충분히 제작할 수 있습니다.   낮은 설계 부담  파일 및 화면의 컴포넌트 분할에 대한 부담이 적어, 프로젝트 초기 설계에 많은 시간을 할애할 필요가 없습니다.   효율적인 개발  BindModel을 사용하면 파일 수, 코드 줄 수, 코드의 복잡도, 개발 시간을 크게 줄일 수 있어, 5배 이상의 생산성 향상을 경험할 수 있습니다.   독립적 View   BindModel은 MVC 패턴의 Controller 역할을 수행하며, View와 완전히 분리되어 있어 화면의 교체와 관리가 매우 용이합니다. 이러한 설계는 개발자가 UI 변경에 영향을 최소화하면서 애플리케이션의 로직을 관리할 수 있게 합니다.   서비스 객체 주입   BindModel은 서비스 객체 주입을 지원하여, 프레임워크의 유연성을 극대화하고 객체의 재사용성을 높일 수 있습니다. 서비스 객체 주입을 통해, 애플리케이션의 공통된 기능을 모듈화하고, 의존성 관리를 간편하게 할 수 있습니다.   객체 직렬화   BindModel은 객체 직렬화를 지원하여, 객체를 효율적으로 전송하고 원격 제어할 수 있도록 합니다. 객체 직렬화는 객체의 상태를 저장하거나 다른 시스템과의 통신에 있어 중요한 역할을 합니다.   하위 호환성   BindModel은 하위 호환성을 보장하기 위해 ES5(JavaScript ECMAScript 5) 문법으로 제작되었습니다. 이는 다양한 환경에서 안정적으로 동작하며, 기존의 자바스크립트 코드와의 호환성을 유지할 수 있도록 합니다.   TypeScript 지원   BindModel은 개발 환경에서 TypeScript 타입 정보를 제공하여, 개발자들이 더욱 안전하고 효율적으로 코드를 작성할 수 있도록 돕습니다. TypeScript의 정적 타입 검사는 코드의 오류를 사전에 방지하고, 코드 완성 기능을 통해 개발 생산성을 크게 향상시킵니다.   Promise 지원   BindModel은 명령(BindCommand)별로 Promise를 제공하여, 비동기 작업을 더욱 쉽게 처리할 수 있도록 돕습니다. Promise는 비동기 작업의 결과를 처리하는 데 필요한 메서드(then, catch, finally)를 제공하여, 코드의 가독성과 유지보수성을 크게 향상시킵니다.   통합 라이브러리   라우팅, 폼 관리, 클라이언트-서버 통신 등 웹 개발에 필요한 라이브러리를 조화롭게 통합한 모음집입니다.   ","url": "http://localhost:4000/ko/docs/feature/"
  },{
    "title": "HTMLColumn 클래스",
    "excerpt":"HTMLColumn 은 바인딩의 핵심입니다 특별한 지시자를에 하용하지 않고 내부구현 방식을 직접 제어하면, 익숙해지면 다양한 조건에 응용할 수 있습니다. 개발시 디버깅과 응용에 유리하며, 개발자도구 만으로 충분합니다.   클래식한 코딩 방식을 유지하면서 코드의 중복을 최소화 하고 재활용에 중점을 두었습니다.   주요 구조   상속 관계   Class diagram    주요 요소   속성                  항목       설명                       domType       아이템 DOM 타입을 정의합니다.                 isReadOnly       읽기 전용 여부를 나타냅니다.                 isHide       숨김 여부를 나타냅니다.                 element       DOM 요소를 나타냅니다.                 selector       셀렉터를 정의합니다.                 getFilter       value 값을 필터링하는 함수입니다.                 setFilter       value 값을 필터링하는 함수입니다.                 value       아이템의 값을 설정하거나 가져옵니다.                 required       컬럼 값의 필수 여부를 설정합니다. 값이 반드시 존재해야 하는 경우 true, 그렇지 않은 경우 false입니다.                 constraints       컬럼의 제약 조건을 설정합니다. 제약 조건은 객체 또는 함수 형태로 설정할 수 있습니다.                 getter       컬럼 값의 getter 함수입니다.                 setter       컬럼 값의 setter 함수입니다.                 columnName       컬럼의 이름을 나타냅니다. _name과 동일합니다.                 alias       컬럼의 별칭을 설정하거나 가져옵니다. 별칭은 데이터 전송 및 로우값 설정 시 사용됩니다.                 default       컬럼의 기본값을 설정합니다.                 caption       컬럼에 대한 설명을 제공합니다.                 _valueTypes       컬럼의 값 타입을 정의합니다. 이 속성은 컬럼 값의 타입을 설정하는 데 사용됩니다.                 _entity       이 컬럼이 속한 엔티티를 나타냅니다. BaseEntity 타입의 객체입니다                 _guid       객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다.                 _type       객체의 생성자 함수. 객체가 생성될 때 사용된 함수입니다.                                       메소드                  항목       설명                       clone(entity)       현재 아이템의 DOM을 복제합니다.                 addConstraint(regex, msg, code, condition)       제약 조건을 추가합니다.                 valid(value)       속성의 값이 유효한지 검사합니다. required 및 constraints를 기준으로 유효성을 검사합니다.                 getObject(vOpt, owned)       현재 객체를 직렬화된 객체로 얻습니다. 순환 참조는 $ref 값으로 대체됩니다.                 setObject(oGuid, origin)       직렬화된 객체를 현재 객체에 설정합니다.   객체는 초기화됩니다.                 equal(target)       현재 객체와 지정된 객체가 동일한지 비교합니다.                 getTypes()       현재 객체의 생성자와 프로토타입 체인의 모든 생성자를 배열로 반환합니다.                 instanceOf(target)       현재 객체가 지정된 타입의 인스턴스인지 확인합니다. (_UNION 포함)                                      이벤트                  항목       위치       설명                       onChanged       MetaColumn       컬럼 값이 변경될 때 발생하는 이벤트입니다.                                             세부 설명   주요 속성   domType      아이템 DOM 타입을 정의합니다.    type domType = object;   isReadOnly      읽기 전용 여부를 나타냅니다.    type isReadOnly = boolean;   isHide      숨김 여부를 나타냅니다.    type isHide = boolean;   element      DOM 요소를 나타냅니다.    type element = HTMLElement;   selector      셀렉터를 정의합니다. type         val 또는 value: 요소의 value 속성값     text: 요소의 텍스트값     html: 요소의 HTML 값     css.속성명: CSS의 속성값 (객체)     prop.속성명: 요소의 속성명값 (초기 상태 기준)     attr.속성명: 요소의 속성명값 (현재 상태)     none: 아무 작업도 수행하지 않음, 표현의 목적 예시: ‘value’, ‘text’, ‘css.color’, ‘prop.disabled’      type selector = { key: string, type: string };   getFilter      value 값을 필터링하는 함수입니다.    type getFilter = (sVal: any) =&gt; any;     sVal : selector 가 존재시 selector 에서 얻는 값입니다.   return : 필터링된 value 값입니다.   setFilter      value 값을 필터링하는 함수입니다.    type setFilter = (val: any) =&gt; any | undefined;     val : 필터로 적용할 값입니다.   return : 필터링 결과값이 있으면, selector 의 값을 설정합니다.            undefined 리턴시   selector 값을 설정하지 않습니다.         value                      아이템의 값을 설정하거나 가져옵니다.    type value = string | number | boolean;   required      컬럼 값의 필수 여부를 설정합니다. 값이 반드시 존재해야 하는 경우 true, 그렇지 않은 경우 false입니다.    type required = boolean;   constraints      컬럼의 제약 조건을 설정합니다. 제약 조건은 객체 또는 함수 형태로 설정할 수 있습니다.    type constraints = (object | Function)[];   getter      컬럼 값의 getter 함수입니다.    type getter = () =&gt; string | number | boolean;     return : 컬럼의 현재 값입니다.   setter      컬럼 값의 setter 함수입니다.    type setter = (value: string | number | boolean) =&gt; void;     value : 설정할 값입니다.   columnName      컬럼의 이름을 나타냅니다. _name과 동일합니다.    type columnName = string;   alias      컬럼의 별칭을 설정하거나 가져옵니다. 별칭은 데이터 전송 및 로우값 설정 시 사용됩니다. 사용처 (기본값 = columnName )\\         Bind-command-ajax._execBind() : 데이터 전송시     BaseBind.setValue(row) : 로우값 을 엔티티에 설정시     getValue() : row 에 활용함      type alias = string;   default      컬럼의 기본값을 설정합니다.    type default = string | number | boolean;   caption      컬럼에 대한 설명을 제공합니다.    type caption = string;   _valueTypes      컬럼의 값 타입을 정의합니다. 이 속성은 컬럼 값의 타입을 설정하는 데 사용됩니다.    type _valueTypes = any;   _entity      이 컬럼이 속한 엔티티를 나타냅니다. BaseEntity 타입의 객체입니다.    type _entity = BaseEntity;   _guid      객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다.    type _guid: string;   _type      객체의 생성자 함수입니다. 객체가 생성될 때 사용된 함수입니다.    type _type = Function;    주요 메소드   clone()      현재 컬럼을 복제합니다.    type clone = (entity: BaseEntity) =&gt; this;     entity : 복제할 대상의 엔티티입니다.   return : 현재 인스턴스의 복제본입니다.   addConstraint()      제약 조건을 추가합니다.    type addConstraint = ( \tregex: RegExp,  \tmsg: string,  \tcode?: string,  \tcondition?: boolean ) =&gt; void;     regex : 적용할 정규 표현식입니다.   msg : 정규 표현식 실패 시 표시할 메시지입니다.   code : 정규 표현식 실패 시 코드입니다. (옵션)   condition : 제약 조건의 성공/실패 여부를 결정하는 조건입니다. 기본값은 false입니다.     valid()          속성의 값이 유효한지 검사합니다. required 및 constraints를 기준으로 유효성을 검사합니다.    type valid = (value: ValueType): object | undefined;     value : 검사할 값입니다.   return : 유효하지 않은 경우 객체를 반환하며, 유효한 경우 undefined를 반환합니다.   getObject()      현재 객체를 직렬화(guid 타입) 객체로 얻습니다. (순환참조는 $ref 값으로 대체됩니다.)    type getObject = (vOpt?: number, owned?: object | Array&lt;object&gt;) =&gt; object;     vOpt :  가져오기 옵션입니다. 기본값은 0 입니다.            opt=0 : 참조 구조(_guid:Yes, $ref:Yes)       opt=1 : 중복 구조(_guid:Yes, $ref:Yes)       opt=2 : 비참조 구조(_guid:No, $ref:No)           owned : 현재 객체를 소유하는 상위 객체들입니다. 기본값은 빈객체 입니다.   return : 직렬화된 객체를 반환합니다.   a.getObject(2) == b.getObject(2)   setObject()      직렬화(guid 타입) 객체를 현재 객체에 설정합니다. (객체는 초기화 됩니다.)    type setObject = (oGuid: object, origin?: object) =&gt; void;     oGuid : 직렬화할 guid 타입의 객체입니다.   origin : 현재 객체를 설정하는 원본 객체입니다. 기본값은 oGuid 입니다.   equal()      현재 객체와 지정된 객체가 동일한지 비교합니다.    type equal (target: object) =&gt; boolean;     return : 두 객체가 동일한지 여부를 반환합니다.   getTypes()      현재 객체의 생성자와 프로토타입 체인의 모든 생성자를 배열로 반환합니다.    type getTypes = () =&gt; Array&lt;Function&gt;;     return : 생성자 함수의 배열을 반환합니다.   const types = obj.getTypes(); console.log(types); // [Function: MetaObject]   instanceOf()      현재 객체가 지정된 타입의 인스턴스인지 확인합니다. (_UNION 포함)    type instanceOf = (target: object | string) =&gt; boolean;     target : 확인할 대상 타입 (객체 또는 문자열)입니다.   return : 지정된 타입의 인스턴스인지 여부를 반환합니다.    주요 이벤트      컬럼 값이 변경될 때 발생하는 이벤트입니다.    type onChanged = (newVal: ValueType, oldVal: ValueType, _this: this) =&gt; void;     newVal : 새 값입니다.   oldVal : 이전 값입니다.   _this : 이벤트를 발생시킨 객체입니다.   예제  column.onChanged = function(newVal, oldVal, _this) { \tconsole.log('Value changed'); };   column 의 value 얻기   우선순위 : 1. getter &gt; 2. getFilter &gt; 3. selector &gt; 4. inner value &gt; 5.default column value 을 얻을때 속성(getter, getFilter, selector) 설정의 우선순위에 따라 선택된 값을 회신합니다.   getter 내부 구조        getter 가 있는 경우, getter 의 return 값을 회신합니다.   getFilter 가 있는 경우, getFilter 의 return 값을 회신합니다. selector 가  동시에 있으면 selector 값은 getFilter(selectorValue) 의 인자로 전달합니다.   selector 가 있는 경우, type 에 따라 값을 회신합니다. type : value, text, html, prop, attr, css (jquey사용) (type = ‘none’ 제외)   내부값을 회신합니다.   내부값이 empty(undefined, null)일 경우, default 값을 회신합니다. default 의 기본값은 ‘‘(빈문자) 입니다.   column 의 value 설정   설정 순서 : 1. setter &gt; 2. inner value &gt; 3. setFilter &gt; 4. selector column value 을 설정 할 때 순차적으로 설정합니다.   setter 내부 구조        setter 가 있는 경우, setter 함수를 호출합니다.   setter 의 return 값을 inner value 에 저장합니다. return 이 없을 경우, 입력값을 저장합니다.   setFilter 가 있는 경우, setFilter 함수를 호출합니다.   selector 이 있는 경우, type 에 따라 값을 설정합니다. (jquery 사용) type : value, text, html, prop, attr, css (jquey사용) (type = ‘none’는 제외)   사용 빈도   HTMLComun 설계시 사용빈도를 분석하여     중복코드의 최소화   다양한 사례에 적용이 가능하고   직관적이 코드 구조를 고려하여 설계 하셨습니다.   또한 selector 는 checkSelector() 메소드로 html 페이지에 대한 요소의 존재여부 확인에 사용됩니다.                  빈도       setter       setFilter       selector       getFilter       getter       설명                       89%                       사용                       - DOM 을 직접 가르키는 경우   - 단독 요소의 경우   - 예시&gt; 태그 p, text, select, css                 3%       사용                               사용       - 외부 객체의 가르키는 경우   - 예시&gt; page_count                 3%       사용               사용               사용       - 외부 객체와 DOM 을 같이 사용 하는 경우   - 예시&gt; page_size = 페이지표시줄수(select box)                 3%               사용       'none'       사용               - 복합 DOM 객체를 가리키는 경우   - selector 은 검사용으로만 사용   - 예시&gt; radio                 1%               사용       사용                       - 단방향으로 사용한 경우   - 예시&gt; 금액(숫자+콤마) 표시                 1%                       'none'       사용               - 단방향으로 사용할 경우   - 예시&gt; 코드값 변환, 목록 선택 값                                                                             (쇼핑몰 웹사이트,  DB Table 36EA 기준)   예제 코드  a. selector 을 사용하는 경우   HTML 요소의 속성값을 value 로 선택할 사용합니다. selector 의 type 은 html, text, value, prop.*, attr.*, css.* 이 있습니다. 또한 selector 은 value 조회/설정 이외에 유효성 검사에 사용할 수 있습니다. BindModelAjax 객체의 checkSelector() 메소드를 통해서 DOM 에 유효성 검사 여부에 활용합니다.   &lt;div id=\"p-nm\"&gt;&lt;p style=\"color:red;\"&gt;10&lt;/p&gt;&lt;/div&gt; &lt;input id=\"p-title\" type=\"text\" value=\"AA\" &gt; &lt;input id=\"p-check\" type=\"checkbox\" checked /&gt; &lt;a href=\"#\"&gt;google.com&lt;/a&gt;   var c1 = new HTMLColumn('c1'); var c2 = new HTMLColumn('c2'); var c3 = new HTMLColumn('c3'); var c4 = new HTMLColumn('c4'); var c5 = new HTMLColumn('c5'); var c6 = new HTMLColumn('c6');  c1.selector = { key: '#area-nm',  type: 'html' }; c2.selector = { key: '#area-nm',  type: 'text' }; c3.selector = { key: '#p-title',  type: 'value' }; c4.selector = { key: 'p-check',   type: 'prop.checked' }; c5.selector = { key: 'a',         type: 'attr.href' }; c6.selector = { key: 'p',         type: 'css.color' };  c1.value; // &lt;p&gt;10&lt;/p&gt; c2.value; // 10 c3.value; // \"AA\" c4.value; // true c5.value; // \"google.com\" c6.value; // \"red\"   b. setter, getter 을 사용한 경우   외부값을 HTMLColumn 의 value 로 사용할 경우 사용합니다.  단방향 외부값을 읽기전용으로 사용할려면 getter 함수만 지정합니다.   var PAGE_SIZE = 10; varc1 = new HTML Column ('c1'); // see external value  c1.getter = function(){ return PAGE_SIZE }; c1.setter = function(){ PAGE_SIZE = newVal };  c1.value; // 10  c. selector 와 setter/getter 를 같이 사용한 경우   외부값을 HTMLColumn 의 value 로 사용하면서, html 로 표현을 해야할 때 지정합니다. 원본데이터를 어디에 위치할지에 따라서 다양하게 구성할 수 있습니다.   &lt;select id=\"page-size\"&gt;     &lt;option value=\"10\"&gt;10EA&lt;/option&gt;     &lt;option value=\"20\"&gt;20EA&lt;/option&gt;     &lt;option value=\"30\"&gt;30EA&lt;/option&gt; &lt;/select&gt;   var PAGE_SIZE = 10; var c1 = new HTMLColumn('c1');  c1.selector = { key: '#page-size',  type: 'value' }; c1.getter = function(){ return PAGE_SIZE }; c1.setter = function(newVal){ PAGE_SIZE = newVal };  c1.value; // 10 $(\"#page-size\") .val(\"20\"); // select change value c2.value; // 20 PAGE_SIZE // 20   d. setFilter/getFilter 을 사용하는 경우   setter/getter와의 차이점은 내부에 사용되는값과 html 표현이 다른 경우에 사용합니다. 주로 여러개의 html 요소를 제어할 때 사용합니다.   &lt;input type=\"radio\" name=\"gender\" value=\"female\" /&gt; &lt;input type=\"radio\" name=\"gender\" value=\"male\" /&gt;   var c1 = new HTMLColumn('c1');  c1.selector = {  \tkey: 'input[name=gender][type=radio]',  type: 'value'  }; c1.getFilter = function(){ \t return $('input[name=gender]:checked').val(); }; c1.setFilter = function(newVal){ \t$('input[name=gender][value='+ newVal + ']').prop('checked', true); };  c1.value; // '' $(\"#gender\").val(\"female\"); // radio 값 변경 c2.value; // 'female'  서비스 객체를 설정   var bm = new BindModel({ \t// selector 만 사용하는 경우 \tarea_page:     { selector: { key: '#area-page',   type: 'html' } }, \ttxt_sumCnt:    { selector: { key: '#sumCnt',      type: 'text' } }, \t \t// setter/getter 를 사용한 경우 \tpage_count: { /* See page object outside */ \t\tgetter: ()=&gt; page.page_count, \t    setter: (val)=&gt; page.page_count = val; \t}, \t \t// selector &amp; setter/getter 를 사용한 경우 \tpage_size: { \t  selector: { key: 'select[name=m-page_size]',     type: 'value' }, \t  getter: ()=&gt;{ return page.page_size; }, \t  setter: (val)=&gt;{ page.page_size = val; } \t}, \t \t// selecter['none'] &amp; setFilter/getFilter 를 사용한 경우 \tactive_yn: {  \t\tselector: { key: 'input[name=m-active_yn][type=radio]',  type: 'none' }, \t    setFilter: (val)=&gt;{  \t\t    $('input[name=active_yn][value='+ val + ']').prop('checked', true); \t\t}, \t    getFilter: (val)=&gt;{  \t\t    return $('input[name=active_yn]:checked').val(); \t\t} \t  }, \t \t// selector &amp; setFilter 를 사용한 경우 (콤마 적용시), 단방향 \tpoint: {     selector: { key: '#point_view',         type: 'text' },     setFilter: function(val) { return numberWithCommas(val); }     default: 0, // Set initial value \t}, \t \t// selector &amp; getFilter 를 사용한 경우 (코드값 변환시), 단방향 \tpoint: { \t\tselector: { key: '#codeValue',           type: 'value' }, \t    getFilter: function(val) { return val == '' ? 'CODE1' : 'CODE2'; } \t}, });  ","url": "http://localhost:4000/ko/docs/api-html-column/"
  },{
    "title": "HTMLColum Class",
    "excerpt":"HTML Column is the key to binding If you directly control the internal implementation method without using a special indicator, you can apply it to various conditions when you get used to it. It is advantageous for debugging and application during development, and developer tools alone are sufficient.   We focused on recycling and minimizing duplication of code while maintaining a classic coding method.   the main structure   an inheritance relationship   Class diagram    a key element   Properties                  Item       Description                       DomType       Defines the item DOM type                 isReadOnly       Indicates whether read-only                 isHide       Indicates whether it is hidden or not                 element       represents the DOM element                 Selector       Defines a selector                 getFilter       Function to filter value                 setFilter       Function to filter value                 value       Sets or imports the value of the item                 Required       Sets whether the column value is required: ‘true’ if the value must exist, or ‘false’ if not                 Constraints       Set the constraints for the column. Constraints can be set in the form of objects or functions.                 getter       getter function of column value                 setter       setter function of column value                 columnName       Indicates the name of the column. Same as ‘_name’                 Alias       Sets or imports aliases for columns. Alias are used to transfer data and set low values                 default       Set the default value for the column                 Caption       Provides a description of the column                 _valueTypes       Defines the value type for the column. This property is used to set the value type for the column.                 _entity       Indicates the entity to which this column belongs. It is an object of type ‘BaseEntity’                 _guid       Unique identifier of the object (GUID). Uniquely identifies the object.                 _type       The generator function of the object. The function used when the object was created.                                     Method                  Item       Description                       clone(entity)       Replicates the DOM of the current item                 addConstraint (regex, msg, code, condition)       Add constraints                 Valid(value)       Checks that the value of the property is valid. Validates based on ‘required’ and ‘constructions’                 getObject(vOpt, up)       Gets the current object as a serialized object. The cyclic reference is replaced by the value ‘$ref’                 setObject(oGuid, origin)       Sets serialized object to current object.  The object is initialized.                 equal(target)       Compare the current object with the specified object.                 getTypes()       Returns the constructors of the current object and all the constructors of the prototype chain to the array.                 instanceOf(target)       Verify that the current object is an instance of the specified type (with _UNION)                                     Events                  Item       Location       Description                       OnChanged       MetaColumn       An event that occurs when the column value changes                                             Detailed description   Key Properties   domType      Define the item DOM type.    type domType = object;   isReadOnly      Indicates whether it is read-only.    type isReadOnly = boolean;   isHide      Indicates whether it is hidden or not.    type isHide = boolean;   element      Indicates the DOM element.    type element = HTMLElement;   selector      Define the selector. type         ‘value’ or ‘value’: Value property value of element     ‘text’: Text value of element     ‘html’: HTML value of element     ‘css. quick name’: property value of CSS (object)     ‘prop. fast name’: Attribute name value of element (based on initial state)     ‘Attr. fast name’: Attribute name value of element (current state)     ‘none’: No action, purpose of expression 예시: ‘value’, ‘text’, ‘css.color’, ‘prop.disabled’      type selector = { key: string, type: string };   getFilter      This function filters the value.    type getFilter = (sVal: any) =&gt; any;     sVal : This is the value obtained from selector when selector exists.   return —Filtered value.   setFilter      This function filters the value.    type setFilter = (val: any) =&gt; any | undefined;     val : The value to be applied as a filter.   return : If there is a filtering result value, set the selector value.            Do not set selector values on undefined returns.         value                      Sets or imports the value of the item.    type value = string | number | boolean;   required      Sets whether column values are required. If the value must exist, it is ‘true’, otherwise it is ‘false’.    type required = boolean;   constraints      Set the constraints for the column. Constraints can be set in the form of objects or functions.    type constraints = (object | Function)[];   getter      Getter function of column value.    type getter = () =&gt; string | number | boolean;     return : The current value of the column.   setter      Setter function of column value.    type setter = (value: string | number | boolean) =&gt; void;     value : This is the value to set.   columnName      Indicates the name of the column. Same as ‘_name’.    type columnName = string;   alias   Set or import aliases for &gt; columns, which are used to transfer data and set low values.     Where to use (default = columnName)\\         Bind-command-ajax._execBind(): When transferring data     BaseBind.setValue(row): When setting a low value to an entity     getValue(): Used for row      type alias = string;   default      Set the default value for the column.    type default = string | number | boolean;   caption      Provides a description of the column.    type caption = string;   _valueTypes      Defines the value type for the column, which is used to set the value type for the column.    type _valueTypes = any;   _entity      Indicates the entity to which this column belongs, an object of type ‘BaseEntity’.    type _entity = BaseEntity;   _guid      Unique identifier of the object (GUID). Uniquely identifies the object.    type _guid: string;  _type      The generator function of the object, which was used when the object was created.    type _type = Function;   Key Methods   clone()      Replicates the current column.    type clone = (entity: BaseEntity) =&gt; this;     entity : The entity to be replicated.   return : This is a replica of the current instance.   addConstraint()      Add constraints.    type addConstraint = ( \tregex: RegExp,  \tmsg: string,  \tcode?: string,  \tcondition?: boolean ) =&gt; void;     regex : Regular expression to apply.   msg —Message to display when regular expression fails.   code : Code for failure of regular expression. (Optional)   condition : A condition that determines whether a constraint is successful/failed. Default is ‘false’.     valid()          Check that the value of the property is valid. Validates based on ‘required’ and ‘constructions’.    type valid = (value: ValueType): object | undefined;     value : The value to be inspected.   return : Returns the object if invalid, and returns ‘undefined’ if valid.   getObject()      Obtain the current object as a guide type object. (Circular references are replaced by $ref values.)    type getObject = (vOpt?: number, owned?: object | Array&lt;object&gt;) =&gt; object;     vOpt : Import option; default is 0.            opt=0: Reference structure (_guid:Yes, $ref:Yes)       opt=1: Redundant structure (_guid:Yes, $ref:Yes)       opt=2 : Non-tidal structure (_guid: No, $ref: No)           aged : The parent objects that currently own the object. The default is an empty object.   return —Returns serialized objects.   a.getObject(2) == b.getObject(2)   setObject()      Set the Guid type object to the current object. (The object will be reset.)    type setObject = (oGuid: object, origin?: object) =&gt; void;     oGuid : Object of the guid type to serialize.   origin : This is the original object that sets the current object. The default is oGuid.   equal()      Compare the current object with the specified object.    type equal (target: object) =&gt; boolean;     return —Returns whether the two objects are identical.   getTypes()      Returns the creators of the current object and all the creators of the prototype chain to the array.    type getTypes = () =&gt; Array&lt;Function&gt;;     return : Returns the array of generator functions.   const types = obj.getTypes(); console.log(types); // [Function: MetaObject]   instanceOf()      Verify that the current object is an instance of the specified type (including _UNION)    type instanceOf = (target: object | string) =&gt; boolean;     target : The type of object to be checked (object or string).   return —Returns whether this is an instance of the specified type.   Key Events   ###      An event that occurs when the column value changes.    type onChanged = (newVal: ValueType, oldVal: ValueType, _this: this) =&gt; void;     newVal : New value.   oldVal : This is the previous value.   _this : The object that caused the event.   column.onChanged = function(newVal, oldVal, _this) { \tconsole.log('Value changed'); };   Get the value of column   우선순위 : 1. getter &gt; 2. getFilter &gt; 3. selector &gt; 4. inner value &gt; 5.default Reply the selected value according to the priority of the property (getter, getFilter, selector) setting when obtaining the column value.  getter internal structure      setting value for column   설정 순서 : 1. setter &gt; 2. inner value &gt; 3. setFilter &gt; 4. selector Set sequentially when setting the column value.   setter internal structure        If setter exists, call the setter function.   Save the setter’s return value to the inner value. If there is no return, save the input.   If setFilter is present, call the setFilter function.   If you have a selector, set the value according to the type. (Use jquery) type : value, text, html, prop, attr, css (jquey사용) (excluding type = ‘none’)     frequency of use       It analyzes the frequency of use when designing HTMLComun     Minimize duplicate code   It can be applied to various cases   Intuitive code structure It was designed with consideration.   The ‘selector’ is also a checkSelector() method used to determine the presence of an element for the html page.                  빈도       setter       setFilter       selector       getFilter       getter       설명                       89%                               ‘Use’               - Direct DOM  - For single elements  - Tag p, text, select, css                 3%       ‘Use’               ‘Use’       - When pointing to an external object  - Example&gt; page_count                                 3%       ‘Use’       ‘Use’       ‘Use’       - When using DOM with external objects  - Example&gt; page_size = page display line (select box)                                 3%               ‘Use’       ‘none’       ‘Use’       - When referring to a composite DOM object  - Selector is used for inspection only  - Example&gt; radio                         1%       ‘Use’       ‘Use’       - Show  - Example&gt; Amount (number + comma) when used in one direction                                         1%                       ‘none’       ‘use’       -  - Example&gt; Code value conversion, list selection value                    (shopping mall website, based on DB Table 36EA)  Example Code  a. When using selector   Use to select the HTML element’s property value as value. The ‘type’ of the selector is html, text, value, prop.*, attr.*, and css.*. Selector can also be used for validation in addition to value lookup/setting. Use the checkSelector() method of the BindModel object to validate the DOM.   &lt;div id=\"p-nm\"&gt;&lt;p style=\"color:red;\"&gt;10&lt;/p&gt;&lt;/div&gt; &lt;input id=\"p-title\" type=\"text\" value=\"AA\" &gt; &lt;input id=\"p-check\" type=\"checkbox\" checked /&gt; &lt;a href=\"#\"&gt;google.com&lt;/a&gt;   var c1 = new HTMLColumn('c1'); var c2 = new HTMLColumn('c2'); var c3 = new HTMLColumn('c3'); var c4 = new HTMLColumn('c4'); var c5 = new HTMLColumn('c5'); var c6 = new HTMLColumn('c6');  c1.selector = { key: '#area-nm',  type: 'html' }; c2.selector = { key: '#area-nm',  type: 'text' }; c3.selector = { key: '#p-title',  type: 'value' }; c4.selector = { key: 'p-check',   type: 'prop.checked' }; c5.selector = { key: 'a',         type: 'attr.href' }; c6.selector = { key: 'p',         type: 'css.color' };  c1.value; // &lt;p&gt;10&lt;/p&gt; c2.value; // 10 c3.value; // \"AA\" c4.value; // true c5.value; // \"google.com\" c6.value; // \"red\"   b. When using setter, getter   Use to use the external value as the value of the HTML Column.  To use unidirectional external values read-only, specify only the getter function.   var PAGE_SIZE = 10; varc1 = new HTML Column ('c1'); // see external value  c1.getter = function(){ return PAGE_SIZE }; c1.setter = function(){ PAGE_SIZE = newVal };  c1.value; // 10  c. If the selector and setter/getter are used together   Use the external value as the value of the HTML Column, and specify when you need to express it in html. Depending on where the original data is located, it can be configured in various ways.   &lt;select id=\"page-size\"&gt;     &lt;option value=\"10\"&gt;10EA&lt;/option&gt;     &lt;option value=\"20\"&gt;20EA&lt;/option&gt;     &lt;option value=\"30\"&gt;30EA&lt;/option&gt; &lt;/select&gt;   var PAGE_SIZE = 10; var c1 = new HTMLColumn('c1');  c1.selector = { key: '#page-size',  type: 'value' }; c1.getter = function(){ return PAGE_SIZE }; c1.setter = function(newVal){ PAGE_SIZE = newVal };  c1.value; // 10 $(\"#page-size\") .val(\"20\"); // select change value c2.value; // 20 PAGE_SIZE // 20   d. When using setFilter/getFilter   The difference from setter/getter is used when the html expression is different from the value used internally. Mainly used to control multiple html elements.   &lt;input type=\"radio\" name=\"gender\" value=\"female\" /&gt; &lt;input type=\"radio\" name=\"gender\" value=\"male\" /&gt;   var c1 = new HTMLColumn('c1');  c1.selector = {  \tkey: 'input[name=gender][type=radio]',  type: 'value'  }; c1.getFilter = function(){ \t return $('input[name=gender]:checked').val(); }; c1.setFilter = function(newVal){ \t$('input[name=gender][value='+ newVal + ']').prop('checked', true); };  c1.value; // '' $(\"#gender\").val(\"female\"); // radio 값 변경 c2.value; // 'female'   Set service objects   var bm = new BindModel({ \t// If using selector only \tarea_page:     { selector: { key: '#area-page',   type: 'html' } }, \ttxt_sumCnt:    { selector: { key: '#sumCnt',      type: 'text' } }, \t \t// If you used setter/getter \tpage_count: { /* See page object outside */ \t\tgetter: ()=&gt; page.page_count, \t    setter: (val)=&gt; page.page_count = val; \t}, \t \t// If selector &amp; setter/getter is used \tpage_size: { \t  selector: { key: 'select[name=m-page_size]',     type: 'value' }, \t  getter: ()=&gt;{ return page.page_size; }, \t  setter: (val)=&gt;{ page.page_size = val; } \t}, \t \t// If you used selector['none'] &amp; setFilter/getFilter \tactive_yn: {  \t\tselector: { key: 'input[name=m-active_yn][type=radio]',  type: 'none' }, \t    setFilter: (val)=&gt;{  \t\t    $('input[name=active_yn][value='+ val + ']').prop('checked', true); \t\t}, \t    getFilter: (val)=&gt;{  \t\t    return $('input[name=active_yn]:checked').val(); \t\t} \t  }, \t \t// If selector &amp; setfilter is used (for comma application), one-way \tpoint: {     selector: { key: '#point_view',         type: 'text' },     setFilter: function(val) { return numberWithCommas(val); }     default: 0, // Set initial value \t}, \t \t// When using selector &amp; getFilter (when converting code values), one-way \tpoint: { \t\tselector: { key: '#codeValue',           type: 'value' }, \t    getFilter: function(val) { return val == '' ? 'CODE1' : 'CODE2'; } \t}, });  ","url": "http://localhost:4000/en/docs/api-html-column/"
  },{
    "title": "MetaTable Class",
    "excerpt":"# the main structure  ## Property Relationships  Class diagram ![image-center](/assets/images/tbl-rel-diagram-2024-08-16-002427.png){: .align-center}   'MetaTable' is similar to the structure and usage of the 'DataTable' class in the .NET framework   ## an inheritance relationship  Class diagram ![image-center](/assets/images/tbl-diagram-2024-08-16-002504.png){: .align-center}  # a key element  ## Properties  | Item | Description | | --------- | ------------------------------------- | | tableName | This property represents the name of the table | | columns | contains all columns in the item (attribute) collection table for this entity | | rows | Data (low) collection of entities | _metaSet | MetaSet to which the entity belongs. | | _guid | Unique identifier of the object (GUID). Uniquely identifies the object. | | _type | The generator function of the object. The function used when the object was created. | |           |                                       |     ## Method  | Item | Description | | -------------------------------- | ------------------------------------------------------ | | clone() | Create and return a deep copy of the current object | | copy(filter, args) | Copy the destination column | acceptChanges() | Commit all changes to the current object. Allow changes: commit | | rejectChanges() | Rollback all changes to the current object. Cancel changes: rollback | | getChanges() | Returns a list of changes to the current object | | transformSchema() | Converts a given serialization object to a schema object | Clear() | Initializes all data in the entity | reset() | Initializes the entity's columns and data | NewRow() | Returns a new row that matches the column structure | getValue() | Returns the value of the column as a MetaRow type object | | setValue(row) | Set the MetaRow value to the value of the column | merge (target, optoin, matchType) | merge the given entity with the current entity | | select(filter, args) | query the row according to the given callback function | | load(obj, path) | Gets the given object into the current entity. Initializes the existing data and loads the new data | output (Vopt, stringify, space) | Outputs the current entity as a serialized string | read(obj, option) | Reads the given object as an entity. Follow JSON schema rules. | | readSchema (obj, createRow) | Reads the given schema object as the current entity | readData(obj) | Reads only rows that exist on a given object | | write(vOpt) | Returns the current entity by converting it to an object of schema type | | writeSchema(vOpt) | Returns the schema of the current entity by converting it to an object of schema type | | writeData(vOpt) | Returns data from the current entity by converting it into schema-type objects.  # Detailed description  ## Key Properties  ### tableName  > Indicates the name of the table.  ```ts type tableName = string; ```  ### columns  > Collection of columns in the table.  ```ts type columns = MetaTableColumnCollection; ```  ### rows  > Data (low) collection of tables.  ```ts type rows = MetaRowCollection; ```  ### \\_metaSet  > This is the meta set to which the table belongs.  ```ts type _metaSet = MetaSet; ```  ### \\_guid  > Unique identifier of the object (GUID). Uniquely identifies the object.  ```ts type _guid = string; ```  ### \\_type  > The generator function of the object, which was used when the object was created.  ```ts type _type = Function; ``` ## Key Methods  ### clone()  > Create and return a deep copy of the current object.  ```ts type clone = () => MetaTable; ``` - return : This is a replica of the current object.  ### copy()  > Copy the target column.  ```ts type copy = ( \tfilter: (row, idx, entity) => boolean | string[], arguments,  \tcols?: string[] | arguments ) => MetaTable; ``` - filter :    \t- Function type is the callback function that selects the column. \t-  Type string[] is the name of the column to copy. -   cols : The name of the column to copy, valid only if the filter is a Function type.  Example: Using filter, cols ```js var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t(row, idx, entity) => { return (idx % 2) > 0; }, \t['aa', 'bb'] ); ``` - Temp is copied only if the row indexes of the columns 'aa' and 'bbb' are odd.  Example: Using cols only ```js var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t['aa', 'bb'] ); ``` - Temp copies the entire row of columns 'aa' and 'bbb'.  ### acceptChanges()  > Commit all changes to the current object. > Allow changes: commit  ```ts type acceptChanges = () => void; ```  ### rejectChanges()  > Rolls back all changes to the current object. > Cancel changes: rollback  ```ts type rejectChanges = () => void; ```  ### getChanges()  > Returns a list of changes to the current object.  ```ts type getChanges = () => object[]; ``` - return : This is the changed list. ### transformSchema()  > Converts a given serialization object to a schema object.  ```ts type transformSchema = (oGuid: object) => object; // static ``` - oGuid : object obtained by getObject().  ### clear()  > Initializes all data in the entity.  ```ts type clear = () => void; ```  ### reset()  > Initializes the entity's columns and data.  ```ts type reset = () => void; ```  ### newRow()  > Create and return a new row that matches the column structure.  ```ts type newRow = () => MetaRow; ``` - return : This is the MetaRow object created. ### getValue()  Returns the value of the > column as a MetaRow type object.  ```ts type getValue = () => MetaRow; ``` - return : MetaRow object with the value of the column set.  ### setValue()  > Set the MetaRow value to the value in the column.  ```ts type setValue = (row: MetaRow) => void; ``` - row : MetaRow object to be set.  ### merge()  > Merges the given entity with the current entity.  ```ts type merge = (target: BaseEntity, option: number, matchType?: boolean) => void; ``` - target : The target entity to merge. - option : Merge option. - matchType : Whether or not a row validation exists. (Default: false)  ### select()  > Look up the row according to the given callback function.  ```ts type select = ( \tfilter: (row, idx, entity) => boolean | string[], | arguments, \tcols?: string[] | arguments ) => MetaView; ``` - filter :    \t- Function type is the callback function that selects the column. \t-  Type string[] is the name of the column to copy. -   cols : The name of the column to copy, valid only if the filter is a Function type.  Example: Using filter, cols ```js var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows var temp = table.copy( \t(row, idx, entity) => { return (idx % 2) > 0; }, \t['aa', 'bb'] ); ``` - The temp view is copied only if the row indexes of the columns 'aa', 'bbb' are odd.  Example: Using cols only ```js var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t['aa', 'bb'] ); ``` - The temp view copies the entire row of columns 'aa' and 'bbb'.   ### load()  > Imports the given object to the current entity, initializes the existing data and loads the new data.  ```ts type load = (obj: object | string, parse?: Function) => void; ``` - obj : The object to be called. - pas : parser function. (Optional)  ### output()  > Outputs the current entity as a serialized string.  ```ts type output = (vOpt: number, stringify?: Function, space?: string) => string; ``` - vOpt : Optional (0, 1, 2) - stringify : This is a user-defined parser function. (Optional) - space : A blank string to be used in the output. (Optional)  ### read()  > Reads the given object as an entity. Follow JSON schema rules.  ```ts type read = (obj: object, option: number) => void; ``` - obj : object to be read. - option : Read option (default: 3)  ```js var schema1 = {  \ttable: {  \t\tcolumns: {},  \t\trows: {}  \t} };  var schema1 = {  \tcolumns: {...},  \trows: {}  }; ``` ### readSchema()  > Reads the given schema object as the current entity.  ```ts type readSchema = (obj: object, createRow?: boolean) => void; ``` - obj : Schema object to be read. - createRow : If true, add the column by row[0] (default: false)  ### readData()  > Reads only rows that exist on a given object.  ```ts type readData = (obj: object) => void; ``` - obj : The object to be read.  ### write()  > Returns the current entity after converting it to an object of schema type.  ```ts type write = (vOpt?: number) => object; ``` - vOpt : Optional (default: 0) - return : Object of schema type.  ### writeSchema()  > Returns the schema of the current entity by converting it to an object of schema type.  ```ts type writeData = (vOpt?: number): object; ``` - vOpt : Optional (default: 0) - return : Object of schema type.  ### writeData()  > Returns the data of the current entity by converting it into an object of schema type.  ```ts type writeData = (vOpt?: number) => object; ``` - vOpt : Optional (default: 0) - return : Object of schema type.  ### getObject()  > Obtain the current object as a guide type object. > (Circular references are replaced by $ref values.)  ```ts type getObject = (vOpt?: number, owned?: object | Array) => object; ``` - vOpt : Import option; default is 0. \t- opt=0: Reference structure (_guid:Yes, $ref:Yes) \t* opt=1: Redundant structure (_guid:Yes, $ref:Yes) \t* opt=2 : Non-tidal structure (_guid: No, $ref: No) - aged : The parent objects that currently own the object. The default is an empty object. - return —Returns serialized objects.  ```js a.getObject(2) == b.getObject(2) ```  ### setObject()  > Set the Guid type object to the current object. > (The object will be reset.)  ```ts type setObject = (oGuid: object, origin?: object) => void; ``` - oGuid : Object of the guid type to serialize. - origin : This is the original object that sets the current object. The default is oGuid.  ### equal()  > Compare the current object with the specified object.  ```ts type equal = (target: object) => boolean; ``` - return —Returns whether the two objects are identical.  ### getTypes()  > Returns the creators of the current object and all the creators of the prototype chain to the array.  ```ts type getTypes = () => Array; ``` - return : Returns the array of generator functions.  ```js const types = obj.getTypes(); console.log(types); // [Function: MetaObject] ```  ### instanceOf()  > Verify that the current object is an instance of the specified type (including _UNION)  ```ts type instanceOf = (target: object | string) => boolean; ``` - target : The type of object to be checked (object or string). - return —Returns whether this is an instance of the specified type.","url": "http://localhost:4000/en/docs/api-meta-table/"
  },{
    "title": "MetaTable 클래스",
    "excerpt":"# 주요 구조  ## 속성 관계  Class diagram ![image-center](/assets/images/tbl-rel-diagram-2024-08-16-002427.png){: .align-center}  `MetaTable` 은 .NET 프레임웍의 `DataTable` 클래스의  구조와 사용법이 흡사합니다  ## 상속 관계  Class diagram ![image-center](/assets/images/tbl-diagram-2024-08-16-002504.png){: .align-center}  # 주요 요소  ## 속성  | 항목        | 설명                                    | | --------- | ------------------------------------- | | tableName | 이 속성은 테이블의 이름을 나타냅니다.                 | | columns   | 이 엔티티의 아이템(속성) 컬렉션 테이블의 모든 컬럼을 포함합니다. | | rows      | 엔티티의 데이터(로우) 컬렉션 입니다.                 | | _metaSet  | 엔티티가 소속되어 있는 메테셋 입니다.                 | | _guid     | 객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다.    | | _type     | 객체의 생성자 함수. 객체가 생성될 때 사용된 함수입니다.      | |           |                                       |   ---  ## 메소드  | 항목                               | 설명                                                     | | -------------------------------- | ------------------------------------------------------ | | clone()                          | 현재 객체의 깊은 복사본을 생성하여 반환합니다.                             | | copy(filter, args)               | 대상 컬럼을 복사한다.                                           | | acceptChanges()                  | 현재 객체에 대한 모든 변경 사항을 커밋합니다. 변경사항 허락 : commit            | | rejectChanges()                  | 현재 객체에 대한 모든 변경 사항을 롤백합니다. 변경사항 취소 : rollback          | | getChanges()                     | 현재 객체에 대한 변경 사항 목록을 반환합니다.                             | | transformSchema()                | 주어진 직렬화 객체를 스키마 객체로 변환합니다.                             | | clear()                          | 엔티티의 모든 데이터를 초기화합니다.                                   | | reset()                          | 엔티티의 컬럼 및 데이터를 초기화합니다.                                 | | newRow()                         | 컬럼 구조에 맞는 새로운 로우를 생성하여 반환합니다.                          | | getValue()                       | 컬럼의 value 값을 MetaRow 타입 객체로 반환합니다.                     | | setValue(row)                    | MetaRow 값을 컬럼의 value에 설정합니다.                           | | merge(target, optoin, matchType) | 주어진 엔티티와 현재 엔티티를 병합합니다.                                | | select(filter, args)             | 주어진 콜백 함수에 따라 로우를 조회합니다.                               | | load(obj, parse)                 | 주어진 객체를 현재 엔티티로 불러옵니다. 기존 데이터를 초기화하고 새로운 데이터를 로드합니다.   | | output(Vopt, stringify, space)   | 현재 엔티티를 직렬화된 문자열로 출력합니다.                               | | read(obj, option)                | 주어진 객체를 엔티티로 읽어옵니다. JSON 스키마 규칙을 따릅니다.                 | | readSchema(obj, createRow)       | 주어진 스키마 객체를 현재 엔티티로 읽어옵니다.                             | | readData(obj)                    | 주어진 객체에서 존재하는 로우만 읽어옵니다.                               | | write(vOpt)                      | 현재 엔티티를 스키마 타입의 객체로 변환하여 반환합니다.                        | | writeSchema(vOpt)                | 현재 엔티티의 스키마를 스키마 타입의 객체로 변환하여 반환합니다.                   | | writeData(vOpt)                  | 현재 엔티티의 데이터를 스키마 타입의 객체로 변환하여 반환합니다.                   | | getObject(vOpt, owned)           | 객체를 특정 옵션에 따라 직렬화된 형태로 반환합니다. 순환 참조는 `$ref` 값으로 대체됩니다. | | setObject(oGuid, origin)         | 주어진 직렬화된 객체를 현재 객체에 반영합니다. 이 작업은 객체를 초기화합니다.           | | equal(target)                    | 현재 객체와 지정된 객체가 동일한지 비교합니다.                             | | getTypes()                       | 현재 객체의 생성자와 프로토타입 체인의 모든 생성자를 배열로 반환합니다.               | | instanceOf(target)               | 현재 객체가 지정된 타입의 인스턴스인지 확인합니다. (_UNION 포함)               |   # 세부 설명  ## 주요 속성  ### tableName  > 테이블의 이름을 나타냅니다.  ```ts type tableName = string; ```  ### columns  > 테이블의 컬럼 컬렉션 입니다.  ```ts type columns = MetaTableColumnCollection; ```  ### rows  > 테이블의  데이터(로우) 컬렉션 입니다.  ```ts type rows = MetaRowCollection; ```  ### \\_metaSet  > 테이블이 소속되어 있는 메타셋 입니다.  ```ts type _metaSet = MetaSet; ```  ### \\_guid  > 객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다.  ```ts type _guid = string; ```  ### \\_type  > 객체의 생성자 함수입니다. 객체가 생성될 때 사용된 함수입니다.  ```ts type _type = Function; ```    --- ## 주요 메소드  ### clone()  > 현재 객체의 깊은 복사본을 생성하여 반환합니다.  ```ts type clone = () => \bMetaTable; ``` - return : 현재 객체의 복제본입니다.  ### copy()  > 대상 컬럼을 복사한다.  ```ts type copy = ( \tfilter: (row, idx, entity) => boolean | string[], arguments,  \tcols?: string[] | arguments ) => MetaTable; ``` - filter :    \t- Function  타입이면 컬럼을 선택하는 콜백함수를 입니다. \t-  string[]   타입이면 복사할 컬럼명입니다. -   cols : 복사할 컬럼명입니다. filter 가 Function 타입일 때만 유효합니다.  #### 예제 : filter, cols 을 사용하는 경우 ```js var table = new MetaTable('t1');  // ... 컬럼 추가, aa, bb, cc, ee 및 rows 추가   var temp = table.copy( \t(row, idx, entity) => { return (idx % 2) > 0; }, \t['aa', 'bb'] ); ``` - temp 에는 'aa', 'bb' 컬럼의 로우 인덱스가 홀수인 경우만 복사됩니다.  #### 예제 : cols 만 사용하는 경우 ```js var table = new MetaTable('t1');  // ... 컬럼 추가, aa, bb, cc, ee 및 rows 추가   var temp = table.copy( \t['aa', 'bb'] ); ``` - temp 에는 'aa', 'bb' 컬럼의 전체 로우가 복사됩니다.  ### acceptChanges()  > 현재 객체에 대한 모든 변경 사항을 커밋합니다. > 변경사항 허락 : commit  ```ts type acceptChanges = () => void; ```  ### rejectChanges()  > 현재 객체에 대한 모든 변경 사항을 롤백합니다. > 변경사항 취소 : rollback  ```ts type rejectChanges = () => void; ```  ### getChanges()  > 현재 객체에 대한 변경 사항 목록을 반환합니다.  ```ts type getChanges = () => object[]; ``` - return : 변경된 목록입니다.  ### transformSchema()  > 주어진 직렬화 객체를 스키마 객체로 변환합니다.  ```ts type transformSchema = (oGuid: object) => object; // static ``` - oGuid : getObject()로 얻은 객체입니다.  ### clear()  > 엔티티의 모든 데이터를 초기화합니다.  ```ts type clear = () => void; ```  ### reset()  > 엔티티의 컬럼 및 데이터를 초기화합니다.  ```ts type reset = () => void; ```  ### newRow()  > 컬럼 구조에 맞는 새로운 로우를 생성하여 반환합니다.  ```ts type newRow = () => MetaRow; ``` - return : 생성된 MetaRow 객체입니다. ### getValue()  > 컬럼의 value 값을 MetaRow 타입 객체로 반환합니다.  ```ts type getValue = () => MetaRow; ``` - return : 컬럼의 값이 설정된 MetaRow 객체입니다.  ### setValue()  > MetaRow 값을 컬럼의 value에 설정합니다.  ```ts type setValue = (row: MetaRow) => void; ``` - row : 설정할 MetaRow 객체입니다.  ### merge()  > 주어진 엔티티와 현재 엔티티를 병합합니다.  ```ts type merge = (target: BaseEntity, option: number, matchType?: boolean) => void; ``` - target : 병합할 대상 엔티티입니다. - option : 병합 옵션입니다. - matchType : 로우 유효성 검사 유무입니다. (기본값: false)  ### select()  > 주어진 콜백 함수에 따라 로우를 조회합니다.  ```ts type select = ( \tfilter: (row, idx, entity) => boolean | string[], | arguments, \tcols?: string[] | arguments ) => MetaView; ``` - filter :    \t- Function  타입이면 컬럼을 선택하는 콜백함수를 입니다. \t-  string[]   타입이면 복사할 컬럼명입니다. -   cols : 복사할 컬럼명입니다. filter 가 Function 타입일 때만 유효합니다.  #### 예제 : filter, cols 을 사용하는 경우 ```js var table = new MetaTable('t1');  // ... 컬럼 추가, aa, bb, cc, ee 및 rows 추가   var temp = table.copy( \t(row, idx, entity) => { return (idx % 2) > 0; }, \t['aa', 'bb'] ); ``` - temp 뷰 에는 'aa', 'bb' 컬럼의 로우 인덱스가 홀수인 경우만 복사됩니다.  #### 예제 : cols 만 사용하는 경우 ```js var table = new MetaTable('t1');  // ... 컬럼 추가, aa, bb, cc, ee 및 rows 추가   var temp = table.copy( \t['aa', 'bb'] ); ``` - temp 뷰 에는 'aa', 'bb' 컬럼의 전체 로우가 복사됩니다.   ### load()  > 주어진 객체를 현재 엔티티로 불러옵니다. 기존 데이터를 초기화하고 새로운 데이터를 로드합니다.  ```ts type load = (obj: object | string, parse?: Function) => void; ``` - obj : 불러올 대상 객체입니다. - parse : 파서 함수입니다. (선택)  ### output()  > 현재 엔티티를 직렬화된 문자열로 출력합니다.  ```ts type output = (vOpt: number, stringify?: Function, space?: string) => string; ``` - vOpt : 옵션입니다. (0, 1, 2) - stringify : 사용자 정의 파서 함수입니다. (옵션) - space : 출력 시 사용할 공백 문자열입니다. (옵션)  ### read()  > 주어진 객체를 엔티티로 읽어옵니다. JSON 스키마 규칙을 따릅니다.  ```ts type read = (obj: object, option: number) => void; ``` - obj : 읽어올 대상 객체입니다. - option : 읽기 옵션입니다. (기본값: 3)  ```js var schema1 = {  \ttable: {  \t\tcolumns: {},  \t\trows: {}  \t} };  var schema1 = {  \tcolumns: {...},  \trows: {}  }; ```  ### readSchema()  > 주어진 스키마 객체를 현재 엔티티로 읽어옵니다.  ```ts type readSchema = (obj: object, createRow?: boolean) => void; ``` - obj : 읽어올 스키마 객체입니다. - createRow : true일 경우, row[0] 기준으로 컬럼을 추가합니다. (기본값: false)  ### readData()  > 주어진 객체에서 존재하는 로우만 읽어옵니다.  ```ts type readData = (obj: object) => void; ``` - obj : 읽어올 객체입니다.  ### write()  > 현재 엔티티를 스키마 타입의 객체로 변환하여 반환합니다.  ```ts type write = (vOpt?: number) => object; ``` - vOpt : 옵션입니다. (기본값: 0) - return : 스키마 타입의 객체입니다.  ### writeSchema()  > 현재 엔티티의 스키마를 스키마 타입의 객체로 변환하여 반환합니다.  ```ts type writeData = (vOpt?: number): object; ``` - vOpt : 옵션입니다. (기본값: 0) - return : 스키마 타입의 객체입니다.  ### writeData()  > 현재 엔티티의 데이터를 스키마 타입의 객체로 변환하여 반환합니다.  ```ts type writeData = (vOpt?: number) => object; ``` - vOpt : 옵션입니다. (기본값: 0) - return : 스키마 타입의 객체입니다.  ### getObject()  > 현재 객체를 직렬화(guid 타입) 객체로 얻습니다. > (순환참조는 $ref 값으로 대체됩니다.)  ```ts type getObject = (vOpt?: number, owned?: object | Array) => object; ``` - vOpt :  가져오기 옵션입니다. 기본값은 0 입니다. \t- opt=0 : 참조 구조(_guid:Yes, $ref:Yes) \t* opt=1 : 중복 구조(_guid:Yes, $ref:Yes) \t* opt=2 : 비참조 구조(_guid:No, $ref:No) - owned : 현재 객체를 소유하는 상위 객체들입니다. 기본값은 빈객체 입니다. - return : 직렬화된 객체를 반환합니다.  ```js a.getObject(2) == b.getObject(2) ```  ### setObject()  > 직렬화(guid 타입) 객체를 현재 객체에 설정합니다. > (객체는 초기화 됩니다.)  ```ts type setObject = (oGuid: object, origin?: object) => void; ``` - oGuid : 직렬화할 guid 타입의 객체입니다. - origin : 현재 객체를 설정하는 원본 객체입니다. 기본값은 oGuid 입니다.  ### equal()  > 현재 객체와 지정된 객체가 동일한지 비교합니다.  ```ts type equal = (target: object) => boolean; ``` - return : 두 객체가 동일한지 여부를 반환합니다.  ### getTypes()  > 현재 객체의 생성자와 프로토타입 체인의 모든 생성자를 배열로 반환합니다.  ```ts type getTypes = () => Array; ``` - return : 생성자 함수의 배열을 반환합니다.  ```js const types = obj.getTypes(); console.log(types); // [Function: MetaObject] ```  ### instanceOf()  > 현재 객체가 지정된 타입의 인스턴스인지 확인합니다. (_UNION 포함)  ```ts type instanceOf = (target: object | string) => boolean; ``` - target : 확인할 대상 타입 (객체 또는 문자열)입니다. - return : 지정된 타입의 인스턴스인지 여부를 반환합니다. ","url": "http://localhost:4000/ko/docs/api-meta-table/"
  },{
    "title": "MetaView 클래스",
    "excerpt":"# 주요 구조  ## 속성 관계  MetaView 는 MetaTable 과 동일하게 작동됩니다.   차이점은  *_baseEntity* 가 지정될 경우 *add(name)* 컬럼을 추가하면, `columns` 에는 참조가 등록되고,  baseEntity 의 `columns` 에  `MetaColumn` 이 등록됩니다. *add(name, collection?)* 컬럼 추가시 `collection` 을 지정하면, `columns` 에\u001f참조가 등록되고, 지정한 `collecton` 에 `MetaColumn` 이 등록됩니다.  Class diagram ![image-center](/assets/images/view-rel-diagram-2024-08-16-002546.png){: .align-center}  ## 상속 관계  Class diagram ![image-center](/assets/images/view-diagram-2024-08-16-004628.png){: .align-center}  # 주요 요소  ## 속성  | 항목          | 설명                                   | | ----------- | ------------------------------------ | | viewName    | 메타 뷰 이름 입니다.                         | | columns     | 뷰의 컬럼 컬렉션 입니다.                       | | rows        | 엔티티의 데이터(로우) 컬렉션 입니다.                | | _baseEntity | 기본 엔티티 입니다.                          | | _metaSet    | 엔티티가 소속되어 있는 메타셋 입니다.                | | _name       | 요소의 이름. MetaElement의 고유 식별자 역할을 합니다. | | _guid       | 객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다.   | | _type       | 객체의 생성자 함수. 객체가 생성될 때 사용된 함수입니다.     | |             |                                      |   ---  ## 메소드  | 항목                               | 설명                                                   | | -------------------------------- | ---------------------------------------------------- | | clone()                          | 현재 메타 뷰의 깊은 복사본을 생성하여 반환합니다.                         | | copy(filter, args)               | 대상 컬럼을 복사한다.                                         | | transformSchema()                | 주어진 직렬화 객체를 스키마 객체로 변환합니다.                           | | clear()                          | 엔티티의 모든 데이터를 초기화합니다.                                 | | reset()                          | 엔티티의 컬럼 및 데이터를 초기화합니다.                               | | newRow()                         | 컬럼 구조에 맞는 새로운 로우를 생성하여 반환합니다.                        | | getValue()                       | 컬럼의 value 값을 MetaRow 타입 객체로 반환합니다.                   | | setValue(row)                    | MetaRow 값을 컬럼의 value에 설정합니다.                         | | merge(target, optoin, matchType) | 주어진 엔티티와 현재 엔티티를 병합합니다.                              | | select(filter, args)             | 주어진 콜백 함수에 따라 로우를 조회합니다.                             | | load(obj, parse)                 | 주어진 객체를 현재 엔티티로 불러옵니다. 기존 데이터를 초기화하고 새로운 데이터를 로드합니다. | | output(vOpt, stringify, space)   | 현재 엔티티를 직렬화된 문자열로 출력합니다.                             | | read(obj, option)                | 주어진 객체를 엔티티로 읽어옵니다. JSON 스키마 규칙을 따릅니다.               | | readSchema(obj, createRow)       | 주어진 스키마 객체를 현재 엔티티로 읽어옵니다.                           | | readData(obj)                    | 주어진 객체에서 존재하는 로우만 읽어옵니다.                             | | write(vOpt)                      | 현재 엔티티를 스키마 타입의 객체로 변환하여 반환합니다.                      | | writeSchema(vOpt)                | 현재 엔티티의 스키마를 스키마 타입의 객체로 변환하여 반환합니다.                 | | writeData(vOpt)                  | 현재 엔티티의 데이터를 스키마 타입의 객체로 변환하여 반환합니다.                 | | getObject(vOpt, owned)           | 객체를 특정 옵션에 따라 직렬화된 형태로 반환합니다. 순환 참조는 $ref 값으로 대체됩니다. | | setObject(oGuid, origin)         | 주어진 직렬화 객체를 현재 객체로 설정합니다. 설정 시 기존 객체는 초기화됩니다.        | | equal(target)                    | 현재 객체와 지정된 객체가 동일한지 비교합니다.                           | | getTypes()                       | 현재 객체의 생성자와 프로토타입 체인의 모든 생성자를 배열로 반환합니다.             | | instanceOf(target)               | 현재 객체가 지정된 타입의 인스턴스인지 확인합니다. (_UNION 포함)             |    # 세부 설명  ## 주요 속성  ### viewName  > 메타 뷰 이름 입니다.  ```ts type viewName = string; ```  ### columns  > 뷰의 컬럼 컬렉션 입니다.  ```ts type columns = MetaTableColumnCollection; ```  ### rows  > 테이블의  데이터(로우) 컬렉션 입니다.  ```ts type rows = MetaRowCollection; ```  ### \\_baseEntity  > 기본 엔티티 입니다.  ```ts type _baseEntity = BaseEntity; ```  ### \\_metaSet  > 테이블이 소속되어 있는 메타셋 입니다.  ```ts type _metaSet = MetaSet; ```  ### \\_guid  > 객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다.  ```ts type _guid: string; ```  ### \\_type  > 객체의 생성자 함수입니다. 객체가 생성될 때 사용된 함수입니다.  ```ts type _type: Function; ```  --- ## 주요 메소드  ### clone()  > 현재 객체의 깊은 복사본을 생성하여 반환합니다.  ```ts type clone() => \bMetaTable; ``` - return : 현재 객체의 복제본입니다.  ### copy()  > 대상 컬럼을 복사한다.  ```ts type copy = ( \tfilter: (row, idx, entity) => boolean | string[], arguments,  \tcols?: string[] | arguments ) => MetaView; ``` - filter :    \t- Function  타입이면 컬럼을 선택하는 콜백함수를 입니다. \t-  string[]   타입이면 복사할 컬럼명입니다. -   cols : 복사할 컬럼명입니다. filter 가 Function 타입일 때만 유효합니다. #### 예제 : filter, cols 을 사용하는 경우 ```js var table = new MetaTable('t1');  // ... 컬럼 추가, aa, bb, cc, ee 및 rows 추가   var temp = table.copy( \t(row, idx, entity) => { return (idx % 2) > 0; }, \t['aa', 'bb'] ); ``` - temp 에는 'aa', 'bb' 컬럼의 로우 인덱스가 홀수인 경우만 복사됩니다. #### 예제 : cols 만 사용하는 경우 ```js var table = new MetaTable('t1');  // ... 컬럼 추가, aa, bb, cc, ee 및 rows 추가   var temp = table.copy( \t['aa', 'bb'] ); ``` - temp 에는 'aa', 'bb' 컬럼의 전체 로우가 복사됩니다.  ### transformSchema()  > 주어진 직렬화 객체를 스키마 객체로 변환합니다.  ```ts type transformSchema = (oGuid: object) => object; // static ``` - oGuid : getObject()로 얻은 객체입니다.  ### clear()  > 엔티티의 모든 데이터를 초기화합니다.  ```ts type clear = () => void; ```  ### reset()  > 엔티티의 컬럼 및 데이터를 초기화합니다.  ```ts type reset = () => void; ```  ### newRow()  > 컬럼 구조에 맞는 새로운 로우를 생성하여 반환합니다.  ```ts type newRow = () => MetaRow; ``` - return : 생성된 MetaRow 객체입니다. ### getValue()  > 컬럼의 value 값을 MetaRow 타입 객체로 반환합니다.  ```ts type getValue = () => MetaRow; ``` - return : 컬럼의 값이 설정된 MetaRow 객체입니다.  ### setValue()  > MetaRow 값을 컬럼의 value에 설정합니다.  ```ts type setValue = (row: MetaRow) => void; ``` - row : 설정할 MetaRow 객체입니다.  ### merge()  > 주어진 엔티티와 현재 엔티티를 병합합니다.  ```ts type merge = (target: BaseEntity, option: number, matchType?: boolean) => void; ``` - target : 병합할 대상 엔티티입니다. - option : 병합 옵션입니다. - matchType : 로우 유효성 검사 유무입니다. (기본값: false)  ### select()  > 주어진 콜백 함수에 따라 로우를 조회합니다.  ```ts type select = ( \tfilter: (row, idx, entity) => boolean | string[], | arguments, \tcols?: string[] | arguments ) => MetaView; ``` - filter :    \t- Function  타입이면 컬럼을 선택하는 콜백함수를 입니다. \t-  string[]   타입이면 복사할 컬럼명입니다. -   cols : 복사할 컬럼명입니다. filter 가 Function 타입일 때만 유효합니다. #### 예제 : filter, cols 을 사용하는 경우 ```js var table = new MetaTable('t1');  // ... 컬럼 추가, aa, bb, cc, ee 및 rows 추가   var temp = table.copy( \t(row, idx, entity) => { return (idx % 2) > 0; }, \t['aa', 'bb'] ); ``` - temp 뷰 에는 'aa', 'bb' 컬럼의 로우 인덱스가 홀수인 경우만 복사됩니다. #### 예제 : cols 만 사용하는 경우 ```js var table = new MetaTable('t1');  // ... 컬럼 추가, aa, bb, cc, ee 및 rows 추가   var temp = table.copy( \t['aa', 'bb'] ); ``` - temp 뷰 에는 'aa', 'bb' 컬럼의 전체 로우가 복사됩니다.  ### load()  > 주어진 객체를 현재 엔티티로 불러옵니다. 기존 데이터를 초기화하고 새로운 데이터를 로드합니다.  ```ts type load = (obj: object | string, parse?: Function) => void; ``` - obj : 불러올 대상 객체입니다. - parse : 파서 함수입니다. (선택)  ### output()  > 현재 엔티티를 직렬화된 문자열로 출력합니다.  ```ts type output = (vOpt: number, stringify?: Function, space?: string) => string; ``` - vOpt : 옵션입니다. (0, 1, 2) - stringify : 사용자 정의 파서 함수입니다. (옵션) - space : 출력 시 사용할 공백 문자열입니다. (옵션)  ### read()  > 주어진 객체를 엔티티로 읽어옵니다. JSON 스키마 규칙을 따릅니다.  ```ts type read = (obj: object, option: number) => void; ``` - obj : 읽어올 대상 객체입니다. - option : 읽기 옵션입니다. (기본값: 3)  ```js var schema1 = {  \ttable: {  \t\tcolumns: {},  \t\trows: {}  \t} };  var schema1 = {  \tcolumns: {...},  \trows: {}  }; ```  ### readSchema()  > 주어진 스키마 객체를 현재 엔티티로 읽어옵니다.  ```ts type readSchema = (obj: object, createRow?: boolean) => void; ``` - obj : 읽어올 스키마 객체입니다. - createRow : true일 경우, row[0] 기준으로 컬럼을 추가합니다. (기본값: false)  ### readData()  > 주어진 객체에서 존재하는 로우만 읽어옵니다.  ```ts type readData = (obj: object) => void; ``` - obj : 읽어올 객체입니다.  ### write()  > 현재 엔티티를 스키마 타입의 객체로 변환하여 반환합니다.  ```ts type write = (vOpt?: number) => object; ``` - vOpt : 옵션입니다. (기본값: 0) - return : 스키마 타입의 객체입니다.  ### writeSchema()  > 현재 엔티티의 스키마를 스키마 타입의 객체로 변환하여 반환합니다.  ```ts type writeData = (vOpt?: number): object; ``` - vOpt : 옵션입니다. (기본값: 0) - return : 스키마 타입의 객체입니다.  ### writeData()  > 현재 엔티티의 데이터를 스키마 타입의 객체로 변환하여 반환합니다.  ```ts type writeData = (vOpt?: number) => object; ``` - vOpt : 옵션입니다. (기본값: 0) - return : 스키마 타입의 객체입니다.  ### getObject()  > 현재 객체를 직렬화(guid 타입) 객체로 얻습니다. > (순환참조는 $ref 값으로 대체됩니다.)  ```ts type getObject = (vOpt?: number, owned?: object | Array) => object; ``` - vOpt :  가져오기 옵션입니다. 기본값은 0 입니다. \t- opt=0 : 참조 구조(_guid:Yes, $ref:Yes) \t* opt=1 : 중복 구조(_guid:Yes, $ref:Yes) \t* opt=2 : 비참조 구조(_guid:No, $ref:No) - owned : 현재 객체를 소유하는 상위 객체들입니다. 기본값은 빈객체 입니다. - return : 직렬화된 객체를 반환합니다.  ```js a.getObject(2) == b.getObject(2) ```  ### setObject()  > 직렬화(guid 타입) 객체를 현재 객체에 설정합니다. > (객체는 초기화 됩니다.)  ```ts type setObject = (oGuid: object, origin?: object) => void; ``` - oGuid : 직렬화할 guid 타입의 객체입니다. - origin : 현재 객체를 설정하는 원본 객체입니다. 기본값은 oGuid 입니다.  ### equal()  > 현재 객체와 지정된 객체가 동일한지 비교합니다.  ```ts type equal (target: object) => boolean; ``` - return : 두 객체가 동일한지 여부를 반환합니다.  ### getTypes()  > 현재 객체의 생성자와 프로토타입 체인의 모든 생성자를 배열로 반환합니다.  ```ts type getTypes = () => Array; ``` - return : 생성자 함수의 배열을 반환합니다.  ```js const types = obj.getTypes(); console.log(types); // [Function: MetaObject] ```  ### instanceOf()  > 현재 객체가 지정된 타입의 인스턴스인지 확인합니다. (_UNION 포함)  ```ts type instanceOf = (target: object | string) => boolean; ``` - target : 확인할 대상 타입 (객체 또는 문자열)입니다. - return : 지정된 타입의 인스턴스인지 여부를 반환합니다.  ","url": "http://localhost:4000/ko/docs/api-meta-view/"
  },{
    "title": "MetaView Class",
    "excerpt":"# the main structure  ## Property Relationships  MetaView operates the same as MetaTable.   The difference is that if *_baseEntity* is specified, if *add(name)* column is added, the 'column' registers a reference,  'MetaColumn' is registered in 'column' of baseEntity. *Add(name, collection?)* If you specify 'collection' when adding a column, the reference is registered in 'columns', 'MetaColumn' is registered in the specified 'collecton'.  Class diagram ![image-center](/assets/images/view-rel-diagram-2024-08-16-002546.png){: .align-center}  ## an inheritance relationship  Class diagram ![image-center](/assets/images/view-diagram-2024-08-16-004628.png){: .align-center}  # a key element  ## Properties  | Item | Description | | ----------- | ------------------------------------ | | viewName | This is the name of the meta view | Columns | Collection of columns in the view | rows | Data (low) collection of entities | _baseEntity | Default entity | _metaSet | Metaset to which the entity belongs. | | _name | Name of the element, which acts as a unique identifier for the MetaElement | _guid | Unique identifier of the object (GUID). Uniquely identifies the object. | | _type | The generator function of the object. The function used when the object was created. | |             |                                      |    ## Method  | Item | Description | | -------------------------------- | ---------------------------------------------------- | | clone() | Create and return a deep copy of the current meta view | | copy(filter, args) | Copy the destination column | transformSchema() | Converts a given serialization object to a schema object | Clear() | Initializes all data in the entity | reset() | Initializes the entity's columns and data | NewRow() | Returns a new row that matches the column structure | getValue() | Returns the value of the column as a MetaRow type object | | setValue(row) | Set the MetaRow value to the value of the column | merge (target, optoin, matchType) | merge the given entity with the current entity | | select(filter, args) | query the row according to the given callback function | | load(obj, path) | Gets the given object into the current entity. Initializes the existing data and loads the new data | output (vOpt, stringify, space) | Outputs the current entity as a serialized string | read(obj, option) | Reads the given object as an entity. Follow JSON schema rules. | | readSchema (obj, createRow) | Reads the given schema object as the current entity | readData(obj) | Reads only rows that exist on a given object | | write(vOpt) | Returns the current entity by converting it to an object of schema type | | writeSchema(vOpt) | Returns the schema of the current entity by converting it to an object of schema type | | writeData(vOpt) | Returns data from the current entity by converting it into schema-type objects.  # Detailed description  ## Key Properties  ### viewName  > This is the name of the meta view.  ```ts type viewName = string; ```  ### columns  > Collection of columns in the view.  ```ts type columns = MetaTableColumnCollection; ```  ### rows  > Data (low) collection of tables.  ```ts type rows = MetaRowCollection; ```  ### \\_baseEntity  > Default entity.  ```ts type _baseEntity = BaseEntity; ```  ### \\_metaSet  > This is the meta set to which the table belongs.  ```ts type _metaSet = MetaSet; ```  ### \\_guid  > Unique identifier of the object (GUID). Uniquely identifies the object.  ```ts type _guid: string; ```  ### \\_type  > The generator function of the object, which was used when the object was created.  ```ts type _type: Function; ```   ## Key Methods  ### clone()  > Create and return a deep copy of the current object.  ```ts type clone() => MetaTable; ``` - return : This is a replica of the current object.  ### copy()  > Copy the target column.  ```ts type copy = ( \tfilter: (row, idx, entity) => boolean | string[], arguments,  \tcols?: string[] | arguments ) => MetaView; ``` - filter :    \t- Function type is the callback function that selects the column. \t-  Type string[] is the name of the column to copy. -   cols : The name of the column to copy, valid only if the filter is a Function type.  Example: Using filter, cols ```js var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows var temp = table.copy( \t(row, idx, entity) => { return (idx % 2) > 0; }, \t['aa', 'bb'] ); ``` - Temp is copied only if the row indexes of the columns 'aa' and 'bbb' are odd.  Example: Using cols only ```js var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t['aa', 'bb'] ); ``` - Temp copies the entire row of columns 'aa' and 'bbb'.  ### transformSchema()  > Converts a given serialization object to a schema object.  ```ts type transformSchema = (oGuid: object) => object; // static ``` - oGuid : object obtained by getObject().  ### clear()  > Initializes all data in the entity.  ```ts type clear = () => void; ```  ### reset()  > Initializes the entity's columns and data.  ```ts type reset = () => void; ```  ### newRow()  > Create and return a new row that matches the column structure.  ```ts type newRow = () => MetaRow; ``` - return : This is the MetaRow object created. ### getValue()  Returns the value of the > column as a MetaRow type object.  ```ts type getValue = () => MetaRow; ``` - return : MetaRow object with the value of the column set.  ### setValue()  > Set the MetaRow value to the value in the column.  ```ts type setValue = (row: MetaRow) => void; ``` - row : MetaRow object to be set.  ### merge()  > Merges the given entity with the current entity.  ```ts type merge = (target: BaseEntity, option: number, matchType?: boolean) => void; ``` - target : The target entity to merge. - option : Merge option. - matchType : Whether or not a row validation exists. (Default: false)  ### select()  > Look up the row according to the given callback function.  ```ts type select = ( \tfilter: (row, idx, entity) => boolean | string[], | arguments, \tcols?: string[] | arguments ) => MetaView; ``` - filter :    \t- Function type is the callback function that selects the column. \t-  Type string[] is the name of the column to copy. -   cols : The name of the column to copy, valid only if the filter is a Function type.  Example: Using filter, cols ```js var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t(row, idx, entity) => { return (idx % 2) > 0; }, \t['aa', 'bb'] ); ``` - The temp view is copied only if the row indexes of the columns 'aa', 'bbb' are odd.  Example: Using cols only ```js var table = new MetaTable('t1');  // ... Add columns, aa, bb, cc, e, and rows   var temp = table.copy( \t['aa', 'bb'] ); ``` - The temp view copies the entire row of columns 'aa' and 'bbb'.  ### load()  > Imports the given object to the current entity, initializes the existing data and loads the new data.  ```ts type load = (obj: object | string, parse?: Function) => void; ``` - obj : The object to be called. - pas : parser function. (Optional)  ### output()  > Outputs the current entity as a serialized string.  ```ts type output = (vOpt: number, stringify?: Function, space?: string) => string; ``` - vOpt : Optional (0, 1, 2) - stringify : This is a user-defined parser function. (Optional) - space : A blank string to be used in the output. (Optional)  ### read()  > Reads the given object as an entity. Follow JSON schema rules.  ```ts type read = (obj: object, option: number) => void; ``` - obj : object to be read. - option : Read option (default: 3)  ```js var schema1 = {  \ttable: {  \t\tcolumns: {},  \t\trows: {}  \t} };  var schema1 = {  \tcolumns: {...},  \trows: {}  }; ```  ### readSchema()  > Reads the given schema object as the current entity.  ```ts type readSchema = (obj: object, createRow?: boolean) => void; ``` - obj : Schema object to be read. - createRow : If true, add the column by row[0] (default: false)  ### readData()  > Reads only rows that exist on a given object.  ```ts type readData = (obj: object) => void; ``` - obj : The object to be read.  ### write()  > Returns the current entity after converting it to an object of schema type.  ```ts type write = (vOpt?: number) => object; ``` - vOpt : Optional (default: 0) - return : Object of schema type.  ### writeSchema()  > Returns the schema of the current entity by converting it to an object of schema type.  ```ts type writeData = (vOpt?: number): object; ``` - vOpt : Optional (default: 0) - return : Object of schema type.  ### writeData()  > Returns the data of the current entity by converting it into an object of schema type.  ```ts type writeData = (vOpt?: number) => object; ``` - vOpt : Optional (default: 0) - return : Object of schema type.  ### getObject()  > Obtain the current object as a guide type object. > (Circular references are replaced by $ref values.)  ```ts type getObject = (vOpt?: number, owned?: object | Array) => object; ``` - vOpt : Import option; default is 0. \t- opt=0: Reference structure (_guid:Yes, $ref:Yes) \t* opt=1: Redundant structure (_guid:Yes, $ref:Yes) \t* opt=2 : Non-tidal structure (_guid: No, $ref: No) - aged : The parent objects that currently own the object. The default is an empty object. - return —Returns serialized objects.  ```js a.getObject(2) == b.getObject(2) ```  ### setObject()  > Set the Guid type object to the current object. > (The object will be reset.)  ```ts type setObject = (oGuid: object, origin?: object) => void; ``` - oGuid : Object of the guid type to serialize. - origin : This is the original object that sets the current object. The default is oGuid.  ### equal()  > Compare the current object with the specified object.  ```ts type equal (target: object) => boolean; ``` - return —Returns whether the two objects are identical.  ### getTypes()  > Returns the creators of the current object and all the creators of the prototype chain to the array.  ```ts type getTypes = () => Array; ``` - return : Returns the array of generator functions.  ```js const types = obj.getTypes(); console.log(types); // [Function: MetaObject] ```  ### instanceOf()  > Verify that the current object is an instance of the specified type (including _UNION)  ```ts type instanceOf = (target: object | string) => boolean; ``` - target : The type of object to be checked (object or string). - return —Returns whether this is an instance of the specified type.   ","url": "http://localhost:4000/en/docs/api-meta-view/"
  },{
    "title": "멀티 테이블 관리",
    "excerpt":"BindModel 객체는 기본적으로 ‘first’라는 이름의 MetaTable을 자동 생성하여 사용합니다. 필요에 따라 다른 MetaTable을 추가할 수 있으며, 이는 컬럼명이 같지만 속성이 다르거나 특별한 경우에 유용합니다.   ## MetaTable 추가  ### addTable() 메소드로 추가  addTable() 메소드를 통해 \\_tables 컬렉션에 MetaTable을 추가할 수 있습니다. 이 메소드를 사용하면, BindModelAjax 객체에서 테이블에 접근하기 위한 참조 키를 자동으로 만듭니다.  ```js var bm = new BindModel();  bm.addTable('second');  // bm._tables[0] === bm._tables['first'] == bm.first // bm._tables[1] === bm._tables['second'] == bm.second // bm._tables.count == 2 ``` - bm.second 로 추가한 테이블의 접근할 수 있습니다.  ### \\_tables 컬렉션으로 추가  \\_tables.add() 메소드를 통해 MetaTable을 추가할 수 있습니다. 이 방법도 유사하게 \\_tables 컬렉션에 테이블을 추가하지만, addTable()과는 달리 테이블명 참조 키를 자동으로 생성하지 않습니다.  ```js var bm = new BindModel();  bm._tables.add('second');  // bm._tables[1] === bm._tables['second'] // bm._tables.count == 2 ``` ## 기본 테이블 변경  추가한 MetaTable을 기본 테이블로 설정하면, 이후에 addColumn() 또는 addCommand()를 사용할 때 기본 테이블이 변경된 테이블로 설정됩니다.  ```js var bm = new BindModel();  bm._tables.add('second');  // 기본테이블 설정 bm._baseTable = bm['second'];    // 컬럼 추가 bm.addColumnValue('aa', 10);  // bm.columns['aa'].value == 10 // bm._tables['first'].columns.count == 0 // bm._tables['second'].columns.count == 1 ``` - `columns` 속성은 `_baseTable`의 columns 을 참조합니다. (columns === \\_tabeTable.columns)  이와 같이 BindModelAjax 객체에서 MetaTable을 추가하고 활용할 수 있습니다.  # 여러 메소드에서 추가한 테이블 지정  여러 메소드에서 추가한 테이블을 지정할 수 있습니다. \\_tables 컬렉션 외부에 테이블을 지정할 경우, 객체 직렬화 기능을 사용할 수 없습니다.  ## BindModel 영역  ### addCommand() : 명령 추가 (BindModel)  command 추가시 테이블을 지정할 수 있습니다.  ```js var bm = new BindModel();  bm.addTable('second');  bm.addCommand('read', 3, 'second'); bm.addCommand('list', 3, bm.second);  // bm.command['read']._baseTable == bm.second // bm.command['list']._baseTable == bm.second ``` - read 명령의 기본 테이블은 'second'로 지정됩니다. - list 명령의 기본 테이블은 'second'로 지정됩니다.  ### addColumn() : 컬럼 추가 (BindModelAjax)  컬럼 추가 시 테이블을 지정할 수 있습니다.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.addColumn('aa', 'read', 'valid', 'second'); bm.addColumn('bb', 'read', '$all', bm.second); ``` - 'aa' 컬럼은 'second' 테이블에 등록되고 read 명령의 valid 에 참조가 등록됩니다. - 'bb' 컬럼은 'second' 테이블에 등록되고 read 명령의 전체 MetaView 에 참조가 등록됩니다.  ### addColumnValue() : 컬럼 추가 (초기값 설정)  column 추가 시 초기값을 지정하고 테이블을 설정할 수 있습니다.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.addColumn('aa', 'AA', 'read', 'valid', 'second'); bm.addColumn('bb', 'BB', 'read', '$all', bm.second); ``` - ‘aa’ 컬럼의 초기값은 ‘AA’로 ‘second’ 테이블에 등록되고 read 명령의 valid에 참조가 등록됩니다. - ‘bb’ 컬럼의 초기값은 ‘BB’로 ‘second’ 테이블에 등록되고 read 명령의 전체 MetaView에 참조가 등록됩니다.  ### setMapping() : 컬럼 매핑  매핑 시 기본 테이블을 지정할 수 있습니다  ```js var bm = new BindModel(); bm.addTable('second'); bm.addCommand('read');  bm.items.add('aa', ''); bm.items.add('bb', '');  bm.setMapping({ \taa: { read: ['valid'] }, \tbb: { read: ['bind'] }, }, 'second');  // bm.second.columns.count == 2 // bm.first.columns.count == 0 ``` - 아이템들은 ‘second’ 테이블에 등록되고, read 명령의 MetaView에 참조값이 등록됩니다.  ### 서비스 객체  items, mapping 영역에서 테이블명과 조합해서 사용할 수 있습니다.  ```js var bm1 = new BindModel({ \ttables: ['second', 'three'], \titems: {         'aa': '',         'second.bb': '',         'cc': '',     },     command: {         read: {} \t},     mapping: {         'aa': { read: ['valid'] },         'bb': { read: ['bind'] },         'three.cc': { read: ['output'] }     }, }); ``` - 'aa' 아이템은 기본 테이블(first)에 등록되고 대상 command 에 매핑됩니다. - 'bb' 아이템은 추가 테이블(second)에 등록되고 대상 command 에 매핑됩니다. - 'cc' 아이템은 추가 테이블(three)에 등록되고 대상 command 에 매핑됩니다.   ## BindCommand 영역  ### addColumn() : 컬럼 추가  컬럼 추가 시 테이블을 지정할 수 있습니다.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.cmd['read'].addColumn('aa', 'valid', 'second'); bm.cmd['read'].addColumn('bb', '$all', bm.second); ``` - 'aa' 컬럼은 'second' 테이블에 등록되고 read 명령의 valid 에 참조가 등록됩니다. - 'bb' 컬럼은 'second' 테이블에 등록되고 read 명령의 전체 MetaView 에 참조가 등록됩니다.  ### addColumnValue() : 컬럼 추가 (초기값 설정)  column 추가 시 초기값을 설정하고 테이블을 지정할 수 있습니다.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.cmd['read'].addColumn('aa', 'AA', 'read', 'valid', 'second'); bm.cmd['read'].addColumn('bb', 'BB', 'read', '$all', bm.second); ``` - 'aa' 컬럼은 초기값은 'AA' 로  'second' 테이블에 등록되고 read 명령의 valid 에 참조가 등록됩니다. - 'bb' 컬럼은 초기값은 'AA' 로 'second' 테이블에 등록되고 read 명령의 전체 MetaView 에 참조가 등록됩니다. ### setColumn() : 컬럼 설정  column 설정 시 테이블을 지정할 수 있습니다.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bb.first.columns.add('aa'); bb.first.columns.add('bb'); bb.seoncd.columns.add('cc');  bm.command['read'].setColumn('aa', 'valid'); bm.command['read'].setColumn(['bb', 'second.cc'], 'bind'); ``` - 기본 테이블에 등록된 'aa' 컬럼은 read 명령의 valid 에 참조가 등록됩니다. - 기본 테이블에 등록된 'bb' 컬럼은 read 명령의 bind 에 참조가 등록됩니다. - 'second' 테이블에 등록된 'cc' 컬럼은 read 명령의 bind 에 참조가 등록됩니다.","url": "http://localhost:4000/ko/docs/multi-table/"
  },{
    "title": "Multi-Table",
    "excerpt":"By default, the BindModel object automatically generates and uses a MetaTable named 'first', which is useful if you have the same column name but different properties or special cases.  ## Add MetaTable  ### Add as addTable() Method  The addTable() method allows you to add MetaTable to the \\_tables collection, which automatically creates a reference key to access the table from the BindModel object.  ```js var bm = new BindModel();  bm.addTable('second');  // bm._tables[0] === bm._tables['first'] == bm.first // bm._tables[1] === bm._tables['second'] == bm.second // bm._tables.count == 2 ``` - Access to tables added as bm.second. ### \\_Add as a collection of tables  You can add MetaTable through the \\_tables.add() method, which adds tables to the \\_tables collection similarly, but does not automatically generate a table name reference key, unlike addTable().  ```js var bm = new BindModel();  bm._tables.add('second');  // bm._tables[1] === bm._tables['second'] // bm._tables.count == 2 ```   ## Change the default table  If you set the added MetaTable to the default table, the default table is set to the changed table when you use addColumn() or addcommand() later.  ```js var bm = new BindModel();  bm._tables.add('second');  // Default Table Settings bm._baseTable = bm['second'];    // Add Column bm.addColumnValue('aa', 10);  // bm.columns['aa'].value == 10 // bm._tables['first'].columns.count == 0 // bm._tables['second'].columns.count == 1 ``` - For the 'column' property, refer to columns of '_baseTable' (column === \\_tabeTable.column)  As such, MetaTable can be added and utilized in the BindModel object.   # Specify tables added by multiple methods  You can specify tables added by multiple methods. If you specify tables outside the \\_tables collection, the object serialization feature is not available.  ## BindModel Area  ### addcommand(): add command  You can specify a table when adding a command.  ```js var bm = new BindModel();  bm.addTable('second');  bm.addCommand('read', 3, 'second'); bm.addCommand('list', 3, bm.second);  // bm.command['read']._baseTable == bm.second // bm.command['list']._baseTable == bm.second ``` - The default table for the read command is specified as 'second'. - The default table for the list command is specified as 'second'. ### addColumn(): add column  You can specify a table when adding columns.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.addColumn('aa', 'read', 'valid', 'second'); bm.addColumn('bb', 'read', '$all', bm.second); ``` - The 'aa' column is registered in the 'second' table and a reference is registered in the valid of the read command. - The 'bb' column is registered in the 'second' table and a reference is registered in the entire MetaView of the read command.  ### addColumnValue(): add column  You can specify an initial value and set the table when adding columns.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.addColumn('aa', 'AA', 'read', 'valid', 'second'); bm.addColumn('bb', 'BB', 'read', '$all', bm.second); ``` - The initial value of the 'aa' column is 'AA' and is registered in the 'second' table and a reference is registered in the valid of the read command. - The initial value of the 'bb' column is 'BBB' and is registered in the 'second' table and a reference is registered in the entire MetaView of the read command.  ### setMapping():column mapping  You can specify a default table when mapping  ```js var bm = new BindModel(); bm.addTable('second'); bm.addCommand('read');  bm.items.add('aa', ''); bm.items.add('bb', '');  bm.setMapping({ \taa: { read: ['valid'] }, \tbb: { read: ['bind'] }, }, 'second');  // bm.second.columns.count == 2 // bm.first.columns.count == 0 ``` - Items are registered in the 'second' table and the reference value is registered in the MetaView of the read command.  ### Service Object  You can use it in combination with the table name in the items, mapping area.  ```js var bm1 = new BindModel({ \ttables: ['second', 'three'], \titems: {         'aa': '',         'second.bb': '',         'cc': '',     },     command: {         read: {} \t},     mapping: {         'aa': { read: ['valid'] },         'bb': { read: ['bind'] },         'three.cc': { read: ['output'] }     }, }); ``` - Items 'aa' are registered in the default table (first) and mapped to the target command. - The 'bbb' item is registered in the extra table (second) and mapped to the target command. - The 'cc' item is registered in the additional table and mapped to the target command.   ## Bind Command Area  ### addColumn(): add column  You can specify a table when adding columns.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.cmd['read'].addColumn('aa', 'valid', 'second'); bm.cmd['read'].addColumn('bb', '$all', bm.second); ``` - The 'aa' column is registered in the 'second' table and a reference is registered in the valid of the read command. - The 'bb' column is registered in the 'second' table and a reference is registered in the entire MetaView of the read command.  ### addColumnValue(): add column  When adding columns, you can set initial values and specify tables.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bm.cmd['read'].addColumn('aa', 'AA', 'read', 'valid', 'second'); bm.cmd['read'].addColumn('bb', 'BB', 'read', '$all', bm.second); ``` - The 'aa' column is registered in the 'second' table with an initial value of 'AA' and a reference is registered in the valid of the read command. - The 'bb' column is registered in the 'second' table with an initial value of 'AA' and a reference is registered in the entire MetaView of the read command. ### setColumn(): column settings  You can specify a table when setting the column.  ```js var bm = new BindModel();  bm.addTable('second'); bm.addCommand('read');  bb.first.columns.add('aa'); bb.first.columns.add('bb'); bb.seoncd.columns.add('cc');  bm.command['read'].setColumn('aa', 'valid'); bm.command['read'].setColumn(['bb', 'second.cc'], 'bind'); ``` - The 'aa' column registered in the default table registers a reference in the valid of the read command. - The 'bbb' column registered in the default table is referenced in the bind of the read command. - The 'cc' column registered in the 'second' table is referenced in the bind of the read command. ","url": "http://localhost:4000/en/docs/multi-table/"
  },{
    "title": "멀티 뷰(output)",
    "excerpt":"멀티뷰는 서버에서 수신한 데이터가 2개 이상의 자료일 경우에 사용됩니다. BindCommand 객체는 기본적으로 output 속성의 MetaView를 포함하며, 이는 `_outputs['output1']`의 참조 속성입니다.  이 기능을 통해 여러 개의 MetaView를 추가하거나 제거할 수 있으며, 각 MetaView는 서버에서 수신한 데이터를 저장하고 관리하는 데 사용됩니다.  ## BindCommand 의 output 구조  BindCommand 객체를 생성하면 기본적으로 output 속성이 추가됩니다. 이 output 속성은 `_outputs['output1']`의 참조입니다.  ```js var bm = new BindModel();  bm.addCommand('test');  // bm.command['test'].output == MetaView // bm.command['test'].output1 == MetaView ``` - 여기서 output과 output1은 동일한 MetaView를 참조합니다.  ## output (MetaView) 추가  타입 : newOutput ```ts type newOutput = (outputName?: string) => void; ``` - outputName: 추가하는 output 이름입니다.  newOutput() 메소드를 사용하여 새로운 MetaView를 추가할 수 있습니다. 이 메소드는 선택적으로 outputName 을 인자로 받아 해당 이름으로 MetaView를 추가합니다.  인자가 없을 경우, 기본적으로 `output + 순서` 형태의 이름으로 추가됩니다.  예제 : output 추가 ```js var bm = new BindModel();  bm.addCommand('test'); // bm.command['test'].output == MetaView // bm.command['test'].output1 == MetaView // bm.cmd['test']._outputs.count == 1  bm.cmd['test'].newOutput(); // bm.command['test'].output2 == MetaView // bm.cmd['test']._outputs.count == 2  bm.cmd['test'].newOutput('three'); // bm.command['test'].output3 == MetaView // bm.command['test'].three == MetaView // bm.cmd['test']._outputs.count == 3 ``` - 첫번째 newOutput() 메소드에서 인자를 주지 않으면 'output2'로 추가되었습니다. - 두번째 newOutput() 메소드에서 'three' 과 'output3' 로 추가되었습니다.  ouput MetaView 을 추가후에 전체 command 에 컬럼을 추가하면 추가된 view 에도 매핑이 됩니다.  예제 : 전체 MetaView 에 컬럼 추가시 ```js var bm = new BindModel();  bm.addCommand('test');  bm.cmd['test'].newOutput('newOutput'); bm.cmd['test'].addColumn('aa');  // bm.cmd['test'].valid.count == 1 ('aa') // bm.cmd['test'].bind.count == 1 ('aa') // bm.cmd['test'].output.count == 1 ('aa') // bm.cmd['test'].newOutput.count == 1 ('aa') ``` - 추가된 'newOutput' 에 추가한 'aa' 컬럼이 추가됩니다.  ## output (MetaView) 제거  타입 : removeOutput ```ts type newOutput = (outputName: string) => boolean; ``` - outputName: 제거할려는 output 이름입니다.  기본 프로퍼티 `ouput`, `output1` 는 제거할 수 없습니다. ```js var bm = new BindModel();  bm.addCommand('test');  bm.cmd['test'].newOutput(); bm.cmd['test'].newOutput('three');  // Remove bm.cmd['test'].removeOutput('output2'); bm.cmd['test'].removeOutput('three'); // bm.cmd['test'].removeOutput('output') : throw 발생 // bm.cmd['test']._outputs.count == 1 ``` - 여기서 newOutput() 메소드로 으로 추가된 output2와 three를 제거할 수 있습니다.  위의 예제와 설명을 통해 멀티뷰 기능을 사용하여 여러 개의 MetaView를 추가하거나 제거하는 방법을 이해할 수 있습니다. 이는 서버에서 수신한 여러 데이터를 관리하고 처리하는 데 유용합니다.  ","url": "http://localhost:4000/ko/docs/multi-view/"
  },{
    "title": "Multi-View(output)",
    "excerpt":"Multi-view is used when data received from the server is more than one data. By default, the Bindcommand object contains the MetaView of the output property, which is a reference property for '_outputs['output1'].  This feature allows you to add or remove multiple MetaViews, each of which is used to store and manage data received from the server.  ## output structure of Bindcommand  When you create a Bindcommand object, the output attribute is added by default, which is a reference to '_outputs['output1']'.  ```js var bm = new BindModel();  bm.addCommand('test');  // bm.command['test'].output == MetaView // bm.command['test'].output1 == MetaView ``` - Here, output and output1 refer to the same MetaView.   ## output (MetaView) 추가  Type: newOutput ```ts type newOutput = (outputName?: string) => void; ``` - outputName—The name of the output to be added.  You can use the newOutput() method to add a new MetaView, which optionally takes outputName as a factor and adds MetaView to that name.  If there is no factor, it is added by default as a name in the form of 'output + order'.  Example: Adding Output ```js var bm = new BindModel();  bm.addCommand('test'); // bm.command['test'].output == MetaView // bm.command['test'].output1 == MetaView // bm.cmd['test']._outputs.count == 1  bm.cmd['test'].newOutput(); // bm.command['test'].output2 == MetaView // bm.cmd['test']._outputs.count == 2  bm.cmd['test'].newOutput('three'); // bm.command['test'].output3 == MetaView // bm.command['test'].three == MetaView // bm.cmd['test']._outputs.count == 3 ``` - If no factor is given in the first newOutput() method, it is added as 'output2'. - It was added as 'three' and 'output3' in the second newOutput() method.  If you add an output MetaView and add a column to the entire command, it is also mapped to the added view.  Example: Adding a column to an entire MetaView ```js var bm = new BindModel();  bm.addCommand('test');  bm.cmd['test'].newOutput('newOutput'); bm.cmd['test'].addColumn('aa');  // bm.cmd['test'].valid.count == 1 ('aa') // bm.cmd['test'].bind.count == 1 ('aa') // bm.cmd['test'].output.count == 1 ('aa') // bm.cmd['test'].newOutput.count == 1 ('aa') ``` - The 'aa' column added to the added 'newOutput' is added.    ## output (MetaView) 제거  타입 : removeOutput ```ts type newOutput = (outputName: string) => boolean; ``` - outputName: The output name that you want to remove.  Default properties 'output', 'output1' cannot be removed.  ```js var bm = new BindModel();  bm.addCommand('test');  bm.cmd['test'].newOutput(); bm.cmd['test'].newOutput('three');  // Remove bm.cmd['test'].removeOutput('output2'); bm.cmd['test'].removeOutput('three'); // bm.cmd['test'].removeOutput('output') : throw 발생 // bm.cmd['test']._outputs.count == 1 ``` - Here, you can remove the newOutput() method and the added output2 and three.  The examples and descriptions above will help you understand how to add or remove multiple MetaViews using the multiview functionality, which is useful for managing and processing multiple data received from the server.  ","url": "http://localhost:4000/en/docs/multi-view/"
  },{
    "title": "Implement notice in BindModel",
    "excerpt":"## Description - As an example of \"Notice\", the administrator and user pages. - You can use html, css, and js files produced by web designers right away without modification. - By separating and managing common service objects, it provides an efficient structure so that repetitive code writing is not required, increasing maintenance and scalability.  ## folder structure ```js vue-mix/ ├── service/ │   ├── base-notice-svc.js │   ├── notice-admin-svc.js  │   └--notice-front-svc.js : ** User Page ** ├-- front.html : ** User Page ** └── admin.html ```  ### admin.html --- A page that consists of html, css, and js of notice lists and forms.  You must add permission settings to the Administrators page during a physical implementation.  ```html      BindModel Example                  Notice Admin Page    Key Features: List inquiry/modification/deletion    Data is transmitted when modified or deleted from the test page, but it is not actually processed.                         Title         Status         Date                                 There is no content.                 {% raw %}               {% endraw %}                            날짜                                 Title                                    Content                                                                                 top notice                                                                              Standby                                                            Activation                                                            Hidden                                               Update     Delete     List             ``` #### Code Description - Inject service objects when creating a 'bm' BindModel object. - A class statement was used internally to separate common elements of the service object (NoticeAdminService). - You have registered the execute() method on the button using Jquery. - After loading the screen, you ran the command to get the list by running bm.cmd['list'].execute(). - The handlebars template was used to output the lock.  ### front.html --- This is the user page of the announcement.  ```html      BindModel Example                  Notice Front Page    Key functions: List Lookup    Data is transmitted when modified or deleted from the test page, but it is not actually processed.                         Title         Date                                 There is no content.                 {% raw %}               {% endraw %}                                Title                                    Content                            List              ``` #### Code Description - Inject service objects when creating a 'bm' BindModel object. - A class statement was used inside to separate common elements of the service object (NoticeFrontService). - You have registered the execute() method on the button using Jquery. - After loading the screen, you ran the command to get the list by running bm.cmd['list'].execute(). - The handlebars template was used to output the lock.   ### service/base-notice-svc.js --- The BaseNoticeService class has configured the common object of the notice.  ```js class BaseNoticeService {     constructor(_SUFF = '') {         var _this = this;              this.items = {             // misc             _area_temp: { selector: { key: `#area-temp${_SUFF}`,    type: 'html' } },             _area_tbody:{ selector: { key: `#area-tbody${_SUFF}`,   type: 'html' } },             _area_form: { selector: { key: `#class-form${_SUFF}`,   type: 'prop.class' } },             _index:     0,             // valid, bind, output             ntc_idx:        '',             title:      {                  selector: { key: `#title${_SUFF}`,        type: 'value' },                 required: true,             },             contents:   { selector: { key: `#contents${_SUFF}`,     type: 'value' } },             top_yn:     {                  selector: { key: `input[name=top_yn${_SUFF}]`,      type: 'none' },                 setFilter(val) {                      $(`input[name=top_yn${_SUFF}]`).prop('checked', val == 'Y' ? true : false);                 },                 getFilter(val) {                     return $(`input[name=top_yn${_SUFF}]:checked`).val();                 }             },             active_cd:  {                 selector: { key: `input[name=active_cd${_SUFF}][type=radio]`,  type: 'none' },                 setFilter(val) {                      $(`input[name=active_cd${_SUFF}][value=${val}]`).prop('checked', true);                 },                 getFilter(val) {                     return $(`input[name=active_cd${_SUFF}]:checked`).val();                 }             },             create_dt:  { selector: { key: `#create_dt${_SUFF}`,  type: 'text' } }         };                  this.fn = {             procRead(index) {                  _this.bindModel.items._index = index;                 _this.bindModel.command['read'].execute();             }         };     } } ``` #### Code Description - The _SUFF parameter was used to prevent duplication of id and name of service object. - var_this is defined to access bindModel objects in the callback function. - The 'items' area is a common property to register as an HTML Column.     - Selector properties are properties that point to DOM.         - The key property is the selector value that points to the element.         - Value, none, text, html, prop.synonyms, and attr.synonyms of type properties.     - setter/getter usually gets values from outside.     - The setFiter/getFiter obtains values from multiple DOM elements or sets them when processing.     The required property is a required value for valid inspection. - The 'fn' area is the user function area.   ### service/notice-admin-svc.js --- The NoticeAdminService class is an administrator service object for a notice.  ```js class NoticeAdminService extends BaseNoticeService {     constructor() {         super();          var _this       = this;         var _template   = null;     // Handlebars template          this.command = {             create:     {             },             read:       {                 outputOption: 3,                 cbBegin(cmd) {                      cmd.outputOption.index = Number(cmd._model.items._index);                     cmd._model.columns._area_form.value = '';  // form show                 },             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) alert('It has been modified.');                 }             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) {                         alert('The post has been deleted.');                         _this.bindModel.cmd['list'].execute();                     }                 }             },             list:       {                 outputOption: 1,                 cbBegin(cmd) {                     cmd._model.columns._area_form.value = 'd-none';                 },                 cbOutput(outs, cmd, res) {                     if (_template === null) {                         _template = Handlebars.compile( _this.bindModel.columns['_area_temp'].value );                      }                     _this.bindModel.columns['_area_tbody'].value   = _template(res.data);                 },             }         };          this.mapping = {             _area_temp:     { list:     'misc' },             _area_tbody:    { list:     'misc' },             _area_form:     { list:     'misc' },             ntc_idx:        { read:     'bind',     update:  'bind',               delete:     'bind' },             title:          { read:     'output',   update:  ['valid', 'bind'], },             contents:       { read:     'output',   update:  'bind' },             top_yn:         { read:     'output',   update:  ['valid', 'bind'], },             active_cd:      { read:     'output',   update:  ['valid', 'bind'], },             create_dt:      { read:     'output' },         };      }     } ``` #### Code Description - The command area sets the properties of the Bindcommand.     - The output option is a method of importing data sent to the server.     - The callback function is called step by step when executing execute().         - **cbBegin**() >> **cbValid**() >> **cbBind**() >> **cbResult**() >> **cbOutput**() >> **cbEnd**() - The mapping area is the Bindcommand object mapping information for the column.     - title:          { read:     'output',   update:  ['valid', 'bind'], }         - Create a Title column and map it to the output of the **read** command and the **valid** command to valid, bind.  ### service/notice-front-svc.js --- The NoticeFrontService class is a user service object of a notice.  ```js class NoticeFrontService extends BaseNoticeService {     constructor() {         super();          var _this       = this;         var _template   = null;     // Handlebars template          this.command = {             read:       {                 outputOption: 3,                 cbBegin(cmd) {                      cmd.outputOption.index = Number(cmd._model.items._index);                     cmd._model.columns._area_form.value = '';  // form show                 },             },               list:       {                 outputOption: 1,                 cbBegin(cmd) {                     cmd._model.columns._area_form.value = 'd-none'; // form hidden                 },                 cbOutput(outs, cmd, res) {                     if (_template === null) {                         _template = Handlebars.compile( _this.bindModel.columns['_area_temp'].value );                      }                     _this.bindModel.columns['_area_tbody'].value   = _template(res.data);                 },             }         };          this.mapping = {             _area_temp:     { list:     'misc' },             _area_tbody:    { list:     'misc' },             _area_form:     { list:     'misc' },             ntc_idx:        { read:     'bind' },             title:          { read:     'output' },             contents:       { read:     'output' },             create_dt:      { read:     'output' },         };     } } ```","url": "http://localhost:4000/en/exam/notice-bindmodel/"
  },{
    "title": "BindModel 예제",
    "excerpt":"## 설명 - \"알림\"의 예로 관리자 및 사용자 페이지를 들 수 있습니다. - 웹 디자이너가 제작한 html, css, js 파일을 수정 없이 바로 사용할 수 있습니다. - 공통 서비스 개체를 분리하여 관리함으로써 반복적인 코드 작성이 필요하지 않도록 효율적인 구조를 제공하여 유지보수 및 확장성을 높입니다.  ## 폴더 구조 ```js vue-mix/ ├── service/ │   ├── base-notice-svc.js │   ├── notice-admin-svc.js  │   └--notice-front-svc.js : ** User Page ** ├-- front.html : ** User Page ** └── admin.html ```  ### admin.html --- 공지 목록과 양식의 html, css, js로 구성된 페이지입니다.  물리적 구현 중에 관리자 페이지에 권한 설정을 추가해야 합니다.  ```html      BindModel Example                  Notice Admin Page    Key Features: List inquiry/modification/deletion    Data is transmitted when modified or deleted from the test page, but it is not actually processed.                         Title         Status         Date                                 There is no content.                 {% raw %}               {% endraw %}                            날짜                                 Title                                    Content                                                                                 top notice                                                                              Standby                                                            Activation                                                            Hidden                                               Update     Delete     List             ``` #### 코드 설명 - 'bm' BindModel 개체를 만들 때 서비스 개체를 주입합니다. - 클래스 문은 내부적으로 서비스 개체(NoticeAdminService)의 공통 요소를 분리하는 데 사용되었습니다. - Jquery를 사용하여 버튼에 execute() 메서드를 등록했습니다. - 화면을 로드한 후 명령을 실행하여 bm.cmd['list'].execute()를 실행하여 목록을 가져옵니다. - 핸들바 템플릿을 사용하여 잠금을 출력했습니다.  ### front.html --- 공지사항의 사용자 페이지입니다.  ```html      BindModel Example                  Notice Front Page    Key functions: List Lookup    Data is transmitted when modified or deleted from the test page, but it is not actually processed.                         Title         Date                                 There is no content.                 {% raw %}               {% endraw %}                                Title                                    Content                            List              ``` #### 코드 설명 - 'bm' BindModel 개체를 만들 때 서비스 개체를 주입합니다. - 클래스 문을 사용하여 서비스 개체(NoticeFrontService)의 공통 요소를 분리했습니다. - Jquery를 사용하여 버튼에 execute() 메서드를 등록했습니다. - 화면을 로드한 후 명령을 실행하여 bm.cmd['list'].execute()를 실행하여 목록을 가져옵니다. - 핸들바 템플릿을 사용하여 잠금을 출력했습니다.  ### service/base-notice-svc.js --- 기본 NoticeService 클래스가 알림의 공통 개체를 구성했습니다.  ```js class BaseNoticeService {     constructor(_SUFF = '') {         var _this = this;              this.items = {             // misc             _area_temp: { selector: { key: `#area-temp${_SUFF}`,    type: 'html' } },             _area_tbody:{ selector: { key: `#area-tbody${_SUFF}`,   type: 'html' } },             _area_form: { selector: { key: `#class-form${_SUFF}`,   type: 'prop.class' } },             _index:     0,             // valid, bind, output             ntc_idx:        '',             title:      {                  selector: { key: `#title${_SUFF}`,        type: 'value' },                 required: true,             },             contents:   { selector: { key: `#contents${_SUFF}`,     type: 'value' } },             top_yn:     {                  selector: { key: `input[name=top_yn${_SUFF}]`,      type: 'none' },                 setFilter(val) {                      $(`input[name=top_yn${_SUFF}]`).prop('checked', val == 'Y' ? true : false);                 },                 getFilter(val) {                     return $(`input[name=top_yn${_SUFF}]:checked`).val();                 }             },             active_cd:  {                 selector: { key: `input[name=active_cd${_SUFF}][type=radio]`,  type: 'none' },                 setFilter(val) {                      $(`input[name=active_cd${_SUFF}][value=${val}]`).prop('checked', true);                 },                 getFilter(val) {                     return $(`input[name=active_cd${_SUFF}]:checked`).val();                 }             },             create_dt:  { selector: { key: `#create_dt${_SUFF}`,  type: 'text' } }         };                  this.fn = {             procRead(index) {                  _this.bindModel.items._index = index;                 _this.bindModel.command['read'].execute();             }         };     } } ``` #### 코드 설명 - _SUFF 매개 변수는 ID와 서비스 개체 이름의 중복을 방지하는 데 사용되었습니다. - var_this는 콜백 함수에서 bindModel 개체에 액세스하도록 정의되었습니다. - '항목' 영역은 HTML 열로 등록할 수 있는 공통 속성입니다.     - 선택기 속성은 DOM을 가리키는 속성입니다.         - 키 속성은 요소를 가리키는 선택기 값입니다.         - 형식 속성의 값, 없음, 텍스트, html, prop.synonymes 및 속성.synonymes.     - 세터/게터는 일반적으로 외부에서 값을 가져옵니다.     - setFiter/getFiter는 여러 DOM 요소에서 값을 얻거나 처리할 때 설정합니다.     필요한 속성은 유효한 검사에 필요한 값입니다. - 'fn' 영역은 사용자 기능 영역입니다.  ### service/notice-admin-svc.js --- NoticeAdminService 클래스는 알림의 관리자 서비스 개체입니다.  ```js class NoticeAdminService extends BaseNoticeService {     constructor() {         super();          var _this       = this;         var _template   = null;     // Handlebars template          this.command = {             create:     {             },             read:       {                 outputOption: 3,                 cbBegin(cmd) {                      cmd.outputOption.index = Number(cmd._model.items._index);                     cmd._model.columns._area_form.value = '';  // form show                 },             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) alert('It has been modified.');                 }             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) {                         alert('The post has been deleted.');                         _this.bindModel.cmd['list'].execute();                     }                 }             },             list:       {                 outputOption: 1,                 cbBegin(cmd) {                     cmd._model.columns._area_form.value = 'd-none';                 },                 cbOutput(outs, cmd, res) {                     if (_template === null) {                         _template = Handlebars.compile( _this.bindModel.columns['_area_temp'].value );                      }                     _this.bindModel.columns['_area_tbody'].value   = _template(res.data);                 },             }         };          this.mapping = {             _area_temp:     { list:     'misc' },             _area_tbody:    { list:     'misc' },             _area_form:     { list:     'misc' },             ntc_idx:        { read:     'bind',     update:  'bind',               delete:     'bind' },             title:          { read:     'output',   update:  ['valid', 'bind'], },             contents:       { read:     'output',   update:  'bind' },             top_yn:         { read:     'output',   update:  ['valid', 'bind'], },             active_cd:      { read:     'output',   update:  ['valid', 'bind'], },             create_dt:      { read:     'output' },         };      }     } ``` #### 코드 설명 - 명령 영역은 Bind명령어의 속성을 설정합니다.     - 출력 옵션은 서버로 전송된 데이터를 가져오는 방법입니다.     - 콜백 함수는 실행()을 실행할 때 단계별로 호출됩니다.         - **cbBegin**() >> **cbValid**() > **cbBind**() > **cbResult**() > **cbOutput**() > **cbEnd**() - 매핑 영역은 열에 대한 Bindcommand 개체 매핑 정보입니다.     - 제목: { 읽기: '출력', 업데이트: ['valid', 'bind', }         - 제목 열을 만들고 **read** 명령 및 **valid** 명령의 출력에 매핑하여 유효하게 바인딩합니다.  ### service/notice-front-svc.js --- NoticeFrontService 클래스는 알림의 사용자 서비스 개체입니다.  ```js class NoticeFrontService extends BaseNoticeService {     constructor() {         super();          var _this       = this;         var _template   = null;     // Handlebars template          this.command = {             read:       {                 outputOption: 3,                 cbBegin(cmd) {                      cmd.outputOption.index = Number(cmd._model.items._index);                     cmd._model.columns._area_form.value = '';  // form show                 },             },               list:       {                 outputOption: 1,                 cbBegin(cmd) {                     cmd._model.columns._area_form.value = 'd-none'; // form hidden                 },                 cbOutput(outs, cmd, res) {                     if (_template === null) {                         _template = Handlebars.compile( _this.bindModel.columns['_area_temp'].value );                      }                     _this.bindModel.columns['_area_tbody'].value   = _template(res.data);                 },             }         };          this.mapping = {             _area_temp:     { list:     'misc' },             _area_tbody:    { list:     'misc' },             _area_form:     { list:     'misc' },             ntc_idx:        { read:     'bind' },             title:          { read:     'output' },             contents:       { read:     'output' },             create_dt:      { read:     'output' },         };     } } ```","url": "http://localhost:4000/ko/exam/notice-bindmodel/"
  },{
    "title": "BindModel 과 React Mix 비교",
    "excerpt":"## 설명   ## 리액트 폴더 구조 ```js react-mix1/ ├── componets/ │   ├── NoticeAdminPage.js │   ├── NoticeForm.js │   └── NoticeList.js ├── app.js └── admin.html ```  ### NoticeAdminPage.js : React --- 이 코드는 비즈니스 로직과 발표의 핵심을 구현하는 코드입니다.  ```js import React from 'https://esm.sh/react';  import NoticeList from './NoticeList.js'; import NoticeForm from './NoticeForm.js';  const { useState, useEffect } = React;  export default function NoticeAdminPage() {   const [notices, setNotices] = useState([]);   const [selectedNotice, setSelectedNotice] = useState(null);   const [formData, setFormData] = useState({     title: '',     contents: '',     active_cd: 'D',     top_yn: false,   });    useEffect(() => {     fetchNotices();   }, []);    const fetchNotices = async () => {     try {       const response = await axios.get('/notice/data/list.json');       setNotices(response.data.rows);     } catch (error) {       console.error('Failed to fetch notices:', error);     }   };    const handleRead = (notice) => {     setSelectedNotice(notice);     setFormData({       title: notice.title,       contents: notice.contents || '',       active_cd: notice.active_cd || 'D',       top_yn: notice.top_yn === 'Y',     });   };    const handleList = () => {     setSelectedNotice(null);   };    const handleChange = (e) => {     const { name, value, type, checked } = e.target;     setFormData((prevFormData) => ({       ...prevFormData,       [name]: type === 'checkbox' ? checked : value,     }));   };    const handleUpdate = async () => {     if (!formData.title.trim()) {       alert('Title is required.');       return;     }      try {       const response = await axios.put(`data/list/${selectedNotice.ntc_idx}`, formData);       console.log('Notice updated successfully:', response.data);       fetchNotices();       setSelectedNotice(null);     } catch (error) {       console.error('Failed to update notice:', error);     }   };    const handleDelete = async () => {     try {       const response = await axios.delete(`data/list/${selectedNotice.ntc_idx}`);       console.log('Notice deleted successfully:', response.data);       fetchNotices();       setSelectedNotice(null);     } catch (error) {       console.error('Failed to delete notice:', error);     }   };    return (     React.createElement('div', { className: 'container mt-3' },       React.createElement('h2', null, 'Notice Admin Page'),       React.createElement('h5', null, 'Key Features: List inquiry/modification/deletion'),       React.createElement('p', null, 'Data is transmitted when modified or deleted from the test page, but it is not actually processed.'),              !selectedNotice ? (         React.createElement(NoticeList, { notices, handleRead })       ) : (         React.createElement(NoticeForm, {           selectedNotice,           formData,           handleChange,           handleUpdate,           handleDelete,           handleList         })       )     )   ); } ```   ### NoticeAdminPage.js : React 와 BindModel 의 Mix ---  ```js import React, { Component } from 'https://esm.sh/react'; import NoticeList from './NoticeList.js'; import NoticeForm from './NoticeForm.js'; import NoticeAdminService from '../service/notice-admin-svc.js'  export default class NoticeAdminPage extends Component {   constructor(props) {     super(props);          this.bm = new _L.BindModel(new NoticeAdminService(this));       this.bm.url = '/notice/data/list.json';            this.state = { selectedNotice: null };   }    componentDidMount() {     this.bm.cmd['list'].execute();   }    handleList = () => {     this.setState({ selectedNotice: null });   };    handleChange = (e) => {     let { name, value, type, checked } = e.target;     if (type === 'checkbox') value = checked ? 'Y' : 'N';     this.bm.cols[name].value = value;  //  column value setting     this.forceUpdate();           //  Forced screen rendering   };    render() {     const { selectedNotice } = this.state;      return (       React.createElement('div', { className: 'container mt-3' },         React.createElement('h2', null, 'Notice Admin Page'),         React.createElement('h5', null, 'Key Features: List inquiry/modification/deletion'),         React.createElement('p', null, 'Data is transmitted when modified or deleted from the test page, but it is not actually processed.'),                  React.createElement(NoticeList, { bindModel: this.bm }),         !selectedNotice || (           React.createElement(NoticeForm, {             handleChange: this.handleChange,             bindModel: this.bm           })         )       )     );   } } ```  ### notice-admin-svc.js : React 와 BindModel 의 Mix ---  ```js export default class NoticeAdminService {     constructor(reactThis) {         const _this = this;          this.items = {             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res)  {                     if (res) {                       alert('The post has been modified.');                       reactThis.handleList();                     }                   }             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) {                       alert('The post has been deleted.');                       reactThis.handleList();                     }                   }             },             list:       {                 outputOption: 1,                 cbEnd(status, cmd, res) {                     reactThis.setState({ selectedNotice: null });                 }             }         };         this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };         this.fn = {             handleRead: async (idx) => {                 _this.bindModel.cmd['read'].outputOption.index = Number(idx);                 await _this.bindModel.cmd['read'].execute();                 reactThis.setState({ selectedNotice: true });             },         };     }     } ``` ## 비교   > 혼합 코드에서 클래스 구성 요소와 BindModel을 사용하면 다음을 포함하여 React의 건강 관리와 비즈니스 로직을 더 명확하게 분리할 수 있는 이점을 얻을 수 있습니다.  1. 비즈니스 로직의 재사용성 및 유지보수 개선: BindModel을 사용하면 비즈니스 로직과 구성 요소를 분리하고 관리할 수 있습니다. BindModel 내부에 데이터 바인딩 및 API 호출과 같은 로직을 정의함으로써 다른 구성 요소에서도 동일한 로직을 재사용할 수 있으며, 향후 로직 변경 시 유지보수가 용이합니다. 첫 번째 코드처럼 비즈니스 로직을 직접 구현하는 것보다 구조적으로 더 깔끔한 관리가 가능합니다. 2. 데이터 바인딩 일관성: BindModel.this.bm.cols[name].value 와 동일한 방식으로 열 값을 관리하면 사용자 입력과 데이터 변경 사항을 효율적으로 동기화할 수 있어 데이터 바인딩 일관성을 보장할 수 있습니다. 3. 명확한 건강 관리: 클래스 구성 요소는 건강 상태를 명시적으로 관리하며, BindModel과의 상호 작용을 통해 각 데이터의 상태 변화를 더 쉽게 추적할 수 있습니다. 이를 통해 구성 요소 간에 보다 체계적인 건강 관리가 가능합니다. 4. 대규모 프로젝트의 유연성: 이 접근 방식은 크고 복잡한 프로젝트에 특히 유리합니다. BindModel은 여러 구성 요소에서 비즈니스 로직을 일관되게 처리할 수 있도록 지원하며 확장성과 유연성이 뛰어납니다.  결론적으로, 혼합 코드는 특히 대규모 프로젝트나 복잡한 데이터 처리의 경우 코드의 가독성, 유지보수 및 재사용성을 크게 개선하기 위해 React의 상태 관리와 비즈니스 로직을 명확하게 구분합니다.","url": "http://localhost:4000/ko/exam/notice-compare-react/"
  },{
    "title": "notice React Mix compare",
    "excerpt":"## Description   ## React folder structure ```js react-mix1/ ├── componets/ │   ├── NoticeAdminPage.js │   ├── NoticeForm.js │   └── NoticeList.js ├── app.js └── admin.html ```  ### NoticeAdminPage.js : React --- It is a code that implements business logic and core in the announcement.  ```js import React from 'https://esm.sh/react';  import NoticeList from './NoticeList.js'; import NoticeForm from './NoticeForm.js';  const { useState, useEffect } = React;  export default function NoticeAdminPage() {   const [notices, setNotices] = useState([]);   const [selectedNotice, setSelectedNotice] = useState(null);   const [formData, setFormData] = useState({     title: '',     contents: '',     active_cd: 'D',     top_yn: false,   });    useEffect(() => {     fetchNotices();   }, []);    const fetchNotices = async () => {     try {       const response = await axios.get('/notice/data/list.json');       setNotices(response.data.rows);     } catch (error) {       console.error('Failed to fetch notices:', error);     }   };    const handleRead = (notice) => {     setSelectedNotice(notice);     setFormData({       title: notice.title,       contents: notice.contents || '',       active_cd: notice.active_cd || 'D',       top_yn: notice.top_yn === 'Y',     });   };    const handleList = () => {     setSelectedNotice(null);   };    const handleChange = (e) => {     const { name, value, type, checked } = e.target;     setFormData((prevFormData) => ({       ...prevFormData,       [name]: type === 'checkbox' ? checked : value,     }));   };    const handleUpdate = async () => {     if (!formData.title.trim()) {       alert('Title is required.');       return;     }      try {       const response = await axios.put(`data/list/${selectedNotice.ntc_idx}`, formData);       console.log('Notice updated successfully:', response.data);       fetchNotices();       setSelectedNotice(null);     } catch (error) {       console.error('Failed to update notice:', error);     }   };    const handleDelete = async () => {     try {       const response = await axios.delete(`data/list/${selectedNotice.ntc_idx}`);       console.log('Notice deleted successfully:', response.data);       fetchNotices();       setSelectedNotice(null);     } catch (error) {       console.error('Failed to delete notice:', error);     }   };    return (     React.createElement('div', { className: 'container mt-3' },       React.createElement('h2', null, 'Notice Admin Page'),       React.createElement('h5', null, 'Key Features: List inquiry/modification/deletion'),       React.createElement('p', null, 'Data is transmitted when modified or deleted from the test page, but it is not actually processed.'),              !selectedNotice ? (         React.createElement(NoticeList, { notices, handleRead })       ) : (         React.createElement(NoticeForm, {           selectedNotice,           formData,           handleChange,           handleUpdate,           handleDelete,           handleList         })       )     )   ); } ```   ### NoticeAdminPage.js : Mix React and BindModel ---  ```js import React, { Component } from 'https://esm.sh/react'; import NoticeList from './NoticeList.js'; import NoticeForm from './NoticeForm.js'; import NoticeAdminService from '../service/notice-admin-svc.js'  export default class NoticeAdminPage extends Component {   constructor(props) {     super(props);          this.bm = new _L.BindModel(new NoticeAdminService(this));       this.bm.url = '/notice/data/list.json';            this.state = { selectedNotice: null };   }    componentDidMount() {     this.bm.cmd['list'].execute();   }    handleList = () => {     this.setState({ selectedNotice: null });   };    handleChange = (e) => {     let { name, value, type, checked } = e.target;     if (type === 'checkbox') value = checked ? 'Y' : 'N';     this.bm.cols[name].value = value;  //  column value setting     this.forceUpdate();           //  Forced screen rendering   };    render() {     const { selectedNotice } = this.state;      return (       React.createElement('div', { className: 'container mt-3' },         React.createElement('h2', null, 'Notice Admin Page'),         React.createElement('h5', null, 'Key Features: List inquiry/modification/deletion'),         React.createElement('p', null, 'Data is transmitted when modified or deleted from the test page, but it is not actually processed.'),                  React.createElement(NoticeList, { bindModel: this.bm }),         !selectedNotice || (           React.createElement(NoticeForm, {             handleChange: this.handleChange,             bindModel: this.bm           })         )       )     );   } } ```  ### notice-admin-svc.js : Mix Vue and BindModel ---  ```js export default class NoticeAdminService {     constructor(reactThis) {         const _this = this;          this.items = {             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res)  {                     if (res) {                       alert('The post has been modified.');                       reactThis.handleList();                     }                   }             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) {                       alert('The post has been deleted.');                       reactThis.handleList();                     }                   }             },             list:       {                 outputOption: 1,                 cbEnd(status, cmd, res) {                     reactThis.setState({ selectedNotice: null });                 }             }         };         this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };         this.fn = {             handleRead: async (idx) => {                 _this.bindModel.cmd['read'].outputOption.index = Number(idx);                 await _this.bindModel.cmd['read'].execute();                 reactThis.setState({ selectedNotice: true });             },         };     }     } ``` ## Comparison   > The use of class components and BindModel in the mixed code provides the benefits of providing a clearer separation of React's health management and business logic, including.  1. Improved Reusability and Maintenance of Business Logic: BindModel lets you separate and manage business logic from components. By defining logic such as data binding and API calls inside BindModel, the same logic can be reused by other components, and maintenance is easy in the event of future logic changes. Structurally cleaner management is possible than implementing business logic directly like the first code. 2. Data Binding Consistency: You can ensure data binding consistency by explicitly connecting data with screen elements via BindModel.Managing column values in the same way as this.bm .cols[name].value allows you to efficiently synchronize user input with data changes. 3. Clear health management: Class components explicitly manage health conditions, and interaction with BindModel makes it easier to track changes in the state of each data. This allows for more systematic health management between components. 4. Flexibility in large-scale projects: This approach is particularly advantageous for large and complex projects. BindModel helps ensure consistent handling of business logic across multiple components, and is highly scalable and flexible.  In conclusion, the mixed code provides a clear separation between React's state management and business logic to significantly improve the readability, maintenance, and reusability of the code, especially for large-scale projects or complex data processing.","url": "http://localhost:4000/en/exam/notice-compare-react/"
  },{
    "title": "BindModel 과 Vue Mix 비교",
    "excerpt":"## 설명  ## 폴더 구조 ```js vue-mix/ ├── componets/ │   ├── NoticeForm.js │   └── NoticeList.js ├── app.js └── admin.html ```  ### app.js : Vue --- 이 코드는 비즈니스 로직과 발표의 핵심을 구현하는 코드입니다.  ```js import NoticeList from './components/NoticeList.js'; import NoticeForm from './components/NoticeForm.js';  const { createApp, ref } = Vue  const app = createApp({   data() {     return {       notices: [],       selectedNotice: null,       statusOptions: {         'D': 'Standby',         'A': 'Activation',         'H': 'Hidden'       }     };   },   methods: {     fetchNotices() {       axios.get('/notice/data/list.json')       .then(response => {         this.notices = response.data.rows.map(row => ({           ntc_idx: row.ntc_idx,           title: row.title,           contents: row.contents,           top_yn: row.top_yn,           active_cd: row.active_cd,           create_dt: row.create_dt         })) || [];       })       .catch(error => {         console.error('Error fetching notices:', error);       });     },     selectNotice(notice) {       this.selectedNotice = notice;       axios.get(`/notice/data/list.json`)  // RESTful : `/notice/data/${ntc_idx}.json`         .then(response => {           const notice = response.data;           this.selectedNotice = {             ntc_idx: notice.ntc_idx,             title: notice.title,             contents: notice.contents,              top_yn: notice.top_yn,             active_cd: notice.active_cd,             create_dt: notice.create_dt           };         })         .catch(error => {           console.error('Error reading notice:', error);         });     },     deselectNotice() {       this.selectedNotice = null;     },     updateNotice(notice) {       const isValid = this.validateNotice(notice);        if (isValid) {         axios.put(`/notice/data/list.json`, notice) // RESTful : '/notice/update/${notice.ntc_idx}`           .then(() => {             console.warn('Caution: Send to the test server, but the data is not reflected.', notice);             this.deselectNotice();           })           .catch(error => {             console.error('Error updating notice:', error);           });       } else {         alert('Validation failed');       }     },     deleteNotice(idx) {       const deleteNotice = {         ntc_idx: idx       };       if (confirm('Are you sure you want to delete it?')){         axios.delete(`/notice/data/list.json`, deleteNotice)  // RESTful : `/notice/delete/${ntc_idx}`           .then(() => {             console.warn('Caution: Send to the test server, but the data is not reflected.', deleteNotice);             this.deselectNotice();             // 삭제 후 공지사항 목록을 다시 불러옴             this.fetchNotices();           })           .catch(error => {             console.error('Error deleting notice:', error);           });       }     },     validateNotice(notice) {       let isValid = true;       if (!notice.title || notice.title === '') {         isValid = false;       }       if (!notice.top_yn || (notice.top_yn !== 'Y' && notice.top_yn !== 'N')) {         isValid = false;       }       if (!notice.active_cd || (notice.active_cd !== 'D' && notice.active_cd !== 'A' && notice.active_cd !== 'H')) {         isValid = false;       }       return isValid;     }   },   mounted() {     this.fetchNotices();   },   components: {     'notice-list': NoticeList,     'notice-form': NoticeForm   } });  app.mount('#app'); ```   ### app.js : Vue 와 BindModel Mix ---  ```js import NoticeList from './components/NoticeList.js'; import NoticeForm from './components/NoticeForm.js'; import NoticeAdminService from './service/notice-admin-svc.js'  const { createApp, ref } = Vue const bm = new _L.BindModel(new NoticeAdminService());    bm.url =' /notice/data/list.json';  const app = createApp({   data() {     return {       notices: [],       selectedNotice: null,       statusOptions: {         'D': 'Standby',         'A': 'Activation',         'H': 'Hidden'       },       bindModel: bm,     };   },   methods: {     selectNotice(idx) {       this.selectedNotice = idx;     },     deselectNotice() {       this.selectedNotice = null;     },   },   components: {     'notice-list': NoticeList,     'notice-form': NoticeForm   } });  app.mount('#app'); ```  ### notice-admin-svc.js : Vue 와 BindModel Mix ---  ```js export default class NoticeAdminService {     constructor() {         var _this       = this;         var _template   = null;     // Handlebars template          this.items = {             ntc_idx: { required: true },             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             list:       {                 outputOption: 1,             }         };          this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };     }     } ``` ## 비교  1. 비즈니스 로직의 격리 및 재사용 가능성: 두 번째 코드는 비즈니스 로직을 BindModel과 NoticeAdminService를 사용하여 별도의 클래스로 분리했습니다. 따라서 비즈니스 로직은 Vue 구성 요소와 분리되어 재사용할 수 있습니다. 이 구조를 통해 다른 Vue 구성 요소나 프로젝트에서 동일한 비즈니스 로직을 재활용할 수 있어 유지보수 및 확장성이 크게 향상됩니다. 2. 데이터 바인딩의 단순성: BindModel을 사용하여 데이터를 가져오는 것과 같은 논리를 캡슐화하면 Vue 구성 요소에 대한 메서드 수를 줄일 수 있습니다. 첫 번째 코드는 직접 축시오스 호출을 사용하지만 두 번째 코드는 BindModel에서 이를 담당하므로 코드가 훨씬 간단해집니다. 3. 유지보수 및 확장성: 비즈니스 로직은 Vue 구성 요소에 직접 의존하지 않기 때문에 향후 API 변경이나 서비스 로직 변경은 NoticeAdminService에서만 수정할 수 있습니다. 이렇게 하면 코드 유지보수가 간소화됩니다. 반면에 첫 번째 코드는 Vue 구성 요소 내부에 비즈니스 로직이 포함되어 있어 로직을 변경할 때 여러 구성 요소를 수정해야 할 수 있습니다. 4. 테스트 가능성 향상: 두 번째 방법은 비즈니스 로직을 별도의 클래스로 분리했기 때문에 해당 클래스에 대해 독립적으로 단위 테스트를 작성할 수 있습니다. Vue 구성 요소 내부의 비즈니스 로직은 테스트하기가 더 복잡하지만 BindModel 방법은 테스트 가능한 코드 구조를 제공합니다.  > 결론적으로 두 번째 코드의 장점은 비즈니스 로직을 분리하여 코드의 재사용 가능성, 유지보수 및 테스트 가능성을 높이는 것입니다. ","url": "http://localhost:4000/ko/exam/notice-compare-vue/"
  },{
    "title": "notice Vue Mix compare",
    "excerpt":"## Description   ## folder structure ```js vue-mix/ ├── componets/ │   ├── NoticeForm.js │   └── NoticeList.js ├── app.js └── admin.html ```  ### app.js : Vue --- It is a code that implements business logic and core in the announcement. ```js import NoticeList from './components/NoticeList.js'; import NoticeForm from './components/NoticeForm.js';  const { createApp, ref } = Vue  const app = createApp({   data() {     return {       notices: [],       selectedNotice: null,       statusOptions: {         'D': 'Standby',         'A': 'Activation',         'H': 'Hidden'       }     };   },   methods: {     fetchNotices() {       axios.get('/notice/data/list.json')       .then(response => {         this.notices = response.data.rows.map(row => ({           ntc_idx: row.ntc_idx,           title: row.title,           contents: row.contents,           top_yn: row.top_yn,           active_cd: row.active_cd,           create_dt: row.create_dt         })) || [];       })       .catch(error => {         console.error('Error fetching notices:', error);       });     },     selectNotice(notice) {       this.selectedNotice = notice;       axios.get(`/notice/data/list.json`)  // RESTful : `/notice/data/${ntc_idx}.json`         .then(response => {           const notice = response.data;           this.selectedNotice = {             ntc_idx: notice.ntc_idx,             title: notice.title,             contents: notice.contents,              top_yn: notice.top_yn,             active_cd: notice.active_cd,             create_dt: notice.create_dt           };         })         .catch(error => {           console.error('Error reading notice:', error);         });     },     deselectNotice() {       this.selectedNotice = null;     },     updateNotice(notice) {       const isValid = this.validateNotice(notice);        if (isValid) {         axios.put(`/notice/data/list.json`, notice) // RESTful : '/notice/update/${notice.ntc_idx}`           .then(() => {             console.warn('Caution: Send to the test server, but the data is not reflected.', notice);             this.deselectNotice();           })           .catch(error => {             console.error('Error updating notice:', error);           });       } else {         alert('Validation failed');       }     },     deleteNotice(idx) {       const deleteNotice = {         ntc_idx: idx       };       if (confirm('Are you sure you want to delete it?')){         axios.delete(`/notice/data/list.json`, deleteNotice)  // RESTful : `/notice/delete/${ntc_idx}`           .then(() => {             console.warn('Caution: Send to the test server, but the data is not reflected.', deleteNotice);             this.deselectNotice();             // 삭제 후 공지사항 목록을 다시 불러옴             this.fetchNotices();           })           .catch(error => {             console.error('Error deleting notice:', error);           });       }     },     validateNotice(notice) {       let isValid = true;       if (!notice.title || notice.title === '') {         isValid = false;       }       if (!notice.top_yn || (notice.top_yn !== 'Y' && notice.top_yn !== 'N')) {         isValid = false;       }       if (!notice.active_cd || (notice.active_cd !== 'D' && notice.active_cd !== 'A' && notice.active_cd !== 'H')) {         isValid = false;       }       return isValid;     }   },   mounted() {     this.fetchNotices();   },   components: {     'notice-list': NoticeList,     'notice-form': NoticeForm   } });  app.mount('#app'); ```   ### app.js : Mix Vue and BindModel ---  ```js import NoticeList from './components/NoticeList.js'; import NoticeForm from './components/NoticeForm.js'; import NoticeAdminService from './service/notice-admin-svc.js'  const { createApp, ref } = Vue const bm = new _L.BindModel(new NoticeAdminService());    bm.url =' /notice/data/list.json';  const app = createApp({   data() {     return {       notices: [],       selectedNotice: null,       statusOptions: {         'D': 'Standby',         'A': 'Activation',         'H': 'Hidden'       },       bindModel: bm,     };   },   methods: {     selectNotice(idx) {       this.selectedNotice = idx;     },     deselectNotice() {       this.selectedNotice = null;     },   },   components: {     'notice-list': NoticeList,     'notice-form': NoticeForm   } });  app.mount('#app'); ```  ### notice-admin-svc.js : Mix Vue and BindModel ---  ```js export default class NoticeAdminService {     constructor() {         var _this       = this;         var _template   = null;     // Handlebars template          this.items = {             ntc_idx: { required: true },             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             list:       {                 outputOption: 1,             }         };          this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };     }     } ```  ## Comparison  1. Isolation and Reusability of Business Logic: The second code separated business logic into separate classes using BindModel and NoticeAdminService. This makes business logic separate from Vue components and reusable. This structure allows the same business logic to be recycled from other Vue components or projects, greatly improving maintenance and scalability. 2. Simplicity of data binding: By encapsulating logic, such as importing data using BindModel, you can reduce the number of methods for Vue components. The first code uses direct axios calls, but the second code is responsible for this at BindModel, which makes the code much simpler. 3. Maintenance and scalability: Because business logic is not directly dependent on Vue components, future API changes or service logic changes can only be modified by the NoticeAdminService. This simplifies the maintenance of the code. On the other hand, the first code contains business logic inside the Vue component, which may require modifying several components when changing logic. 4. Improved testability: The second method separated the business logic into separate classes, so unit tests can be written independently for that class. The business logic inside the Vue component is more complex to test, but the BindModel method provides a testable code structure.  > In conclusion, the advantage of the second code is to separate the business logic, increasing the reusability, maintenance, and testability of the code.","url": "http://localhost:4000/en/exam/notice-compare-vue/"
  },{
    "title": "React Mix 예제",
    "excerpt":"## 설명  \"Notice\"의 예로 사용자 페이지를 페이지로 제외했습니다.  ## 폴더 구조  ```js react-mix1/ ├── componets/ │   ├── NoticeAdminPage.js │   ├── NoticeForm.js │   └── NoticeList.js ├── service/ │   └── notice-admin-svc.js ├── app.js └── admin.html ```  ### admin.html ---  ```html            Notice Admin Page - React                 ```  ### app.js ---  ```js  import React from 'https://esm.sh/react'; import ReactDOM from 'https://esm.sh/react-dom'; import NoticeAdminPage from './components/NoticeAdminPage.js';  function App() {   return React.createElement(NoticeAdminPage); }  ReactDOM.render(   React.createElement(App),   document.getElementById('root') ); ```  ### service/notice-admin-svc.js ---  ```js class NoticeAdminService {     constructor(reactThis) {         const _this = this;          this.items = {             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res)  {                     if (res) {                       alert('The post has been modified.');                       reactThis.handleList();                     }                   }             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) {                       alert('The post has been deleted.');                       reactThis.handleList();                     }                   }             },             list:       {                 outputOption: 1,                 cbEnd(status, cmd, res) {                     reactThis.setState({ selectedNotice: null });                 }             }         };         this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };         this.fn = {             handleRead: async (idx) => {                 _this.bindModel.cmd['read'].outputOption.index = Number(idx);                 await _this.bindModel.cmd['read'].execute();                 reactThis.setState({ selectedNotice: true });             },         };     }     }  export {     NoticeAdminService as default,     NoticeAdminService } ```   ### components/NoticeAdminPage.js ---  ```js import React, { Component } from 'https://esm.sh/react'; import NoticeList from './NoticeList.js'; import NoticeForm from './NoticeForm.js'; import NoticeAdminService from '../service/notice-admin-svc.js'  export default class NoticeAdminPage extends Component {   constructor(props) {     super(props);          this.bm = new _L.BindModel(new NoticeAdminService(this));       this.bm.url = '/notice/data/list.json';            this.state = { selectedNotice: null };   }    componentDidMount() {     this.bm.cmd['list'].execute();   }    handleList = () => {     this.setState({ selectedNotice: null });   };    handleChange = (e) => {     let { name, value, type, checked } = e.target;     if (type === 'checkbox') value = checked ? 'Y' : 'N';     this.bm.cols[name].value = value;  //  column value setting     this.forceUpdate();           //  Forced screen rendering   };    render() {     const { selectedNotice } = this.state;      return (       React.createElement('div', { className: 'container mt-3' },         React.createElement('h2', null, 'Notice Admin Page'),         React.createElement('h5', null, 'Key Features: List inquiry/modification/deletion'),         React.createElement('p', null, 'Data is transmitted when modified or deleted from the test page, but it is not actually processed.'),                  React.createElement(NoticeList, { bindModel: this.bm }),         !selectedNotice || (           React.createElement(NoticeForm, {             handleChange: this.handleChange,             bindModel: this.bm           })         )       )     );   } } ```   ### components/NoticeForm.js ---  ```js import React, { Component } from 'https://esm.sh/react';  export default class NoticeForm extends Component {   render() {     const { handleChange, bindModel } = this.props;      return (       React.createElement('div', { id: 'class-form' },         React.createElement('form', null,           React.createElement('div', { className: 'form-group' },             React.createElement('label', {}, '날짜'),             React.createElement('p', { id: 'create_dt' }, bindModel.cols.create_dt.value)           ),           React.createElement('div', { className: 'form-group' },             React.createElement('label', { htmlFor: 'title' }, 'Title'),             React.createElement('input', {               type: 'text',               className: 'form-control',               id: 'title',               name: 'title',               value: bindModel.cols.title.value,               onChange: handleChange             })           ),           React.createElement('div', { className: 'form-group' },             React.createElement('label', { htmlFor: 'contents' }, 'Content'),             React.createElement('textarea', {               className: 'form-control',               id: 'contents',               name: 'contents',               rows: '3',               value: bindModel.cols.contents.value,               onChange: handleChange             })           ),           React.createElement('div', { className: 'row' },             React.createElement('div', { className: 'col' },               React.createElement('div', { className: 'form-check' },                 React.createElement('input', {                   type: 'checkbox',                   className: 'form-check-input',                   id: 'check1',                   name: 'top_yn',                   checked: bindModel.cols.top_yn.value === 'Y',                   onChange: handleChange                 }),                 React.createElement('label', { className: 'form-check-label', htmlFor: 'check1' }, 'top notice')               )             ),             React.createElement('div', { className: 'col' },               ['D', 'A', 'H'].map(value => (                 React.createElement('div', { className: 'form-check', key: value },                   React.createElement('input', {                     type: 'radio',                     className: 'form-check-input',                     id: `radio${value}`,                     name: 'active_cd',                     value: value,                     checked: bindModel.cols.active_cd.value === value,                     onChange: handleChange                   }),                   React.createElement('label', { className: 'form-check-label', htmlFor: `radio${value}` },                     value === 'D' ? 'Standby' : value === 'A' ? 'Activation' : 'Hidden'                   )                 )               ))             )           )         ),         React.createElement('button', { type: 'button', className: 'btn btn-primary mt-3', onClick: ()=> bindModel.cmd['update'].execute() }, 'Update'),         React.createElement('button', { type: 'button', className: 'btn btn-primary mt-3', onClick: ()=> bindModel.cmd['delete'].execute() }, 'Delete'),         React.createElement('button', { type: 'button', className: 'btn btn-primary mt-3', onClick: ()=> bindModel.cmd['list'].execute() }, 'List')       )     );   } } ```   ### components/NoticeList.js ---  ```js import React, { Component } from 'https://esm.sh/react';  export default class NoticeList extends Component {   render() {     const { bindModel } = this.props;     const rows = bindModel.cmd.list.output.rows;      return (       React.createElement('table', { className: 'table' },         React.createElement('thead', null,           React.createElement('tr', null,             React.createElement('th', null, 'Title'),             React.createElement('th', null, 'Status'),             React.createElement('th', null, 'Date')           )         ),         React.createElement('tbody', null,           rows.count > 0 ? (             rows.map((notice, i) => (               React.createElement('tr', { key: notice.ntc_idx },                 React.createElement('td', null,                   React.createElement('a', { href: '#', onClick: () => bindModel.fn.handleRead(i), className: 'btnNormal' },                     notice.title                   )                 ),                 React.createElement('td', null, notice.active_cd),                 React.createElement('td', null, notice.create_dt)               )             ))           ) : (             React.createElement('tr', null,               React.createElement('td', { colSpan: '3' }, 'There is no content.')             )           )         )       )     );   } } ```    ","url": "http://localhost:4000/ko/exam/notice-mix-react/"
  },{
    "title": "notice React Mix",
    "excerpt":"## Description  As an example of \"Notice\", we excluded the user page as a page.  ## folder structure ```js react-mix1/ ├── componets/ │   ├── NoticeAdminPage.js │   ├── NoticeForm.js │   └── NoticeList.js ├── service/ │   └── notice-admin-svc.js ├── app.js └── admin.html ```  ### admin.html ---  ```html            Notice Admin Page - React                 ```  ### app.js ---  ```js  import React from 'https://esm.sh/react'; import ReactDOM from 'https://esm.sh/react-dom'; import NoticeAdminPage from './components/NoticeAdminPage.js';  function App() {   return React.createElement(NoticeAdminPage); }  ReactDOM.render(   React.createElement(App),   document.getElementById('root') ); ```  ### service/notice-admin-svc.js ---  ```js class NoticeAdminService {     constructor(reactThis) {         const _this = this;          this.items = {             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res)  {                     if (res) {                       alert('The post has been modified.');                       reactThis.handleList();                     }                   }             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },                 cbEnd(status, cmd, res) {                     if (res) {                       alert('The post has been deleted.');                       reactThis.handleList();                     }                   }             },             list:       {                 outputOption: 1,                 cbEnd(status, cmd, res) {                     reactThis.setState({ selectedNotice: null });                 }             }         };         this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };         this.fn = {             handleRead: async (idx) => {                 _this.bindModel.cmd['read'].outputOption.index = Number(idx);                 await _this.bindModel.cmd['read'].execute();                 reactThis.setState({ selectedNotice: true });             },         };     }     }  export {     NoticeAdminService as default,     NoticeAdminService } ```   ### components/NoticeAdminPage.js ---  ```js import React, { Component } from 'https://esm.sh/react'; import NoticeList from './NoticeList.js'; import NoticeForm from './NoticeForm.js'; import NoticeAdminService from '../service/notice-admin-svc.js'  export default class NoticeAdminPage extends Component {   constructor(props) {     super(props);          this.bm = new _L.BindModel(new NoticeAdminService(this));       this.bm.url = '/notice/data/list.json';            this.state = { selectedNotice: null };   }    componentDidMount() {     this.bm.cmd['list'].execute();   }    handleList = () => {     this.setState({ selectedNotice: null });   };    handleChange = (e) => {     let { name, value, type, checked } = e.target;     if (type === 'checkbox') value = checked ? 'Y' : 'N';     this.bm.cols[name].value = value;  //  column value setting     this.forceUpdate();           //  Forced screen rendering   };    render() {     const { selectedNotice } = this.state;      return (       React.createElement('div', { className: 'container mt-3' },         React.createElement('h2', null, 'Notice Admin Page'),         React.createElement('h5', null, 'Key Features: List inquiry/modification/deletion'),         React.createElement('p', null, 'Data is transmitted when modified or deleted from the test page, but it is not actually processed.'),                  React.createElement(NoticeList, { bindModel: this.bm }),         !selectedNotice || (           React.createElement(NoticeForm, {             handleChange: this.handleChange,             bindModel: this.bm           })         )       )     );   } } ```   ### components/NoticeForm.js ---  ```js import React, { Component } from 'https://esm.sh/react';  export default class NoticeForm extends Component {   render() {     const { handleChange, bindModel } = this.props;      return (       React.createElement('div', { id: 'class-form' },         React.createElement('form', null,           React.createElement('div', { className: 'form-group' },             React.createElement('label', {}, '날짜'),             React.createElement('p', { id: 'create_dt' }, bindModel.cols.create_dt.value)           ),           React.createElement('div', { className: 'form-group' },             React.createElement('label', { htmlFor: 'title' }, 'Title'),             React.createElement('input', {               type: 'text',               className: 'form-control',               id: 'title',               name: 'title',               value: bindModel.cols.title.value,               onChange: handleChange             })           ),           React.createElement('div', { className: 'form-group' },             React.createElement('label', { htmlFor: 'contents' }, 'Content'),             React.createElement('textarea', {               className: 'form-control',               id: 'contents',               name: 'contents',               rows: '3',               value: bindModel.cols.contents.value,               onChange: handleChange             })           ),           React.createElement('div', { className: 'row' },             React.createElement('div', { className: 'col' },               React.createElement('div', { className: 'form-check' },                 React.createElement('input', {                   type: 'checkbox',                   className: 'form-check-input',                   id: 'check1',                   name: 'top_yn',                   checked: bindModel.cols.top_yn.value === 'Y',                   onChange: handleChange                 }),                 React.createElement('label', { className: 'form-check-label', htmlFor: 'check1' }, 'top notice')               )             ),             React.createElement('div', { className: 'col' },               ['D', 'A', 'H'].map(value => (                 React.createElement('div', { className: 'form-check', key: value },                   React.createElement('input', {                     type: 'radio',                     className: 'form-check-input',                     id: `radio${value}`,                     name: 'active_cd',                     value: value,                     checked: bindModel.cols.active_cd.value === value,                     onChange: handleChange                   }),                   React.createElement('label', { className: 'form-check-label', htmlFor: `radio${value}` },                     value === 'D' ? 'Standby' : value === 'A' ? 'Activation' : 'Hidden'                   )                 )               ))             )           )         ),         React.createElement('button', { type: 'button', className: 'btn btn-primary mt-3', onClick: ()=> bindModel.cmd['update'].execute() }, 'Update'),         React.createElement('button', { type: 'button', className: 'btn btn-primary mt-3', onClick: ()=> bindModel.cmd['delete'].execute() }, 'Delete'),         React.createElement('button', { type: 'button', className: 'btn btn-primary mt-3', onClick: ()=> bindModel.cmd['list'].execute() }, 'List')       )     );   } } ```   ### components/NoticeList.js ---  ```js import React, { Component } from 'https://esm.sh/react';  export default class NoticeList extends Component {   render() {     const { bindModel } = this.props;     const rows = bindModel.cmd.list.output.rows;      return (       React.createElement('table', { className: 'table' },         React.createElement('thead', null,           React.createElement('tr', null,             React.createElement('th', null, 'Title'),             React.createElement('th', null, 'Status'),             React.createElement('th', null, 'Date')           )         ),         React.createElement('tbody', null,           rows.count > 0 ? (             rows.map((notice, i) => (               React.createElement('tr', { key: notice.ntc_idx },                 React.createElement('td', null,                   React.createElement('a', { href: '#', onClick: () => bindModel.fn.handleRead(i), className: 'btnNormal' },                     notice.title                   )                 ),                 React.createElement('td', null, notice.active_cd),                 React.createElement('td', null, notice.create_dt)               )             ))           ) : (             React.createElement('tr', null,               React.createElement('td', { colSpan: '3' }, 'There is no content.')             )           )         )       )     );   } } ```    ","url": "http://localhost:4000/en/exam/notice-mix-react/"
  },{
    "title": "Vue Mix 예제",
    "excerpt":"## 설명  \"Notice\"의 예로 사용자 페이지를 페이지로 제외했습니다.  ## 폴더 구조 ```js vue-mix/ ├── componets/ │   ├── NoticeForm.js │   └── NoticeList.js ├── service/ │   └── notice-admin-svc.js ├── app.js └── admin.html ```  ### admin.html ---  ```html      Notice Admin Page               Notice Admin Page    Key Features: List inquiry/modification/deletion    Data is transmitted when modified or deleted from the test page, but it is not actually processed.                      ```  ### app.js ---  ```js import NoticeList from './components/NoticeList.js'; import NoticeForm from './components/NoticeForm.js'; import NoticeAdminService from './service/notice-admin-svc.js'  const { createApp, ref } = Vue const bm = new _L.BindModel(new NoticeAdminService());    bm.url =' /notice/data/list.json';  const app = createApp({   data() {     return {       notices: [],       selectedNotice: null,       statusOptions: {         'D': 'Standby',         'A': 'Activation',         'H': 'Hidden'       },       bindModel: bm,     };   },   methods: {     selectNotice(idx) {       this.selectedNotice = idx;     },     deselectNotice() {       this.selectedNotice = null;     },   },   components: {     'notice-list': NoticeList,     'notice-form': NoticeForm   } });  app.mount('#app'); ```  ### service/notice-admin-svc.js ---  ```js class NoticeAdminService {     constructor() {         var _this       = this;         var _template   = null;     // Handlebars template          this.items = {             ntc_idx: { required: true },             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             list:       {                 outputOption: 1,             }         };          this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };     }     }  export {     NoticeAdminService as default,     NoticeAdminService } ```  ### components/NoticeForm.js ---  ```js export default {     props: ['statusOptions', 'bindModel'],     data() {       return {         formData: { ...this.notice }       };     },     emits: ['deselect-notice'],     template: `                                        날짜             {{ bindModel.cols.create_dt.value }}                                    Title                                                Content                                                                                                 Top notice                                                                                          {{ label }}                                                  Update           Delete           List                     `,     async created() {       var _this = this;        this.bindModel.cmd['update'].cbEnd = function(status, cmd, res) {         if (res) {           alert('The post has been modified.');           _this.$emit('deselect-notice');         }       };       this.bindModel.cmd['delete'].cbEnd = function(status, cmd, res) {         if (res) {           alert('The post has been deleted.');           _this.$emit('deselect-notice');         }       };     },     methods: {       updateClick() {         for (var prop in this.formData) {           this.bindModel.columns[prop].value = this.formData[prop];         }         this.bindModel.cmd['update'].execute();       },       deleteClick() {         this.bindModel.cmd['delete'].execute();       }      }   }; ```  ### components/NoticeList.js ---  ```js export default {     props: ['bindModel'],     emits: ['select-notice'],     template: `                                        Title             Status             Date                                                     There is no content.                                   {{ notice.title }}             {{ notice.active_cd }}             {{ notice.create_dt }}                                `,     async created() {            await this.bindModel.cmd['list'].execute();     },     methods: {       async readClick(idx) {         this.bindModel.cmd['read'].outputOption.index = Number(idx);         await this.bindModel.cmd['read'].execute();         this.$emit('select-notice', idx);       }     }   }; ```   ","url": "http://localhost:4000/ko/exam/notice-mix-vue/"
  },{
    "title": "notice Vue Mix",
    "excerpt":"## Description  As an example of \"Notice\", we excluded the user page as a page.  ## folder structure ```js vue-mix/ ├── componets/ │   ├── NoticeForm.js │   └── NoticeList.js ├── service/ │   └── notice-admin-svc.js ├── app.js └── admin.html ```  ### admin.html ---  ```html      Notice Admin Page               Notice Admin Page    Key Features: List inquiry/modification/deletion    Data is transmitted when modified or deleted from the test page, but it is not actually processed.                      ```  ### app.js ---  ```js import NoticeList from './components/NoticeList.js'; import NoticeForm from './components/NoticeForm.js'; import NoticeAdminService from './service/notice-admin-svc.js'  const { createApp, ref } = Vue const bm = new _L.BindModel(new NoticeAdminService());    bm.url =' /notice/data/list.json';  const app = createApp({   data() {     return {       notices: [],       selectedNotice: null,       statusOptions: {         'D': 'Standby',         'A': 'Activation',         'H': 'Hidden'       },       bindModel: bm,     };   },   methods: {     selectNotice(idx) {       this.selectedNotice = idx;     },     deselectNotice() {       this.selectedNotice = null;     },   },   components: {     'notice-list': NoticeList,     'notice-form': NoticeForm   } });  app.mount('#app'); ```  ### service/notice-admin-svc.js ---  ```js class NoticeAdminService {     constructor() {         var _this       = this;         var _template   = null;     // Handlebars template          this.items = {             ntc_idx: { required: true },             title: { required: true }         },         this.command = {             create:     {             },             read:       {                 outputOption: 3,             },             update:     {                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             delete:     {                 cbValid(valid, cmd) {                      if (confirm('Are you sure you want to delete it?')) return true;                 },                 cbBind(bind, cmd, setup) {                     console.warn('Caution: Send to the test server, but the data is not reflected.', setup.data);                 },             },             list:       {                 outputOption: 1,             }         };          this.mapping = {             ntc_idx:    { read:     ['bind', 'output'],     update:  'bind',               delete:     ['valid', 'bind'] },             title:      { read:     'output',               update:  ['valid', 'bind'], },             contents:   { read:     'output',               update:  'bind' },             top_yn:     { read:     'output',               update:  ['valid', 'bind'], },             active_cd:  { read:     'output',               update:  ['valid', 'bind'], },             create_dt:  { read:     'output' },         };     }     }  export {     NoticeAdminService as default,     NoticeAdminService } ```  ### components/NoticeForm.js ---  ```js export default {     props: ['statusOptions', 'bindModel'],     data() {       return {         formData: { ...this.notice }       };     },     emits: ['deselect-notice'],     template: `                                        날짜             {{ bindModel.cols.create_dt.value }}                                    Title                                                Content                                                                                                 Top notice                                                                                          {{ label }}                                                  Update           Delete           List                     `,     async created() {       var _this = this;        this.bindModel.cmd['update'].cbEnd = function(status, cmd, res) {         if (res) {           alert('The post has been modified.');           _this.$emit('deselect-notice');         }       };       this.bindModel.cmd['delete'].cbEnd = function(status, cmd, res) {         if (res) {           alert('The post has been deleted.');           _this.$emit('deselect-notice');         }       };     },     methods: {       updateClick() {         for (var prop in this.formData) {           this.bindModel.columns[prop].value = this.formData[prop];         }         this.bindModel.cmd['update'].execute();       },       deleteClick() {         this.bindModel.cmd['delete'].execute();       }      }   }; ```  ### components/NoticeList.js ---  ```js export default {     props: ['bindModel'],     emits: ['select-notice'],     template: `                                        Title             Status             Date                                                     There is no content.                                   {{ notice.title }}             {{ notice.active_cd }}             {{ notice.create_dt }}                                `,     async created() {            await this.bindModel.cmd['list'].execute();     },     methods: {       async readClick(idx) {         this.bindModel.cmd['read'].outputOption.index = Number(idx);         await this.bindModel.cmd['read'].execute();         this.$emit('select-notice', idx);       }     }   }; ```   ","url": "http://localhost:4000/en/exam/notice-mix-vue/"
  },{
    "title": "Notice example",
    "excerpt":"## 예제 화면  ![image-left](/assets/images/notice-800.gif){: .align-center}   ## 환경 구성  ```sh git clone https://github.com/white-base/exam-bind-model.git cd exam-bind-model npx serve ```  ## props drilling 이슈  리액트, 뷰, 앵글을 사용한 props drilling 문제는 데이터를 중앙에서 관리하고 비즈니스 로직을 명확하게 분리하여 유지보수 및 재사용성을 크게 개선하는 BindModel을 통해 한꺼번에 해결할 수 있습니다.  BindModel의 구성 요소인 MetaTable과 MetaView는 표준 인터페이스로 정의되어 화면 구성이 더욱 유연해집니다. React와 Vue는 화면 관련 책임만 관리하고 비즈니스 로직을 BindModel에 위임하여 비즈니스 로직을 다양한 화면에서 재사용할 수 있습니다.  ","url": "http://localhost:4000/ko/exam/notice/"
  },{
    "title": "Notice example",
    "excerpt":"## Example screen  ![image-left](/assets/images/notice-800.gif){: .align-center}   ## Configuring the Environment  ```sh git clone https://github.com/white-base/exam-bind-model.git cd exam-bind-model npx serve ```  ## props drilling issue  The problem of Props drilling with React, Vue, and Angular can be solved all at once by BindModel, which manages data centrally and clearly separates business logic to significantly improve maintenance and reusability.  BindModel's components, MetaTable and MetaView, are defined as standard interfaces, making screen configurations more flexible. React and Vue only manage screen-related responsibilities and delegate business logic to BindModel, allowing business logic to be reused on a variety of screens.  ","url": "http://localhost:4000/en/exam/notice/"
  },{
    "title": "PropertyCollection 클래스",
    "excerpt":"# 주요 구조  ## 상속 관계  Class diagram ![image-center](/assets/images/coll-diagram-2024-08-16-002653.png){: .align-center}  # 주요 요소  ## 속성  | 항목         | 설명                                 | | ---------- | ---------------------------------- | | count      | 컬렉션 요소의 갯수입니다.                     | | _owner     | 컬렉션 소유자입니다.                        | | _elemTypes | 컬렉션 요소의 타입 제약조건입니다.                | | _list      | 컬렉션 요소의 목록입니다.                     | | _guid      | 객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다. | | _type      | 객체의 생성자 함수. 객체가 생성될 때 사용된 함수입니다.   | |            |                                    |    ---  ## 메소드  | 항목                       |                                          | | ------------------------ | ---------------------------------------- | | add(key, elem, desc)     | 프로퍼티 컬렉션에 요소를 추가합니다.                     | | clear()                  | 프로퍼티 컬렉션을 초기화합니다.                        | | keyOf(idx)               | 프로퍼티 컬렉션의 인덱스에 해당하는 키를 반환합니다.            | | exist(key)               | 프로퍼티 컬렉션에 지정된 키가 존재하는지 확인합니다.            | | remove(elem)             | 컬렉션에 요소를 삭제합니다.                          | | removeAt(pos)            | 컬렉션에서 지정된 위치의 요소를 삭제합니다.                 | | contains(elem)           | 요소가 컬렉션에 존재하는지 확인합니다.                    | | indexOf(target, isKey)   | 프로퍼티 컬렉션에서 지정된 키 또는 요소의 인덱스를 반환합니다.      | | getObject(vOpt, owned)   | 프로퍼티 컬렉션 객체를 직렬화된 객체로 반환합니다.             | | setObject(oGuid, origin) | 직렬화된 객체를 사용하여 프로퍼티 컬렉션 객체를 초기화합니다.       | | equal(target)            | 현재 객체와 지정된 객체가 동일한지 비교합니다.               | | getTypes()               | 현재 객체의 생성자와 프로토타입 체인의 모든 생성자를 배열로 반환합니다. | | instanceOf(target)       | 현재 객체가 지정된 타입의 인스턴스인지 확인합니다. (_UNION 포함) | |                          |                                          |   --- ## 이벤트  | 항목         | 설명                            | | ---------- | ----------------------------- | | onAdd      | 컬렉션 요소를 추가 전에 발생하는 이벤트 입니다.   | | onAdded    | 컬렉션 요소를 추가한 후에 발생하는 이벤트입니다.   | | onRemove   | 컬렉션 요소를 삭제하기 전에 발생하는 이벤트입니다.  | | onRemoved  | 컬렉션 요소를 삭제한 후에 발생하는 이벤트입니다.   | | onClear    | 컬렉션을 초기화하기 전에 발생하는 이벤트입니다.    | | onCleared  | 컬렉션을 초기화한 후에 발생하는 이벤트입니다.     | | onChanging | 컬렉션 요소를 변경하기 전에 발생하는 이벤트 입니다. | | onChanged  | 컬렉션 요소를 변경한 후에 발생하는 이벤트 입니다.  | |            |                               |  # 세부 설명  ## 주요 속성  ### count  > 현재 컬렉션의 요소 수를 반환합니다.  ```ts readonly type count = number; ```  ### \\_owner  > 컬렉션의 소유 객체입니다.  ```ts type _owner = object; ```  ### \\_elemTypes  > 컬렉션 요소의 타입 제약조건을 정의합니다.  ```ts type _elemTypes = any[]; ```  ### \\_list  > 컬렉션의 요소 목록을 저장하는 배열입니다. 이 배열은 컬렉션의 실제 데이터를 포함합니다.  ```ts readonly type _list = any[]; ```  ### \\_guid  > 객체의 고유 식별자 (GUID). 객체를 고유하게 식별합니다.  ```ts type _guid = string; ```  ### \\_type  > 객체의 생성자 함수입니다. 객체가 생성될 때 사용된 함수입니다.  ```ts type _type = Function; ```  --- ## 주요 메소드  ### add()  > 프로퍼티 컬렉션에 요소를 추가합니다.  ```ts type add = (key: string, elem: any, desc?: PropertyDescriptor) => number; ``` - key : key 요소의 키입니다. - elem : 추가할 요소입니다. - desc : 요소에 대한 프로퍼티 기술자 객체입니다. 선택값입니다. - return : 추가된 요소의 인덱스입니다. ### clear()  > 프로퍼티 컬렉션을 초기화합니다. > 이 메서드는 `$elements`, `$descriptors`, `$keys` 배열을 초기화합니다. > 이벤트는 초기화되지 않습니다.  ```ts type clear = () => void; ```   ```js myCollection.clear(); console.log(myCollection.count); // 0 ```  ### keyOf()  > 프로퍼티 컬렉션의 인덱스에 해당하는 키를 반환합니다.  ```ts type keyOf = (idx: number) => string; ``` - idx : 조회할 인덱스 값입니다. - return : 인덱스에 해당하는 키입니다. 인덱스가 범위를 벗어나면 `undefined`를 반환할 수 있습니다.   ```js const key = myCollection.keyOf(0); console.log(`인덱스 0의 키: ${key}`); ```  ### exist()  > 프로퍼티 컬렉션에 지정된 키가 존재하는지 확인합니다.  ```ts type exist = (key: string) => boolean; ``` - key - 확인할 키입니다. - return : 키의 존재 여부를 나타내는 불리언 값입니다.  ### remove()  > 컬렉션에 요소를 삭제합니다.  ```ts type remove = (elem: any) => number; ``` - elem : 삭제할 요소입니다. - return : 삭제된 요소의 인덱스입니다.   ```js const removedIndex = myCollection.remove(someElement); console.log(`삭제된 요소의 인덱스: ${removedIndex}`); ```  ### removeAt()  > 컬렉션에서 지정된 위치의 요소를 삭제합니다.  ```ts type removeAt = (pos: number) => boolean; ``` - pos : 삭제할 요소의 인덱스입니다. - return : 요소 삭제 성공 여부를 나타내는 불리언 값입니다.   ```js const success = myCollection.removeAt(0); console.log(`요소 삭제 성공: ${success}`); ```  ### contains()  > 요소가 컬렉션에 존재하는지 확인합니다.  ```ts type contains = (elem) => boolean; ``` - elem : 확인할 요소입니다. - return : 요소의 존재 여부를 나타내는 불리언 값입니다.  ```js const exists = myCollection.contains(someElement); console.log(`요소 존재 여부: ${exists}`); ```  ### indexOf()  > 프로퍼티 컬렉션에서 지정된 키 또는 요소의 인덱스를 반환합니다.  ```ts type indexOf = (target: any | string, isKey?: boolean) => number; ``` - target : target 조회할 키 또는 요소입니다. 키로 조회할 경우 문자열을 전달할 수 있습니다. - isKey : 키로 조회할지 여부를 결정하는 불리언 값입니다. 기본값은 `false`입니다. - return : 요소의 인덱스입니다. 요소가 존재하지 않을 경우 `-1`을 반환합니다.   ```js const index = myCollection.indexOf(\"key1\", true); console.log(`키의 인덱스: ${index}`); ```  --- ## 주요 이벤트  ### onAdd  > 컬렉션에 요소를 추가하기 전에 발생하는 이벤트입니다.  ```ts type onAdd = (idx: number, elem: any, _this: object) => void; ``` - idx : 추가할 요소의 인덱스입니다. - elem : 추가할 요소입니다. - \\_this : 현재 컬렉션 객체입니다.  ```js myCollection.onAdd = function(idx, elem, _this) { \tconsole.log(`요소 추가 전: 인덱스 ${idx}, 요소 ${elem}`); }; ```  ### onAdded  > 컬렉션에 요소를 추가한 후에 발생하는 이벤트입니다.  ```ts type onAdded = (idx: number, elem: any, _this: object) => void; ``` - idx : 추가된 요소의 인덱스입니다. - elem : 추가된 요소입니다. - \\_this : 현재 컬렉션 객체입니다.   ```js myCollection.onAdded = function(idx, elem, _this) { \tconsole.log(`요소 추가 후: 인덱스 ${idx}, 요소 ${elem}`); }; ```  ### onRemove  > 컬렉션에서 요소를 삭제하기 전에 발생하는 이벤트입니다.  ```ts type onRemove = (idx: number, elem: any, _this: object) => void; ``` - idx : 삭제할 요소의 인덱스입니다. - elem : 삭제할 요소입니다. - \\_this : 현재 컬렉션 객체입니다.  ```js myCollection.onRemove = function(idx, elem, _this) { \tconsole.log(`요소 삭제 전: 인덱스 ${idx}, 요소 ${elem}`); }; ```  ### onRemoved  > 컬렉션에서 요소를 삭제한 후에 발생하는 이벤트입니다.  ```ts type onRemoved = (idx: number, elem: any, _this: object) => void; ``` - idx : 삭제된 요소의 인덱스입니다. - elem : 삭제된 요소입니다. - \\_this : 현재 컬렉션 객체입니다.   ```js myCollection.onRemoved = function(idx, elem, _this) { \tconsole.log(`요소 삭제 후: 인덱스 ${idx}, 요소 ${elem}`); }; ```  ### onClear  > 컬렉션을 초기화하기 전에 발생하는 이벤트입니다.  ```ts type onClear = (_this: object) => {}; ``` - \\_this : 현재 컬렉션 객체입니다.   ```js myCollection.onClear = function(_this) { \tconsole.log('컬렉션 초기화 전'); }; ```  ### onCleared  > 컬렉션을 초기화한 후에 발생하는 이벤트입니다.  ```ts type onCleared = (_this: object)=> {}; ``` - \\_this : 현재 컬렉션 객체입니다.   ```js myCollection.onCleared = function(_this) { \tconsole.log('컬렉션 초기화 후'); }; ```  ### onChanging  > 컬렉션의 요소를 변경하기 전에 발생하는 이벤트입니다.  ```ts type onChanging = (idx: number, elem: any, _this: object) => void; ``` - idx : 변경할 요소의 인덱스입니다. - elem : 변경할 요소입니다. - \\_this : 현재 컬렉션 객체입니다.   ```js myCollection.onChanging = function(idx, elem, _this) { \tconsole.log(`요소 변경 전: 인덱스 ${idx}, 요소 ${elem}`); }; ```  ### onChanged  > 컬렉션의 요소를 변경한 후에 발생하는 이벤트입니다.  ```ts type onChanged = (idx: number, elem: any, _this: object) => void; ``` - idx : 변경된 요소의 인덱스입니다. - elem : 변경된 요소입니다. - \\_this : 현재 컬렉션 객체입니다.   ```js myCollection.onChanged = function(idx, elem, _this) { \tconsole.log(`요소 변경 후: 인덱스 ${idx}, 요소 ${elem}`); }; ``` ","url": "http://localhost:4000/ko/docs/api-property-collection/"
  },{
    "title": "PropertyCollection Class",
    "excerpt":"# the main structure  ## an inheritance relationship  Class diagram ![image-center](/assets/images/coll-diagram-2024-08-16-002653.png){: .align-center}  # a key element  ## Properties  | Item | Description | | ---------- | ---------------------------------- | | count | Number of collection elements | | _owner | is the owner of the collection. | | _elemTypes | Type constraints for collection elements | | _list | List of collection elements. | | _guid | Unique identifier of the object (GUID). Uniquely identifies the object. | | _type | The generator function of the object. The function used when the object was created. | |            |                                    |      ## Method  | Item || | ------------------------ | ---------------------------------------- | | add(key, element, desc) | Add an element to the property collection | Clear() | Initializes the property collection | keyOf(idx) | Returns the key corresponding to the index of the property collection | | Exist(key) | Verify that the specified key exists in the property collection | remove(element) | Delete an element in the collection | | removeAt(pos) | Deletes elements in the specified location from the collection | contains(element) | Verify that the element exists in the collection | indexOf (target, isKey) | Returns the index of the key or element specified in the property collection. | | getObject(vOpt, up) | Returns properties collection objects as serialized objects | | setObject(oGuid, origin) | Initializes property collection objects using serialized objects | | equal(target) | Compare the current object with the specified object. | | getTypes() | Returns the constructors of the current object and all the constructors of the prototype chain to the array. | | instanceOf(target) | Verify that the current object is an instance of the specified type (with _UNION) | |                          |                                          |    ## Events  | Item | Description | | ---------- | ----------------------------- | | onAdd | Events that occur before adding collection elements | | OnAdded | Events that occur after adding collection elements | | onRemove | Events that occur before deleting collection elements | | OnRemoved | Events that occur after the collection element is deleted | | onClear | Events that occur before the collection is initialized | OnCleared | Events that occur after the collection is initialized | onChanging | Events that occur before changing collection elements | | OnChanged | Events that occur after changing the collection element | |            |                               |  # Detailed description  ## Key Properties  ### count  > Returns the number of elements in the current collection.  ```ts readonly type count = number; ```  ### \\_owner  > This is the object owned by the collection.  ```ts type _owner = object; ```  ### \\_elemTypes  > Define the type constraints for the collection element.  ```ts type _elemTypes = any[]; ```  ### \\_list  > Array that stores the list of elements in the collection, which contains the actual data of the collection.  ```ts readonly type _list = any[]; ```  ### \\_guid  > Unique identifier of the object (GUID). Uniquely identifies the object.  ```ts type _guid = string; ```  ### \\_type  > The generator function of the object, which was used when the object was created.  ```ts type _type = Function; ```   ## Key Methods  ### add()  > Add an element to the property collection.  ```ts type add = (key: string, elem: any, desc?: PropertyDescriptor) => number; ``` - key : The key of the key element. - element : The element to be added. - desc : Property descriptor object for element. Select value. - return : Index of the added element. ### clear()  > Initialize the property collection. > This method initializes the array '$elements', '$descriptors', and '$keys'. > Events are not initialized.  ```ts type clear = () => void; ```  ```js myCollection.clear(); console.log(myCollection.count); // 0 ``` ### keyOf()  > Returns the key corresponding to the index of the property collection.  ```ts type keyOf = (idx: number) => string; ``` - idx : Index value to look up. - return : The key corresponding to the index. If the index is out of range, it can return 'undefined'.  ```js const key = myCollection.keyOf(0); console.log(key for index 0: ${key}'); ```  ### exist()  > Verify that the specified key exists in the property collection.  ```ts type exist = (key: string) => boolean; ``` - key - This is the key to check. - return —Bulian value indicating the presence or absence of a key.  ### remove()  > Delete an element in the collection.  ```ts type remove = (elem: any) => number; ``` - element : The element to be deleted. - return : Index of the deleted element.  ```js const removedIndex = myCollection.remove(someElement); console.log(`Index of deleted element: ${removedIndex}`); ```  ### removeAt()  > Deletes elements in the specified location from the collection.  ```ts type removeAt = (pos: number) => boolean; ``` - pos : Index of the element to be deleted. - return : Bullion value that indicates whether element deletion is successful.  ```js const success = myCollection.removeAt(0); console.log(`Delete element successful: ${success}`); ```  ### contains()  > Verify that the element exists in the collection.  ```ts type contains = (elem) => boolean; ``` - element : The element to be checked. - return : A Boolean value indicating the presence or absence of an element.  ```js const exists = myCollection.contains(someElement); console.log(`element exists: ${exists}`); ```  ### indexOf()  > Returns the index of the key or element specified in the property collection.  ```ts type indexOf = (target: any | string, isKey?: boolean) => number; ``` - target : A key or element to look up the target. A string can be passed when viewed with a key. - isKey : A bullion value that determines whether to look up with a key. Default is 'false'. - return : Index of the element. Returns '-1' if the element does not exist.  ```js const index = myCollection.indexOf(\"key1\", true); console.log(`Index of key: ${index}`); ``` ## Key Events  ### onAdd  > Events that occur before adding an element to a collection.  ```ts type onAdd = (idx: number, elem: any, _this: object) => void; ``` - idx : Index of the element to be added. - element : The element to be added. - \\_this : current collection object.  ```js myCollection.onAdd = function(idx, elem, _this) { \tconsole.log(`Before adding elements: index ${idx}, element ${elem}`); }; ```  ### onAdded  > Events that occur after adding an element to a collection.  ```ts type onAdded = (idx: number, elem: any, _this: object) => void; ``` - idx : Index of the added element. - element : Added element. - \\_this : current collection object.  ```js myCollection.onAdded = function(idx, elem, _this) { \tconsole.log ('After adding elements: index ${idx}, element ${elem}'); }; ```  ### onRemove  > An event that occurs before an element is deleted from the collection.  ```ts type onRemove = (idx: number, elem: any, _this: object) => void; ``` - idx : Index of the element to be deleted. - element : The element to be deleted. - \\_this : current collection object.  ```js myCollection.onRemove = function(idx, elem, _this) { \tconsole.log(`Before element deletion: index ${idx}, element ${elem}`); }; ```  ### onRemoved  > Events that occur after you delete an element from the collection.  ```ts type onRemoved = (idx: number, elem: any, _this: object) => void; ``` - idx : Index of deleted elements. - element : Deleted element. - \\_this : current collection object.  ```js myCollection.onRemoved = function(idx, elem, _this) { \tconsole.log(`After element deletion: index ${idx}, element ${elem}`); }; ```  ### onClear  > Events that occur before the collection is initialized.  ```ts type onClear = (_this: object) => {}; ``` - \\_this : current collection object.  ```js myCollection.onClear = function(_this) { \tconsole.log ('Before collection initialization); }; ``` ### onCleared  > Events that occur after the collection is initialized.  ```ts type onCleared = (_this: object)=> {}; ``` - \\_this : current collection object.  ```js myCollection.onCleared = function(_this) { \tconsole.log ('After collection initialization'); }; ```  ### onChanging  > Events that occur before you change the elements in the collection.  ```ts type onChanging = (idx: number, elem: any, _this: object) => void; ``` - idx : Index of the element to be changed. - element : The element to be changed. - \\_this : current collection object.  ```js myCollection.onChanging = function(idx, elem, _this) { \tconsole.log(`Before element change: index ${idx}, element ${elem}`); }; ```  ### onChanged  > Events that occur after you change the elements of the collection.  ```ts type onChanged = (idx: number, elem: any, _this: object) => void; ``` - idx : Index of the changed element. - element : Changed element. - \\_this : current collection object.  ```js myCollection.onChanged = function(idx, elem, _this) { \tconsole.log ('After element change: index ${idx}, element ${elem}'); }; ``` ","url": "http://localhost:4000/en/docs/api-property-collection/"
  },{
    "title": "시작하기",
    "excerpt":"## BindModel 이란?  BindModel은 웹과 Node.js 환경에서 작동하는 프론트엔드 프레임워크입니다. 명령과 엔티티(Table, View)를 기반으로 하여 단순함과 생산성을 목표로 설계되었습니다. HTML, CSS, JavaScript의 기초를 숙지한 상태에서 BindModel을 사용하여 손쉽게 웹사이트를 제작할 수 있습니다.  - 모든 데이터를 엔티티(MetaTable, MetaView)로 관리합니다. - MVC 패턴에서 Controller의 역할을 수행하며, View(화면)와 완전히 분리있습니다. - 명령(BindCommand) 기반의 프로세서를 제공하여, 일관된 개발 패턴을 제공합니다. - 라우팅, 폼 관리, 클라이언트-서버 통신 등 웹 개발에 필요한 라이브러리를 조화롭게 통합한 모음집입니다. - 다른 프레임워크의 연동하여 사용할 수 있습니다.         ## 설치  ### npm 을 이용한 설치  Node.js 환경에서 BindModel 을 설치하려면 다음 명령어를 사용하십시오.  ```sh npm install logic-bind-model ```  ### 브라우저 환경에서의 설치  브라우저 환경에서는 BindModel 을 CDN을 통해 사용할 수 있습니다.  ```html  ```    ## 사용  BindModelAjax 는 프레임워크의 핵심 객체입니다.  ### 서버 환경 (node.js)  Node.js 환경에서는 require 또는 import 문을 통해 BindModelAjax 을 사용할 수 있습니다.  예제 : CommonJS 에서 사용 ```js const { BindModel } = require('logic-bind-model');  const bm = new BindModel(); ```   예제 : ES6 에서 사용 ```js import { BindModel } from 'logic-bind-model';    const bm = new BindModel(); ```  ### HTML 환경  브라우저 환경에서는 `_L` 전역 변수를 통해서 접근합니다.  예제 : HTML 환경에서 사용 ```html       ```   ## 패키징  BindModelAjax는 axios 와 jQuery 모듈에 의존하여 서버와의 비동기 통신 및 DOM 조작을 수행합니다. 이러한 의존성을 반영하여 다양한 배포 패키지를 제공합니다.  ### bind-model.pack.js,  bind-model.pack.min.js  이 패키지는 BindModelAjax와 함께 axios와 jQuery 라이브러리를 포함하고 있습니다. 이 패키지는 외부에서 별도로 axios나 jQuery를 설치하지 않아도, bind-model.pack.js 하나만으로 모든 기능을 사용할 수 있습니다.   ### bind-model.js,  bind-model.min.js  이 패키지는 BindModelAjax 만을 포함하고 있으며, axios와 jQuery는 포함되지 않습니다. 이 패키지를 사용할 경우, 외부에서 axios와 jQuery를 이미 포함하고 있거나, 별도로 관리하고 있을 때 유용합니다.  {% capture notice-text %} * bindmodel.min.js * bindmodel.pack.min.js {% endcapture %}     See :    {{ notice-text | markdownify }} ","url": "http://localhost:4000/ko/docs/quick-start/"
  },{
    "title": "Start",
    "excerpt":"## What is BindModel?  BindModel is a front-end framework that operates on the web and in Node.js environments. It is designed for simplicity and productivity based on commands and entities (Table, View). Once you are familiar with the basics of HTML, CSS, and JavaScript, you can easily create websites using BindModel.  - Manage all data as an entity (MetaTable, MetaView). - It acts as a controller in the MVC pattern and is completely separate from the View. - It provides a command-based processor to provide a consistent development pattern. - It is a harmonious collection of libraries needed for web development, such as routing, form management, and client-server communication. - It can be used in conjunction with other frameworks.         ## Installation  ### Installation using npm  To install BindModel in a Node.js environment, use the following command.  ```sh npm install logic-bind-model ```  ### Installing in a browser environment  In a browser environment, BindModel is available via CDN.  ```html  ```    ## Use  BindModel is the core object of the framework.  ### Server Environment (node.js)  In the Node.js environment, you can use the BindModel through a require or import statement.  Example: Using with CommonJS ```js const { BindModel } = require('logic-bind-model');  const bm = new BindModel(); ```   Example: Using with ES6 ```js import { BindModel } from 'logic-bind-model';    const bm = new BindModel(); ```  ### HTML Environment  In the browser environment, it is accessed through the '_L' global variable.   Example: Using in HTML Environments ```html       ```   ## Packaging  BindModel relies on axios and jQuery modules to perform asynchronous communication and DOM operations with the server; reflecting this dependency, it provides a variety of deployment packages.  ### bindmodel.js  This package contains only BindModel and does not include axios and jQuery. This package is useful when externally already including axios and jQuery, or if you are managing them separately.  ### bindmodel.pack.js  This package contains the axios and jQuery libraries along with BindModel. This package can be fully functional with just one bind-model.pack.js, without having to install axios or jQuery from the outside.   {% capture notice-text %} 'Packy name + min.js' is a compressed file. * bindmodel.min.js * bindmodel.pack.min.js {% endcapture %}     See :    {{ notice-text | markdownify }} ","url": "http://localhost:4000/en/docs/quick-start/"
  },{
    "title": "서비스객체 구성",
    "excerpt":"서비스 객체를 사용하면 `BindModelAjax`객체를 쉽게 생성할 수 있으며, 상속으로 공통 영역을 분리하여 재사용성을 높일 수 있습니다.  콜백 함수에서 this.bindModel 속성으로 `BindModelAjax` 객체에 접근할 수 있습니다.  타입 : ServiceType ```ts // items area type KeyType = 'none' | 'value' | 'text' | 'html' | 'prop' | 'attr' | 'css'; type SelectorType = { key: string, type: KeyType }; type RegExpType = { reg: RegExp, msg: string, return?: boolean }; type FuncType = (value: any) => boolean; type ConstraintType = RegExpType | FuncType; type ColumnType = { \tselector?: SelectorType, \tgetter?: () => any, \tsetter?: (val: any) => any, \tgetFilter?: () => any, \tsetFilter?: (val; any) => any, \tdefault?: stirng | number | boolean | null, \tvalue?: any, \talias?: string, \tcaption?: string, \tconstraints?: ConstraintType[] | ConstraintType, \trequired?: boolean | false, \tcolumnName?: string }; type Itemtype = { \t[key: string]: string | number | boolean | ColumnType }; // command area type CmdValueType = { \toutputOption?: 0 | 1 | 2 | 3,  // alias : outOpt \tconfig?: see axiosConfig, // axios type \turl?: string, \tviews?: string[], \tcbBegin?: (cmd: BindCommand) => void, \tcbValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBind?: (view: MetaView, cmd: BindCommand, cfg: object) => void, \tcbResult?: (data: object, cmd: BindCommand, res: object) => object, \tcbOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, }; type CommandType = { \t[key: string]: CmdValueType }; // mapping area typeColumnName = string; // 'item name' | 'column name' | 'table name.column name'; type CommandName = '$all' | string;  // string = 'command name' type ViewName = 'valid' | 'bind' | 'output' | '$all' | string; // add view name type MappingType = { \t[key: ColumnName]: { \t\t[key: CommandName]: ViewName | ViewName[] \t} }; // fn area type fnType = { \t[key: string]: Function }; // ------------------------- // service area type ServiceType = { \ttables?: string | string[], \tbaseConfig?: axiosConfig,  // // axios type \turl?: string, \tcbBaseBegin?: (cmd: BindCommand) => void; \tcbBaseValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBaseBind?: (view: MetaView, cmd: BindCommand, cfg) => void, \tcbBaseResult?: (data: object, cmd: BindCommand, res) => object, \tcbBaseOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbBaseEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, \titems?: Itemtype, \tcommand?: CommandType, \tmapping?: MappingType, \tfn?: fnType, \tpreRegister?: (bindModel) => void', \tpreCheck?: (bindModel) => boolean', \tpreReady?: (bindModel) => void,  }; ```  # 서비스 객체  ## 기본 영역 구성하기  서비스객체의 기본 콜백함수와 서버요청 정보를 구성합니다.   타입 : 기본 서버요청 및 기본 콜백함수 ```ts // Configuring Callback and Server Requests on Service Objects type ServiceType = { \tbaseConfig?: axiosConfig,  // axios 타입 참조 \turl?: string, \tcbBaseBegin?: (cmd: BindCommand) => void; \tcbBaseValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBaseBind?: (view: MetaView, cmd: BindCommand, cfg) => void, \tcbBaseResult?: (data: object, cmd: BindCommand, res) => object, \tcbBaseOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbBaseEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, }; ``` - 'url' 은 `baseConfig.url` 값 입니다.  예제 : 기본 ```js var bm = new BindModel({ \t// 기본 서버 요청 \tbaseConfig: { method: 'GET' }, \turl: '/user', \t// 기본 콜백함수 \tcbBaseBegin: function(cmd) {  \t\tconsole.log('기본 시작 콜백');  \t}, \tcbBaseValid: function(view, cmd) { \t\tconsole.log('기본 유효성 검사 콜백'); \t\treturn true; \t}, \tcbBaseBind: function(view, cmd, cfg) {  \t\tconsole.log('기본 서버 요청 콜백');  \t}, \tcbBaseResult: function(data, cmd, res) { \t\tconsole.log('기본 서버 응답 콜백'); \t\treturn data; \t}, \tcbBaseOutput: function(vidw, cmd, res) => {  \t\tconsole.log('\b기본 응답 출력 콜백');  \t}, \tcbBaseEnd: function(status, cmd, res) => {  \t\tconsole.log('기본 종료 콜백');  \t},\t }); ```  예제 : 메소드를 통한 기본 구성 ```js var bm = new BindModel();  // 기본 서버 설정 bm.baseConfig = { method: 'GET', url: '/user' }; bm.cbBaseBegin = function(cmd) {  \tconsole.log('기본 시작 콜백');  };  // 기본 콜백함수 bm.cbBaseValid: function(view, cmd) { \tconsole.log('기본 유효성 검사 콜백'); \treturn true; }; bm.cbBaseBind: function(view, cmd, cfg) {  \tconsole.log('기본 서버 요청 콜백');  }; bm.cbBaseResult: function(data, cmd, res) { \tconsole.log('기본 서버 응답 콜백'); \treturn data; }; bm.cbBaseOutput: function(vidw, cmd, res) => {  \tconsole.log('기본 응답 출력 콜백');  }; bm.cbBaseEnd: function(status, cmd, res) => {  \tconsole.log('기본 종료 콜백');  }; ``` - 위의 구성한 서비스 객체와 동일합니다.  기본 구성은 commnad 별로 설정이 가능하며, 기본 구성 보다  'command' 의 우선순위가 높습니다.  ## 테이블 영역 구성하기  서비스객체의 추가 테이블 정보를 구성합니다.   타입 : tables ```ts // Configuring Tables in a Service Object type ServiceType = { \ttables?: string | string[], }; ```  `BindModelAjax` 객체는 'first' 라는 이름의 `MetaTable`을 자동 생성하여 사용합니다. 추가 테이블을 'tables' 속성으로 설정합니다.  ```js var bm = new BindModel({     tables: ['second', 'third'] });  // 기본 테이블 참조 // bm.first === bm._tables['first']  // true // bm.first === bm._tables[0]        // true  // 추가 테이블 참조 // bm.second === bm._tables['second'] // true // bm.second === bm._tables[1]        // true // bm.third === bm._tables['third']   // true // bm.third === bm._tables[2]         // true ``` - 추가적인 테이블이 필요할 경우에 사용합니다.  예제 : 메소드를 통한 테이블 구성 ```js var bm = new BindModel();  // Create a table bm.addTable('second'); bm.addTable('third'); ``` - 위의 구성한 서비스 객체와 동일합니다.  ## 아이템 영역 구성하기  서비스객체의 컬럼 원시값을 구성합니다.  ### 컬럼의 원시값 설정  - items 각 요소는 컬럼의 원시값을 입니다.  - items 의 키값이 `string, number, boolean, null` 타입일 경우, 컬럼의 value에 설정됩니다.  - items 의 키값이 `object` 타입일 경우, 컬럼의  프로퍼티 값으로 사용됩니다.  타입 : items ```ts type KeyType = 'none' | 'value' | 'text' | 'html' | 'prop' | 'attr' | 'css'; type SelectorType = { key: string, type: KeyType }; type RegExpType = {reg: RegExp, msg: string, return?: boolean = true}; type FuncType = (value: any) => boolean; type ConstraintType = RegExpType | FuncType; type ColumnType = { \tselector?: SelectorType, \tgetter?: () => any, \tsetter?: (val: any) => any, \tgetFilter?: () => any, \tsetFilter?: (val: any) => any, \tdefault?: stirng | number | boolean | null, \tvalue?: any, \talias?: string, \tcaption?: string, \tconstraints?: ConstraintType[] | ConstraintType, \trequired?: boolean | false, \tcolumnName?: string }; type Itemtype = { \t[key: string]: string | number | boolean | ColumnType }; // 서비스 객체에서 items 구성 type ServiceType = { \titems?: ItemType }; ```  ### item 네이밍 규칙 - 컬럼명 : 기본테이블에 컬럼을 등록됩니다. - 테이블명.컬럼명 : 대상 테이블에 컬럼을 등록됩니다.  ### items 속성 설명 - `string, number, boolean, null `: 원시값으로 컬럼의 value 에 설정됩니다. - selector : 컬럼의 value 를 DOM 에서 가져오거나 설정할 때 사용할 선택자입니다. - setter : 외부에 value 을 설정할 때 사용할 함수입니다. - getter : 외부에서 value 을 가져올 때 사용할 함수입니다. - required : 컬럼 value 의 필수 여부를 설정합니다. - setFilter : value 를 설정할 때 사용할 필터 함수입니다. - getFilter : value 를 가져올 때 사용할 필터 함수입니다. - constraints : 정규식 또는 사용자 함수로 value 의 제약조건을 설정하며, 유효성 검사에 사용됩니다.  [[54. HTML Column Class-B|Refer to HTML Column]]   예제 : items ```js var bm = new BindModel({ \t// 추가 테이블 생성 \ttables: 'second', \t \t// 아이템 생성 \titems: { \t\taa: 'Cat', \t\t'second.bb': 10, \t\t'second.cc': true, \t\tdd: { \t\t\tselector: { key: '#U_ID', type: 'value' },  // 컬럼의 selector 설정 \t\t\tsetter: (val) => {/*외부에 설정 영역*/},        // 컬럼의 setter 설정 \t\t\tgetter: () => { return '외부값'; },           // 컬럼의 getter 설정 \t\t}, \t\tee: { \t\t\trequired: true,                             // 컬럼의 required 설정 \t\t\tsetFilter: (val) => {/*외부에 설정영역*/},      // 컬럼의 setFilter 설정 \t\t\tgetFilter: () => { return '외부값'; },        // 컬럼의 getFilter 설정 \t\t}, \t\tff: { \t\t\tconstraints: { reg: /abc/, msg: '매칭되지 실패!' } // 컬럼의 제약조건 설정 \t\t} \t} }); ``` - aa' 아이템은 기본테이블에 컬럼으로 등록하고, value 에 'Cat' 을 설정합니다. - bb' 아이템은 second 테이블에 컬럼으로 등록하고, value 에 10 을 설정합니다. - cc' 아이템은 second 테이블에 컬럼으로 등록하고, value 에 true 을 설정합니다.  예제 : 메소드를 통한 아이템 구성 ```js var bm = new BindModel();  // 추가 테이블 생성 bm.addTable('second');  // 아이템 생성 bm.items.add('aa', 'Cat'); bm.items.add('second.bb', 10); bm.items.add('second.cc', true); bm.items.add('dd', { \tselector: { key: '#U_ID', type: 'value' }, \tsetter: function(val) {/*외부에 설정 영역*/}, \tgetter: function() { return '외부값'; },  }); bm.items.add('ee', { \trequired: true, \tsetFilter: function(val) {/*외부에 설정영역*/}, \tgetFilter: function() { return '외부값'; }, }); bm.items.add('ff', { \tconstraints: { reg: /abc/, msg: '매칭되지 실패!' } }); ``` - 위의 구성한 서비스 객체와 동일합니다.  또한 items 은 여러 테이블에 동일한 컬럼을 등록할 때 유용하게 데이터를 관리할 수 있습니다.  ## 명령 영역 구성하기  서비스객체의 command 정보를 구성합니다.  타입 : command ```ts type CmdValueType = { \toutputOption?: 0 | 1 | 2 | 3,  // 별칭 : outOpt \tconfig?: see axiosConfig, // axios type \turl?: string, \tviews?: string[], \tcbBegin?: (cmd: BindCommand) => void, \tcbValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBind?: (view: MetaView, cmd: BindCommand, cfg: object) => void, \tcbResult?: (data: object, cmd: BindCommand, res: object) => object, \tcbOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, }; type CommandType = { \t[key: string]: CmdValueType }; // 서비스 객체에서 command 구성 type ServiceType = { \tcommand?: CommandType, }; ``` - `CmdValueType.url` 은 `CmdValueType.config.url` 값을 참조합니다. - `CommandType` key 는 추가할 'command' 의 이름 입니다.  ### 명령 타입 설명 -  outputOption : 뷰 출력 방식을 지정합니다. 기본값은 0입니다.  -  config : axios의 설정 객체와 동일합니다. -  url : `config.url`값이며, axios을 통해 요청할 URL 경로를 설정합니다. - views : 추가할 출력 뷰(MetaView) 이름 입니다. - cbBegin : 시작 전 콜백함수 입니다. - cbValid : 유효성 검사 콜백함수 입니다. - cbBind : 서버 요청 콜백함수 입니다. - cbResult : 서버 응답 콜백함수 입니다. - cbOutput : 응답 출력 콜백함수 입니다. - cbEnd : 종료 전 콜백함수 입니다.  [24. Bind Command Composition - C#Callback (Attribute)] 예제 : command ```js var bm = new BindModel({ \tcommand: { \t\tcreate: {}, \t\tread: { \t\t\toutputOption: 3,  // 데이터를 컬럼값에 설정하기 (지정한 컬럼) \t\t\tconfig: { method: 'GET' },  // GET 요청 설정 \t\t\tcbEnd: function() { alert('정상처리되었습니다.'); } // 처리 완료 후 콜백 함수 \t\t}, \t\tupdate: { \t\t\tviews: ['two'],  // 'two' 뷰를 추가 \t\t\turl: '/user'     // 요청할 URL 경로 \t\t} \t} }); ``` - 'create'  를 생성하고  \t- 기본값 outputOption = 0 을 설정합니다. - 'read' 를 생성하고 \t- outputOption = 3 을 설정하고 \t- config 서버 요청을 설정하고 \t- cbEnd 콜백함수를 설정합니다. - 'update' 를 생성하고 \t- 기본값 outputOption = 0 설정하고 \t- 출력뷰 'two'을 추가하고 \t- 서버요청 url 을 설정합니다.  예제 : 메소드를 통한 명령 구성 ```js var bm = new BindModel();  // 명령 생성 bm.addCommand('create'); bm.addCommand('read'); bm.addCommand('update');  // read 명령 설정 bm.commmand['read'].outputOption = 3; bm.commmand['read'].config = { method: 'GET' }; bm.commmand['read'].cbEnd = {  \talert('정상처리되었습니다.'); };  // update 명령 설정 bm.commmand['update'].newOutput('two'); bm.commmand['update'].url = '/user'; ``` - 위의 구성한 서비스 객체와 동일합니다.  ## 매핑 영역 구성하기  서비스객체에서 items 과 'command' 의 매핑을 구성합니다.  타입 : mapping ```ts type ColumnName = string;            // '아이템명' | '컬럼명' | '테이블명.컬럼명'; type CommandName = '$all' | string;  // string = '명령 이름' type ViewName = 'valid' | 'bind' | 'output' | '$all' | string; // 추가 뷰 이름 type MappingType = { \t[key: ColumnName]: { \t\t[key: CommandName]: ViewName | ViewName[] \t} }; // 서비스 객체에서 mapping 구성 type ServiceType = { \tmapping?: MappingType }; ```  ### 매핑 규칙 - 컬럼명(ColumnName)  \t- `'컬럼명'` : 기본테이블의 컬럼이 선택됩니다. \t- `'테이블명.컬럼명'` : 지정한 테이블의 컬럼이 선택됩니다. (없을시 생성) #REVIEW - 명령명(CommandName)  \t- `'명령명'` : 지정한 command 가 선택됩니다. \t- `'$all'` : 전체 command 가 선택됩니다. - 뷰명(ViewName) \t- `'valid', 'bind', 'output'` : 선택된 MetaView 에 매핑됩니다. (복수는 배열로 지정) \t- '`$all'` : 전체 MetaView 에 매핑됩니다.  (추가된 output 도 포함됨) \t [00. Column mapping]  예제 : mapping ```js var bm = new BindModel(); bm.setService({ \t// 테이블 영역 \ttables: ['second'], \t// 아이템 영역 \titems: { \t\taa: '', \t\tbb: '', \t\tcc: '', \t\tdd: '' \t}, \t// 명령 영역 \tcommand: { \t\tone: {}, \t\ttwo: {}, \t}, \t// 매핑 영역 \tmapping: { \t\taa: { $all: ['valid'] }, // 모든 명령의 'valid' 뷰에 'aa' 등록 \t\tbb: { one: ['bind'] },   // 'one' 명령의 'bind' 뷰에 'bb' 등록 \t\t'second.cc': { two: ['output'] }  // 'two' 명령의 'output' 뷰에 'cc' 등록 \t} });  // bm.items.count == 4 ('aa','bb','cc','dd') // bm.first.columns.count == 2 ('aa','bb') // bm.second.columns.count == 1 ('cc') // bm.cmd['one'].valid.columns.count == 1 ('aa') // bm.cmd['one'].bind.columns.count == 1 ('bb') // bm.cmd['one'].output.columns.count == 0 // bm.cmd['two'].valid.columns.count == 1 ('aa') // bm.cmd['two'].bind.columns.count == 0 // bm.cmd['two'].output.columns.count  == 1 ('cc') ``` - 'aa' 아이템은 기본 테이블에 등록 되고, 모든 commnad 의 valid(MetaVeiw)에 매핑 됩니다. - 'bb' 아이템은 기본 테이블에 등록 되고, 'one' commnad 의 bind(MetaVeiw)에 매핑 됩니다. - 'cc' 아이템은 'second' 테이블에 등록 되고, 'two' commnad 의 output(MetaVeiw)에 매핑 됩니다.  타입 : setMapping() ```ts type setMapping( \tmapping: PropertyCollection | object,  \tbTable?: MetaTable | string ) => void; ``` - mapping : 매핑할 컬렉션입니다. - bTable : 매핑할 기본테이블 입니다. 기본값은 \\_baseTable 입니다.  예제 : 메소드를 통한 매핑 구성 ```js var bm = new BindModel();  // 추가 테이블 생성 bm.addTable('second');  // 아이템 생성 bm.items.add('aa', ''); bm.items.add('bb', ''); bm.items.add('cc', ''); bm.items.add('dd', '');  // 명령 생성 bm.addCommand('one'); bm.addCommand('two');  // 아이템 매핑 bm.setMapping({ \taa: { $all: ['valid'] }, // 모든 명령의 'valid' 뷰에 'aa' 등록 \tbb: { one: ['bind'] },   // 'one' 명령의 'bind' 뷰에 'bb' 등록 \t'second.cc': { two: ['output'] }  // 'two' 명령의 'output' 뷰에 'cc' 등록 }); ``` - 위의 구성한 서비스 객체와 동일합니다.  각 명령의 특정 뷰에 필요한 컬럼들을 효율적으로 매핑할 수 있으며, 이를 통해 데이터 처리의 일관성을 유지하고 관리의 편의성을 높일 수 있습니다.  ## 함수 영역 구성하기  서비스객체의 사용자함수를 구성합니다.  타입 : fn ```ts type fnType = { \t[key: string]: Function; }; // 서비스 객체에서 fn 구성 type ServiceType = { \tfn?: fnType }; ``` - key 는 사용자함수명입니다.  예제 : fn ```js var bm = new BindModel({ \tcbBaseBegin: function(cmd) { \t\tAccess the parameter at cmd._model.fn.ecCreate(); // cmd 에서 파라메터로 접근 \t\tthis.bindModel.fn.sum(1, 1); // this.bindModel로 접근 \t}, \tcommand: { \t\tcreate: { \t\t\tcbEnd: function() { \t\t\t\tthis.bindModel.fn.sum(1, 2); \t\t\t} \t\t}, \t}, \tfn: { \t\tsum: function(a, b) {return a + b}, \t\texecCreate: function() { \t\t\tthis.bindModel.cmd.read.execute(); \t\t} \t} });  // 이벤트 등록 $('#btn_create').click(function() { \tbm.fn.execCreate(); }); ``` - 콜백함수에서 `파라메터` 또는 `this.bindModel` 속성으로 BindModelAjax 객체에 접근할 수 있습니다.  예제 : 메소드를 함수 구성 ```js var bm = new BindModel();  // 함수 구성 bm.fn.add('sum', function(a, b) {return a + b}); bm.fn.add('execCreate', function() { \tthis.bindModel.cmd.read.execute(); // this.bindModel 로 접근 });  // 공통 콜백 구성 bm.cbBaseBegin = function(cmd) { \tcmd._model.fn.execCreate();  // cmd 파라메터로의 접근 \tthis.bindModel.fn.sum(1, 1); // this.bindModel 로 접근 };  // 명령 구성 bm.addCommand('create'); bm.command['create'].cbEnd = function() { \tthis.bindModel.fn.sum(1, 2);  // this.bindModel 로 접근 }  // 이벤트 등록 $('#btn_create').click(function() { \tbm.fn.execCreate();  // 외부에서 함수 접근 }); ``` - 위의 구성한 서비스 객체와 동일합니다.  각각 영역은 결합도를 높이고, 재사용성과 유지보수성을 높일 수 있습니다.ty and maintenance.  ## 전처리 영역 구성하기  서비스객체의 전처리 정보를 구성합니다. 주로 서비스객체를 자동화 할 때 사용합니다.  타입 : init(), preRegister, preCheck, preReady ```ts type init = () => void;  type preRegister = (bindModel) => void;  type preCheck = (bindModel) => boolean;  type preReady = (bindModel) => void;  ```  ### 전처리 호출 흐름  1. init() 메소들 호출하면 preRegister, preCheck, preReady 순차적으로 호출됩니다. 2. preCheck 에서 false 을 리턴하면 preReady 는 호출하지 않고 cbFail 을 호출됩니다. 3. preCheck 에서 true 을 리턴하면 preReady 호출됩니다.  전처리는 서비스객체와 화면 페이지와의 상호작용 또는 selector 유효성 검사에 활용됩니다.  예제 : 전처리 ```js var bm = new BindModel({ preRegister: function(bindModel) {  \t\t// 전처리 : 검사전 \t}, \tpreCheck: function(bindModel) { \t\t// 전처리 : 검사 \t\tif (bm.checkSelector().length === 0) return true; \t}, \tpreReady: function(bindModel) {  \t\t// 전처리 : 준비 완료 \t\tbindModel.command['test'].execute(); \t}, });  $(document).ready(function () { \tbm.init(); }); ``` - 페이지가 준비되면 init() 메소드를 호출해서 DOM 을 검사하고, 'test' command 를 실행합니다.  예제 : 메소드를 전처리 구성 ```js var bm = new BindModel(); // BindModel Settings...  bm.preRegister = function(bindModel) {  \t// 전처리 : 검사전 }; bm.preCheck = function(bindModel) {  \t// 전처리 : 검사 \tif (bm.checkSelector().length === 0) return true; }; bm.preReady = function(bindModel) {  \t// 전처리 : 준비 완료 \tbindModel.command['test'].execute(); };  $(document).ready(function () { \tbm.init(); }); ``` - 위의 구성한 서비스 객체와 동일합니다.  전처리 영역은 자동화가 필요할 경우 활용할 수 있습니다.   # 기능  ## 서비스 객체 주입하기  `BindModelAjax` 객체를 생성할 때 파라미터 전달하거나, setService() 메소드를 호출하여 서비스 객체를 주입할 수 있습니다.   타입 : setservice() ```ts type setService = (service: IService, isTypeCheck: boolean = false) => void; ``` -  service : 주입할 서비스 객체입니다. - isTypeCheck : 타입 검사를 할지 여부를 설정합니다. 기본값은 false 입니다.  setService() 메소드로 사용은 서비스객체 분리하여 코드의 가독성과 유지보수성을 높여줍니다.  예제 : 생성자를 통한 주입 ```js var bm1 = new BindModel({ \titems: {         aa: 'Cat',         bb: 10,         cc: true,     },     fn: {         sum: function(a, b) { return a + b; },     },     url: '/user',     command: {         read: {             outputOption: 3,             cbEnd: function() { console.log('Normal Processed'); }         },         update: {             views: ['two'],             url: '/user'         }     },     mapping: {         aa: { $all: ['valid'] },         bb: { read: ['bind'], update: 'output' },         cc: { update: ['output'] }     }, }); ``` 예제 : setService() 메소드로 주입 ```js // items, fn 구성 var svcItems = { \titems: {         aa: 'Cat',         bb: 10,         cc: true,     },     fn: {         sum: function(a, b) { return a + b; },     } };  // 기타 구성 var svcCommon = {     baseConfig: { method: 'GET' },     url: '/user',     command: {         read: {             outputOption: 3,             config: { method: 'GET' },             cbEnd: function() { console.log('Normal Processed'); }         },     },     mapping: {         aa: { $all: ['valid'] },         bb: { read: ['bind'], update: 'output' },         cc: { update: ['output'] }     }, };  barbm = new BindModel(); // 파라메터를 통한 주입  bm2.setService(svcItems); bm2.setService(svcCommon); ``` - 위의 구성한 서비스 객체와 동일합니다. - 첫번째 setService() 메소드 호출에서는 items, fn 을 서비스를 설정합니다. - 두번째 setService() 메소드 호출에서는 command, mapping 등 서비스를 설정합니다.  중복된 설정은 마직막 값을 유지되며, 이벤트 값의 경우는 추가됩니다.  'items', 'fn' 영역 다른 영역에 대한 의존성이 낮습니다. 서비스 객체를 통해 공통 설정을 관리하고, 재사용성을 높일 수 있습니다.   ## 서비스 클래스로 정의하기  ### 상속을 통한 서비스객체 생성  서비스를 클래스로 제작하여 공통 부분을 코드의 재사용성을 높일 수 있습니다. 서비스 클래스를 다양한 구조로 활용할 수 있습니다.  common-svc.js ```js class CommonService() { \tcbFail = function(msg) { \t\tconsole.warn (\"user failure handling:+ msg\"); \t}; \tcbError = function(msg) { \t\tconsole.error (\"User error handling\") \t}; } ``` - 공통으로 사용되는 영역을 공통서비스 클래스로 작성하였습니다.  member-svc.js ```js class MemberService(suffix) extends CommonService { \titems = { \t\tidx: -1, \t\tuser_no: { selector: { key: '#user_no'+ suffix, type: 'value' } }, \t\tu_name: { selector: { key: '#u_name'+ suffix, type: 'value' } }, \t}; \tcommand = { \t\tcreate: 0, \t\tread: { \t\t\toutputOption: 3, \t\t\tcbEnd: () => { alert('Normal Processed'); } \t\t} \t}; \tmapping = { \t\tidx: {  \t\t\tread: ['valid', 'bind']  \t\t}, \t\tu_name: {  \t\t\tcreate: ['valid', 'bind'], \t\t\tread: ['output'] \t\t}, \t\tuser_no: {  \t\t\tcreate: ['bind'], \t\t\tread:: ['output'], \t\t} \t}; \tpreCheck = function(bindModel) {  \t\tif (bm.checkSelector().length === 0) return true; \t} }; ``` - suffix 파라메터는 selector 이름의 충돌을 방지를 접두사입니다.  member.html ```html   \tClass number     \t이름   추가      ``` - 페이지를 준비가 되면 init() 메소드 호출되어 preReady 에서  selector 유효성 검사를 합니다. - '추가' 버튼 클릭시 command.create.execute() 실행하여, 서버요청 결과를 화면에 바인딩합니다.  화면의 paging 처리 같은 공통 부분을 관리하기에 용이합니다.   ","url": "http://localhost:4000/ko/docs/service-config/"
  },{
    "title": "Configure Service objects",
    "excerpt":"Service objects make it easy to create 'BindModel' objects, and inheritance can separate common areas for increased reuse.  The 'BindModel' object can be accessed by the this.bindModel property in the callback function.  Type: ServiceType ```ts // items area type KeyType = 'none' | 'value' | 'text' | 'html' | 'prop' | 'attr' | 'css'; type SelectorType = { key: string, type: KeyType }; type RegExpType = { reg: RegExp, msg: string, return?: boolean }; type FuncType = (value: any) => boolean; type ConstraintType = RegExpType | FuncType; type ColumnType = { \tselector?: SelectorType, \tgetter?: () => any, \tsetter?: (val: any) => any, \tgetFilter?: () => any, \tsetFilter?: (val; any) => any, \tdefault?: stirng | number | boolean | null, \tvalue?: any, \talias?: string, \tcaption?: string, \tconstraints?: ConstraintType[] | ConstraintType, \trequired?: boolean | false, \tcolumnName?: string }; type Itemtype = { \t[key: string]: string | number | boolean | ColumnType }; // command area type CmdValueType = { \toutputOption?: 0 | 1 | 2 | 3,  // alias : outOpt \tconfig?: see axiosConfig, // axios type \turl?: string, \tviews?: string[], \tcbBegin?: (cmd: BindCommand) => void, \tcbValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBind?: (view: MetaView, cmd: BindCommand, cfg: object) => void, \tcbResult?: (data: object, cmd: BindCommand, res: object) => object, \tcbOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, }; type CommandType = { \t[key: string]: CmdValueType }; // mapping area typeColumnName = string; // 'item name' | 'column name' | 'table name.column name'; type CommandName = '$all' | string;  // string = 'command name' type ViewName = 'valid' | 'bind' | 'output' | '$all' | string; // add view name type MappingType = { \t[key: ColumnName]: { \t\t[key: CommandName]: ViewName | ViewName[] \t} }; // fn area type fnType = { \t[key: string]: Function }; // ------------------------- // service area type ServiceType = { \ttables?: string | string[], \tbaseConfig?: axiosConfig,  // // axios type \turl?: string, \tcbBaseBegin?: (cmd: BindCommand) => void; \tcbBaseValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBaseBind?: (view: MetaView, cmd: BindCommand, cfg) => void, \tcbBaseResult?: (data: object, cmd: BindCommand, res) => object, \tcbBaseOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbBaseEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, \titems?: Itemtype, \tcommand?: CommandType, \tmapping?: MappingType, \tfn?: fnType, \tpreRegister?: (bindModel) => void', \tpreCheck?: (bindModel) => boolean', \tpreReady?: (bindModel) => void,  }; ```  # Service Object  ## Configuring the Default Area  Configures the default callback function and server request information for the service object.   Type: Default server request and default callback function ```ts // Configuring Callback and Server Requests on Service Objects type ServiceType = { \tbaseConfig?: axiosConfig,  // axios 타입 참조 \turl?: string, \tcbBaseBegin?: (cmd: BindCommand) => void; \tcbBaseValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBaseBind?: (view: MetaView, cmd: BindCommand, cfg) => void, \tcbBaseResult?: (data: object, cmd: BindCommand, res) => object, \tcbBaseOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbBaseEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, }; ``` - 'url' is the value of 'baseConfig.url'.  Example: Basic ```js var bm = new BindModel({ \t// Default Server Request \tbaseConfig: { method: 'GET' }, \turl: '/user', \t// Default callback function \tcbBaseBegin: function(cmd) {  \t\tconsole.log ('default start callback);  \t}, \tcbBaseValid: function(view, cmd) { \t\tconsole.log ('default validation callback); \t\treturn true; \t}, \tcbBaseBind: function(view, cmd, cfg) {  \t\tconsole.log ('Basic Server Request Callback');  \t}, \tcbBaseResult: function(data, cmd, res) { \t\tconsole.log ('Default Server Response Callback'); \t\treturn data; \t}, \tcbBaseOutput: function(vidw, cmd, res) => {  \t\tconsole.log ('Default Response Output Callback');  \t}, \tcbBaseEnd: function(status, cmd, res) => {  \t\tconsole.log ('Default Termination Callback');  \t},\t }); ```  Example: Basic Configuration by Method ```js var bm = new BindModel();  // Default Server Settings bm.baseConfig = { method: 'GET', url: '/user' }; bm.cbBaseBegin = function(cmd) {  \tconsole.log ('default start callback);  };  // Default callback function bm.cbBaseValid: function(view, cmd) { \tconsole.log ('default validation callback); \treturn true; }; bm.cbBaseBind: function(view, cmd, cfg) {  \tconsole.log ('Basic Server Request Callback');  }; bm.cbBaseResult: function(data, cmd, res) { \tconsole.log ('Default Server Response Callback'); \treturn data; }; bm.cbBaseOutput: function(vidw, cmd, res) => {  \tconsole.log ('Default Response Output Callback');  }; bm.cbBaseEnd: function(status, cmd, res) => {  \tconsole.log ('Default Termination Callback');  }; ``` - Same as the service object configured above.  The default configuration can be set by command, and 'command' has a higher priority than the default configuration.  ## Configuring a Table Area  Configures additional table information for service objects.   Type: Tables ```ts // Configuring Tables in a Service Object type ServiceType = { \ttables?: string | string[], }; ```  The 'BindModel' object automatically generates and uses the 'MetaTable' named 'first'. Set the additional table to the 'tables' property.   ```js var bm = new BindModel({     tables: ['second', 'third'] });  // Refer to the main table // bm.first === bm._tables['first']  // true // bm.first === bm._tables[0]        // true  // See Additional Table // bm.second === bm._tables['second'] // true // bm.second === bm._tables[1]        // true // bm.third === bm._tables['third']   // true // bm.third === bm._tables[2]         // true ``` - Use when you need an additional table.  Example: Configuring a Table by Method ```js var bm = new BindModel();  // Create a table bm.addTable('second'); bm.addTable('third'); ``` - Same as the service object configured above.   ## Configuring the Item Area  Configures the column raw value for the service object.  ### Setting Raw Values for Columns  - items Each element has the raw value of the column.  - If the key value of items is of type 'string, number, boolean, null', it is set to the value of the column.  - If the key value of items is of the 'object' type, it is used as the property value of the column.  Type: items ```ts type KeyType = 'none' | 'value' | 'text' | 'html' | 'prop' | 'attr' | 'css'; type SelectorType = { key: string, type: KeyType }; type RegExpType = {reg: RegExp, msg: string, return?: boolean = true}; type FuncType = (value: any) => boolean; type ConstraintType = RegExpType | FuncType; type ColumnType = { \tselector?: SelectorType, \tgetter?: () => any, \tsetter?: (val: any) => any, \tgetFilter?: () => any, \tsetFilter?: (val: any) => any, \tdefault?: stirng | number | boolean | null, \tvalue?: any, \talias?: string, \tcaption?: string, \tconstraints?: ConstraintType[] | ConstraintType, \trequired?: boolean | false, \tcolumnName?: string }; type Itemtype = { \t[key: string]: string | number | boolean | ColumnType }; // Configuring items in a service object type ServiceType = { \titems?: ItemType }; ```  ### item naming rule - Column Name : The column is registered in the default table. - Table name.Column name: The column is registered in the target table. ### items property description - 'string, number, boolean, null ': The raw value is set to the value of the column. - selector : Selector to use when importing or setting the value of a column from DOM. - setter : A function to use when setting an external value. - getter : A function to use when importing values from outside. - required : Sets whether the column value is required or not. - setFilter : A filter function to use when setting the value. - getFilter —Filter function to use to import value. - constructs —Set the constraints of the value with a regular expression or user function, used for validation.  [[54. HTML Column Class-B|Refer to HTML Column]]   Example: items ```js var bm = new BindModel({ \t// Create additional tables \ttables: 'second', \t \t// Create an item \titems: { \t\taa: 'Cat', \t\t'second.bb': 10, \t\t'second.cc': true, \t\tdd: { \t\t\tselector: { key: '#U_ID', type: 'value' },  // 컬럼의 selector 설정 \t\t\tsetter: (val) => {/*Outside setting area*/}, // Setter for column \t\t\tgetter: () => { return 'external value'; }, // set getter for column \t\t}, \t\tee: { \t\t\trequired: true, // required setting of column \t\t\tsetFilter: (val) => {/*Outside setting area*/}, // SetFilter on column \t\t\tgetFilter: () => { return 'external value'; }, // set getFilter for column \t\t}, \t\tff: { \t\t\tconstructs: {reg: /abc/, msg: 'Failed to match!' } // Set Constraints for Column \t\t} \t} }); ``` - The item aa' is registered as a column in the default table, and 'Cat' is set in the value. - The item 'bb' registers as a column in the second table, and sets value to 10. - The cc' item registers as a column in the second table and sets true to the value.  Example: Configuring an Item Using the Method ```js var bm = new BindModel();  // Create additional tables bm.addTable('second');  // Create an item bm.items.add('aa', 'Cat'); bm.items.add('second.bb', 10); bm.items.add('second.cc', true); bm.items.add('dd', { \tselector: { key: '#U_ID', type: 'value' }, \tsetter: function(val) {/*external setting area*/}, \tgetter: function() { return '외부값'; },  }); bm.items.add('ee', { \trequired: true, \tsetFilter: function(val) {/*external setting*/}, \tgetFilter: function() { return '외부값'; }, }); bm.items.add('ff', { \tconstructs: {reg: /abc/, msg: 'Failed to match!' } }); ``` - Same as the service object configured above.  Items can also help manage data when registering the same column in multiple tables.  ## Configuring Command Areas  Configures command information for a service object.  Type: command ```ts type CmdValueType = { \toutputOption?: 0 | 1 | 2 | 3,  // 별칭 : outOpt \tconfig?: see axiosConfig, // axios type \turl?: string, \tviews?: string[], \tcbBegin?: (cmd: BindCommand) => void, \tcbValid?: (view: MetaView, cmd: BindCommand) => boolean, \tcbBind?: (view: MetaView, cmd: BindCommand, cfg: object) => void, \tcbResult?: (data: object, cmd: BindCommand, res: object) => object, \tcbOutput?: (views: MetaViewCollection, cmd: BindCommand, res: object) => void, \tcbEnd?: (status: number, cmd: BindCommand, res: object) => void, \tonExecute?: (bindModel, bindCommand) => void, \tonExecuted?: (bindModel, bindCommand) => void, }; type CommandType = { \t[key: string]: CmdValueType }; // Configuring a command in a service object type ServiceType = { \tcommand?: CommandType, }; ``` - For 'CmdValueType.url', see the value 'CmdValueType.config.url'. - 'CommandType' key is the name of the 'command' to be added.  ### Command Type Description -  outputOption —Specifies how the view is output; the default is 0.  -  config : Same as the setting object of axios. -  url : 'config.url' value, setting the URL path to request via axios. - views —Name of the output view (MetaView) to be added. - cbBegin : This is the callback function before the start. - cbValid : Validation callback function. - cbBind : This is the server request callback function. - cbResult —The server response callback function. - cbOutput —Answer output callback function. - cbEnd —Callback function before termination.  [24. Bind Command Composition - C#Callback (Attribute)] Example: command ```js var bm = new BindModel({ \tcommand: { \t\tcreate: {}, \t\tread: { \t\t\toutputOption: 3, // Set data to column value (specified column) \t\t\tconfig: {method: 'GET' }, // GET request setting \t\t\tcbEnd: function() { alarm('Normal Processed') ; } // Callback function after processing is completed \t\t}, \t\tupdate: { \t\t\tviews: ['two'], // adding 'two' views \t\t\turl: '/user' // URL path to request \t\t} \t} }); ``` - I created \"create\"  \t- Set the default output option = 0. - We created \"read\" \t- Set output option = 3 \t- Set the config server request and \t- Sets the cbEnd callback function. - Create 'update' and \t- Set the default output option = 0 and \t- I'll add \"two\" to the output view \t- Set the server request url.  Example: Configuring Commands by Method ```js var bm = new BindModel(); // command generation bm.addCommand('create'); bm.addCommand('read'); bm.addCommand('update');  // Set the read command bm.commmand['read'].outputOption = 3; bm.commmand['read'].config = { method: 'GET' }; bm.commmand['read'].cbEnd = {  \talert('Normal Processed'); };  // update command setting bm.commmand['update'].newOutput('two'); bm.commmand['update'].url = '/user'; ``` - Same as the service object configured above.   ## Configuring Mapping Areas  Configure the mapping of items and 'command' in the service object.  Type: Mapping ```ts typeColumnName = string; // 'item name' | 'column name' | 'table name.column name'; type CommandName = '$all' | string;  // string = '명령 이름' type ViewName = 'valid' | 'bind' | 'output' | '$all' | string; // 추가 뷰 이름 type MappingType = { \t[key: ColumnName]: { \t\t[key: CommandName]: ViewName | ViewName[] \t} }; // Configuring Mapping on a Service Object type ServiceType = { \tmapping?: MappingType }; ```  ### Mapping Rules - Column Name  \t- 'Column Name' : The column in the base table is selected. \t- ''Table name.Column name' : A column for the specified table is selected. (Create when none exists) #REVIEW - Command Name  \t- ' 'command name' : The specified command is selected. \t- '$all' : Full command is selected. - View Name (ViewName) \t- 'valid', 'bind', 'output' : Map to the selected MetaView (multiple is specified as array) \t- '$all' : Map to the entire MetaView (including added output) \t [00. Column mapping]  Example: Mapping ```js var bm = new BindModel(); bm.setService({ \t// Table Area \ttables: ['second'], \t// Item Area \titems: { \t\taa: '', \t\tbb: '', \t\tcc: '', \t\tdd: '' \t}, \t// command area \tcommand: { \t\tone: {}, \t\ttwo: {}, \t}, \t// Mapping area \tmapping: { \t\taa: { $all: ['valid']}, // Register 'aa' in the 'valid' view of all commands \t\tbb: {one: ['bind']}, // Register 'bbb' in 'bind' view of 'one' command \t\t'second.cc ': {two: ['output'] } // Register 'cc' in 'output' view of 'two' command \t} });  // bm.items.count == 4 ('aa','bb','cc','dd') // bm.first.columns.count == 2 ('aa','bb') // bm.second.columns.count == 1 ('cc') // bm.cmd['one'].valid.columns.count == 1 ('aa') // bm.cmd['one'].bind.columns.count == 1 ('bb') // bm.cmd['one'].output.columns.count == 0 // bm.cmd['two'].valid.columns.count == 1 ('aa') // bm.cmd['two'].bind.columns.count == 0 // bm.cmd['two'].output.columns.count  == 1 ('cc') ``` - Items 'aa' are registered in the default table and mapped to the valid (MetaVeiw) of all commnads. - Items 'bbb' are registered in the default table and mapped to the bind (MetaVeiw) of the 'one' command. - The 'cc' item is registered in the 'second' table and mapped to the output (MetaVeiw) of the 'two' command.  Type: setMapping() ```ts type setMapping( \tmapping: PropertyCollection | object,  \tbTable?: MetaTable | string ) => void; ``` - mapping : The collection to be mapped. - bTable : Default table to be mapped, default is \\_baseTable.  Example: Configuring Mapping by Method ```js var bm = new BindModel();  // Create additional tables bm.addTable('second');  // Create an item bm.items.add('aa', ''); bm.items.add('bb', ''); bm.items.add('cc', ''); bm.items.add('dd', '');  // command generation bm.addCommand('one'); bm.addCommand('two');  // Item mapping bm.setMapping({ \taa: { $all: ['valid']}, // Register 'aa' in the 'valid' view of all commands \tbb: {one: ['bind']}, // Register 'bbb' in 'bind' view of 'one' command \t'second.cc ': {two: ['output'] } // Register 'cc' in 'output' view of 'two' command }) ``` - Same as the service object configured above.  You can efficiently map the columns required for a specific view of each command, which helps to maintain consistency in data processing and improve management convenience.  ## Configuring a Function Area  Configures the user function of the service object.  Type : fn ```ts type fnType = { \t[key: string]: Function; }; // Configuring fn in a service object type ServiceType = { \tfn?: fnType }; ``` - The key is the user function name.  Example: fn ```js var bm = new BindModel({ \tcbBaseBegin: function(cmd) { \t\tAccess the parameter at cmd._model.fn.ecCreate(); //cmd \t\tthis.bindModel.fn.sum(1, 1); // this.bindModel로 접근 \t}, \tcommand: { \t\tcreate: { \t\t\tcbEnd: function() { \t\t\t\tthis.bindModel.fn.sum(1, 2); \t\t\t} \t\t}, \t}, \tfn: { \t\tsum: function(a, b) {return a + b}, \t\texecCreate: function() { \t\t\tthis.bindModel.cmd.read.execute(); \t\t} \t} });  // Register for an event $('#btn_create').click(function() { \tbm.fn.execCreate(); });  ``` - You can access the BindModel object with the 'parameter' or 'this.bindModel' properties in the callback function.  Example: Configuring a Method as a Function ```js var bm = new BindModel();  // Configuring Functions bm.fn.add('sum', function(a, b) {return a + b}); bm.fn.add('execCreate', function() { \tthis.bindModel.cmd.read.execute(); // this.bindModel 로 접근 });  // Common callback configuration bm.cbBaseBegin = function(cmd) { \tcmd._model.fn.ecCreate(); // Access to the cmd parameter \tthis.bindModel.fn.sum(1, 1); // this.bindModel 로 접근 };  // Configuring Commands bm.addCommand('create'); bm.command['create'].cbEnd = function() { \tthis.bindModel.fn.sum(1, 2);  // this.bindModel 로 접근 }  // Register for an event $('#btn_create').click(function() { \tbm.fn.execCreate(); // Access functions from outside }); ``` - Same as the service object configured above.  Each area can increase the degree of engagement and increase reusability and maintenance.   ## Configuring the Preprocessing Area  Configures preprocessing information for service objects, primarily used to automate service objects.  타입 : init(), preRegister, preCheck, preReady ```ts type init = () => void;  type preRegister = (bindModel) => void;  type preCheck = (bindModel) => boolean;  type preReady = (bindModel) => void;  ```  ### Preprocessing Call Flow  1. The init() mesodle calls are preRegister, preCheck, and preReady sequentially. 2. If you return false from preCheck, preReady is called cbFail without calling. 3. If you return true from preCheck, a preReady call is made.  Preprocessing is used for interaction between service objects and screen pages or selector validation.  Example: Pre-processing ```js var bm = new BindModel({ \tpreRegister: function(bindModel) {  \t\t// Pre-processing: Before the inspection \t}, \tpreCheck: function(bindModel) { \t\t// Pre-processing: Inspection \t\tif (bm.checkSelector().length === 0) return true; \t}, \tpreReady: function(bindModel) {  \t\t// Pre-processing: Ready \t\tbindModel.command['test'].execute(); \t}, });  $(document).ready(function () { \tbm.init(); }); ``` - When the page is ready, call the init() method to inspect the DOM and run the 'test' command.  Example: Pre-processing a Method ```js var bm = new BindModel(); // BindModel Settings...  bm.preRegister = function(bindModel) {  \t// Pre-processing: Before the inspection }; bm.preCheck = function(bindModel) {  \t// Pre-processing: Inspection \tif (bm.checkSelector().length === 0) return true; }; bm.preReady = function(bindModel) {  \t// Pre-processing: Ready \tbindModel.command['test'].execute(); };  $(document).ready(function () { \tbm.init(); });  ``` - Same as the service object configured above.  Pre-processing areas can be utilized if automation is required.  # function  ## To inject service objects  When creating a 'BindModel' object, you can either pass parameters or call the setService() method to inject service objects.   Type: setservice() ```ts type setService = (service: IService, isTypeCheck: boolean = false) => void; ``` -  service —The service object to be injected. - isTypeCheck : Sets whether to perform a type check; the default is false.  As a setService() method, it separates service objects to enhance readability and maintenance of code.  Example: Injection via Creator ```js var bm1 = new BindModel({ \titems: {         aa: 'Cat',         bb: 10,         cc: true,     },     fn: {         sum: function(a, b) { return a + b; },     },     url: '/user',     command: {         read: {             outputOption: 3,             cbEnd: function() { console.log('Normal Processed'); }         },         update: {             views: ['two'],             url: '/user'         }     },     mapping: {         aa: { $all: ['valid'] },         bb: { read: ['bind'], update: 'output' },         cc: { update: ['output'] }     }, }); ```  Example: Inject with setService() Method ```js // items, fn configuration var svcItems = { \titems: {         aa: 'Cat',         bb: 10,         cc: true,     },     fn: {         sum: function(a, b) { return a + b; },     } };  // Other configurations var svcCommon = {     baseConfig: { method: 'GET' },     url: '/user',     command: {         read: {             outputOption: 3,             config: { method: 'GET' },             cbEnd: function() { console.log('Normal Processed'); }         },     },     mapping: {         aa: { $all: ['valid'] },         bb: { read: ['bind'], update: 'output' },         cc: { update: ['output'] }     }, };  barbm = new BindModel(); // Injection by Parameters  bm2.setService(svcItems); bm2.setService(svcCommon); ``` - Same as the service object configured above. - In the first setService() method call, set items, fn to service. - The second setService() method call sets up services such as command, mapping, and so on.  Duplicate settings retain the last-minute value, and are added for event values.  Areas 'items', 'fn' have low dependence on other areas. Service objects allow you to manage common settings and increase reusability.  ## Defining a service class  ### Create a service object through inheritance  You can create a service in a class to increase the reuse of the common part of the code. Service classes can be used in various structures.  common-svc.js ```js class CommonService() { \tcbFail = function(msg) { \t\tconsole.warn (\"user failure handling:+ msg\"); \t}; \tcbError = function(msg) { \t\tconsole.error (\"User error handling\") \t}; } ``` - Common areas were created as common service classes.  member-svc.js ```js class MemberService(suffix) extends CommonService { \titems = { \t\tidx: -1, \t\tuser_no: { selector: { key: '#user_no'+ suffix, type: 'value' } }, \t\tu_name: { selector: { key: '#u_name'+ suffix, type: 'value' } }, \t}; \tcommand = { \t\tcreate: 0, \t\tread: { \t\t\toutputOption: 3, \t\t\tcbEnd: () => { alert('Normal Processed'); } \t\t} \t}; \tmapping = { \t\tidx: {  \t\t\tread: ['valid', 'bind']  \t\t}, \t\tu_name: {  \t\t\tcreate: ['valid', 'bind'], \t\t\tread: ['output'] \t\t}, \t\tuser_no: {  \t\t\tcreate: ['bind'], \t\t\tread:: ['output'], \t\t} \t}; \tpreCheck = function(bindModel) {  \t\tif (bm.checkSelector().length === 0) return true; \t} }; ``` - The suffix parameter is a prefix for preventing conflicts in the selector name.  member.html ```html   \tClass number     \t이름   추가      ``` - When the page is ready, the init() method is called to validate the selector in preReady. - When you click the 'Add' button, run command.create.execute() to bind the server request result to the screen.  Easy to manage common parts such as paging processing on the screen.   ","url": "http://localhost:4000/en/docs/service-config/"
  },{
    "title": "단계별 제작 과정",
    "excerpt":"BindModel 를 활용하여 고객 정보 등록, 조회, 수정 기능을 처리하는 HTML 제작 과정입니다.  ## 고객정보 등록 하기  여러 command에서 컬럼을 공유해서 사용하는 화면이므로 서비스 객체 주입 방식을 사용하여 제작했습니다.  ### 1. 회원 등록 HTML  제작 ```html  \tname    \tman \twoman\t   \ttel    등록 ``` - 이 HTML은 사용자 이름, 성별, 연락처를 입력할 수 있는 입력 필드와 등록 버튼을 포함합니다.  ### 2. 아이템 및 명령 설정 ```js var bm = new BindModel({ \titems: { \t\tuser_name: { \t\t\tselector: { key: '#user_name', type: 'value' }, \t\t\trequired: true \t\t}, \t\tgender: { \t\t\tsetFilter: function(val) {  \t\t\t\t$('input[name=gender][value='+ val + ']').prop('checked',true); \t\t\t}, \t\t\tgetFilter: function() {  \t\t\t\treturn $('input[name=gender]:checked').val()  \t\t\t} \t\t}, \t\ttel: { \t\t\tselector: { key: '#tel', type: 'value' }, \t\t\tconstraints: [ \t\t\t\t{ regex: /\\d{3}-\\d{3,4}-\\d{4}/, msg: \"Not in phone number format.\"} \t\t\t] \t\t} \t}, \tcommand: { \t\tcreate: { \t\t\tcbEnd: function() { \t\t\t\talert( 'Registration processed successfully'); \t\t\t} \t\t} \t}, \tmapping: { \t\tuser_name: { create: ['valid', 'bind'] }, \t\tgender:    { create: ['bind'] }, \t\ttel:       { create: ['bind', 'bind'] } \t} }); bm.url = '/user'; ``` - items는 입력 필드와 그 특성을 정의합니다. \t- user_name :  ID 가 'user_name' 인 요소와 바인딩되며 필수 항목입니다. \t- gender : 라디오 버튼을 설정 및 가져오는 필터를 사용합니다. \t- tel: ID 가 'tel' 인 요소와 바인딩되며 전화번호 형식을 검사하는 유효성 검사를 포함합니다. - command는 서버와의 상호작용을 정의합니다. \t- create: 등록 관련 command 이며, 완료 시 알림을 표시하는 콜백 함수를 포함합니다. - mapping은 아이템과  명령 간의 매핑을 정의합니다. \t- user_name, gender, tel 필드가 create 명령에 어떻게 매핑되는지 설정합니다.  ### 3. 이벤트 등록  ```js $('#btn_create').click(() => bm.command['create'].execute()); ``` - 등록 버튼이 클릭되면 create 명령을 실행합니다.  ## 고객정보 조회 하기  서버 데이터 예시 ```json // Restful :/user/1 { \t\"rows\": [ \t\t{ \t\t\t\"user_name\": \"Hong Gildong\", \t\t\t\"gender\": \"male\", \t\t\t\"tel\": \"010-123-1234\" \t\t} \t] } ``` - 서버에서 조회할 때 받을 JSON 형식의 데이터입니다. ### 1. html 추가  ```html  ``` - 조회할 고객의 ID를 저장하기 위한 숨김 필드를 추가합니다.  ### 2. items, command, mapping 추가 ```js var bm = new BindModel({ \titems: { \t\tidx: { \t\t\tselector: { key: '#idx', type: 'value' }, \t\t} \t}, \tcommand: { \t\tread: { \t\t\toutputOption: 3 \t\t} \t}, \tmapping: { \t\tidx:       { read: ['valid', 'bind'] }, \t\tuser_name: { read: ['output'] }, \t\tgender:    { read: ['output'] }, \t\ttel:       { read: ['output'] } \t} }); ``` -  items에 idx 아이템을 추가하여 고객 ID를 저장합니다. - command에 read 명령을 추가하여 조회 기능을 정의합니다. - mapping에서 idx, user_name, gender, tel 아이템을 read 명령에 매핑합니다.  ### 3. url 에서 idx 가져와서 읽기  ```js   $(document).ready(function () { \tvar idx = window.location.href.split('=')[1]; \tif (idx) { \t\t$(\"#idx\").val(idx);  // input hidden 설정 \t\tbm.command['read'].execute(); \t} }); ``` - 페이지가 로드될 때 URL에서 idx 값을 가져와 idx 컬럼에 설정하고, read 명령을 실행하여 데이터를 조회합니다.  ## 고객정보 수정 하기  ### 1. 수정 버튼 추가  ```html 수정 ``` - 수정 버튼을 추가합니다.  ### 2. command 및 mapping 추가 ```js var bm = new BindModel({ \tcommand: { \t\tupdate: { \t\t\tcbEnd: function() { \t\t\t\talert('Corrected processed'); \t\t\t} \t\t} \t}, \tmapping: { \t\tuser_name: { update: ['valid', 'bind'] }, \t\tgender:    { update: ['bind'] }, \t\ttel:       { update: ['bind', 'bind'] } \t} }); ``` -  command에 update 명령을 추가하여 수정 기능을 정의합니다. -  mapping에서 user_name, gender, tel 컬럼을 update 명령과 매핑합니다.  ### 3. 이벤트 등록 ```js $('#btn_update').click(() => bm.command['update'].execute()); ``` - 수정 버튼이 클릭되면 update 명령을 실행합니다.   ## 전체 소스 (조회, 등록, 수정)  ### 1. body  영역 ```html   \tname    \tman \twoman\t   \ttel    create update ```  ### 2. script 영역  ```html  ```  이 코드는 BindModel 를 활용하여 간단하고 직관적으로 입력 필드와 명령 간의 바인딩 및 서버와의 상호작용을 설정하는 예시입니다. 고객 정보를 등록, 조회, 수정하는 기능을 구현하는 데 필요한 모든 요소를 포함하고 있으며, 사용자의 입력과 서버 간의 데이터 교환을 효율적으로 처리합니다. ","url": "http://localhost:4000/ko/docs/step-by-step/"
  },{
    "title": "Step-by-step process",
    "excerpt":"It is an HTML production process that uses BindModel to process customer information registration, inquiry, and correction functions.  ## Registering customer information  Since it is a screen that is used by sharing columns in several commands, it was created using the service object injection method. ### 1. Create membership HTML  ```html  \tname    \tman \twoman\t   \ttel    등록 ``` - This HTML includes an entry field and a register button to enter your username, gender, and contact information. ### 2. Set Items and Commands  ```js var bm = new BindModel({ \titems: { \t\tuser_name: { \t\t\tselector: { key: '#user_name', type: 'value' }, \t\t\trequired: true \t\t}, \t\tgender: { \t\t\tsetFilter: function(val) {  \t\t\t\t$('input[name=gender][value='+ val + ']').prop('checked',true); \t\t\t}, \t\t\tgetFilter: function() {  \t\t\t\treturn $('input[name=gender]:checked').val()  \t\t\t} \t\t}, \t\ttel: { \t\t\tselector: { key: '#tel', type: 'value' }, \t\t\tconstraints: [ \t\t\t\t{ regex: /\\d{3}-\\d{3,4}-\\d{4}/, msg: \"Not in phone number format.\"} \t\t\t] \t\t} \t}, \tcommand: { \t\tcreate: { \t\t\tcbEnd: function() { \t\t\t\talert( 'Registration processed successfully'); \t\t\t} \t\t} \t}, \tmapping: { \t\tuser_name: { create: ['valid', 'bind'] }, \t\tgender:    { create: ['bind'] }, \t\ttel:       { create: ['bind', 'bind'] } \t} }); bm.url = '/user'; ``` - items define the input fields and their characteristics. \t- user_name : Binds with element with ID 'user_name' and is required. \t- gender : Use a filter to set and import radio buttons. \t- tel: contains a validation that binds to an element with ID 'tel' and checks the phone number format. - command defines the interaction with the server. \t- create—Registration-related command, including a callback function that alerts you upon completion. - Mapping defines the mapping between items and commands. \t- Sets how the user_name, gender, and tel fields are mapped to the create command.  ### 3. Event registration  ```js $('#btn_create').click(() => bm.command['create'].execute()); ``` - When the register button is clicked, run the create command.  ## Looking up customer information  Example Server Data ```json // Restful :/user/1 { \t\"rows\": [ \t\t{ \t\t\t\"user_name\": \"Hong Gildong\", \t\t\t\"gender\": \"male\", \t\t\t\"tel\": \"010-123-1234\" \t\t} \t] } ``` - Data in JSON format that you will receive when you query the server. ### 1. Add html  ```html  ``` - Add a hidden field to store the ID of the customer you want to look up.  ### 2. items, command, mapping 추가  ```js var bm = new BindModel({ \titems: { \t\tidx: { \t\t\tselector: { key: '#idx', type: 'value' }, \t\t} \t}, \tcommand: { \t\tread: { \t\t\toutputOption: 3 \t\t} \t}, \tmapping: { \t\tidx:       { read: ['valid', 'bind'] }, \t\tuser_name: { read: ['output'] }, \t\tgender:    { read: ['output'] }, \t\ttel:       { read: ['output'] } \t} }); ``` -  Save the customer ID by adding the idx item to the items. - Define the lookup function by adding the read command to the command. - Mapping maps idx, user_name, gender, tel items to read commands.  ### 3. Get idx from url and read it  ```js   $(document).ready(function () { \tvar idx = window.location.href.split('=')[1]; \tif (idx) { \t\t$(\"#idx\").val(idx);  // input hidden 설정 \t\tbm.command['read'].execute(); \t} }); ``` - When the page loads, take the idx value from the URL and set it in the idx column, run the read command to query the data.  ## To modify customer information  ### 1. Add a modification button  ```html 수정 ``` - Add the Modify button.  ### 2. Add command and mapping  ```js var bm = new BindModel({ \tcommand: { \t\tupdate: { \t\t\tcbEnd: function() { \t\t\t\talert('Corrected processed'); \t\t\t} \t\t} \t}, \tmapping: { \t\tuser_name: { update: ['valid', 'bind'] }, \t\tgender:    { update: ['bind'] }, \t\ttel:       { update: ['bind', 'bind'] } \t} }); ``` -  Define modifications by adding the update command to the command. -  In mapping, map the user_name, gender, and tel columns with the update command. ### 3. Event registration  ```js $('#btn_update').click(() => bm.command['update'].execute()); ``` - When the edit button is clicked, run the update command.   ## Full Source (Inquiry, Registration, Modification)  ### 1. Body area  ```html   \tname    \tman \twoman\t   \ttel    create update ```  ### 2. Script Area  ```html  ```  This code is a simple and intuitive example of using BindModel to establish binding between input fields and commands and interactions with servers. It contains all the elements needed to implement the ability to register, query, and modify customer information, and efficiently handles user input and data exchange between servers. ","url": "http://localhost:4000/en/docs/step-by-step/"
  },{
    "title": "execute() 동기화",
    "excerpt":"BindCommand 객체의 execute() 메소드는 Promise를 반환합니다. 따라서 async 및 await 키워드를 사용하여 비동기적으로 명령을 실행하고 필요한 경우 동기화 코드를 작성할 수 있습니다.   타입 : execute() ```ts type execute () => Promise; ```  ## 단일 명멸어 동기화 예제  다음 코드는 'read_member' 라는 명령을 실행하고, 해당 명령이 완료된 후에 알림을 표시합니다.  ```js var bm = new BindModel();  bm.addCommand('read_member', 3); // ... omit column settings  async function readView() {     try {         await bm.cmd['read_member'].execute();         alert( 'Called membership information');     } catch (error) {         console.error ('Error encountered during command execution:', error);     } } ``` - 이 코드에서 execute() 메소드는 Promise를 반환하므로 await 키워드를 사용하여 명령이 완료될 때까지 대기합니다. 명령이 성공적으로 완료되면 알림 메시지를 표시합니다. 또한, try...catch 블록을 사용하여 명령 실행 중 발생할 수 있는 오류를 처리할 수 있습니다.  ## 다중 명령어 동기화 예제  다음 코드는 read_meb와 read_corp라는 두 개의 명령을 순차적으로 실행합니다. ```js var bm = new BindModel();  bm.addCommand('read_meb', 3); bm.addCommand('read_corp', 3); // ... omit column settings  async function readView() {     try {         await bm.cmd['read_meb'].execute();         console.log ('calling private membership information');                  await bm.cmd['read_corp'].execute();         console.log ('could get corporation information');     } catch (error) {         console.error ('Error encountered during command execution:', error);     } } ``` - 이 코드에서는 두 개의 명령을 순차적으로 실행하며, 각 명령이 완료될 때마다 로그 메시지를 출력합니다. try...catch 블록을 사용하여 두 명령 실행 중 발생할 수 있는 오류를 처리합니다.  ## 동시 실행 예제  명령을 순차적으로 실행하는 대신 동시에 실행해야 하는 경우, Promise.all을 사용할 수 있습니다.  ```js var bm = new BindModel();  bm.addCommand('read_meb', 3); bm.addCommand('read_corp', 3); // ... Column Settings async function readView() {     try {         await Promise.all([             bm.cmd['read_meb'].execute(),             bm.cmd['read_corp'].execute()         ]);         console.log ('Called all information');     } catch (error) {         console.error ('Error encountered during command execution:', error);     } } ``` - 이 코드에서는 Promise.all을 사용하여 두 명령을 동시에 실행하고, 모든 명령이 완료될 때까지 기다립니다. 모든 명령이 성공적으로 완료되면 로그 메시지를 출력합니다. 오류가 발생하면 catch 블록에서 처리합니다.  이와 같이 async 및 await 키워드를 사용하면 Promise 기반의 비동기 코드를 쉽게 동기화할 수 있습니다. 이를 통해 명령 실행 순서를 제어하고 오류를 처리할 수 있습니다. ","url": "http://localhost:4000/ko/docs/synchronization/"
  },{
    "title": "Synchronization",
    "excerpt":"The execute() method of the Bindcommand object returns Promise, so you can use the async and wait keywords to execute commands asynchronously and write synchronization codes if necessary.   Type: execute() ```ts type execute () => Promise; ```  ## Example of synchronizing single-flawed fish  The following code executes a command called 'read_member' and displays a notification after that command is complete. ```js var bm = new BindModel();  bm.addCommand('read_member', 3); // ... omit column settings  async function readView() {     try {         await bm.cmd['read_member'].execute();         alert( 'Called membership information');     } catch (error) {         console.error ('Error encountered during command execution:', error);     } } ``` - In this code, the execute() method returns Promise, so use the wait keyword to wait for the command to complete. If the command completes successfully, a notification message is displayed. You can also use the try...catch block to handle errors that may occur during the execution of the command.   ## Multiple Command Synchronization Example  The following code executes two commands in sequence: read_meb and read_corp. ```js var bm = new BindModel();  bm.addCommand('read_meb', 3); bm.addCommand('read_corp', 3); // ... omit column settings  async function readView() {     try {         await bm.cmd['read_meb'].execute();         console.log ('calling private membership information');                  await bm.cmd['read_corp'].execute();         console.log ('could get corporation information');     } catch (error) {         console.error ('Error encountered during command execution:', error);     } } ``` - The code executes two commands in sequence, and outputs a log message each time they complete. Use the try...catch block to handle errors that may occur during the execution of both commands.  ## Example of a Simultaneous Run  Promise.all is available if you need to run commands simultaneously instead of sequentially.  ```js var bm = new BindModel();  bm.addCommand('read_meb', 3); bm.addCommand('read_corp', 3); // ... Column Settings async function readView() {     try {         await Promise.all([             bm.cmd['read_meb'].execute(),             bm.cmd['read_corp'].execute()         ]);         console.log ('Called all information');     } catch (error) {         console.error ('Error encountered during command execution:', error);     } } ``` - In this code, use Promise.all to run both commands at the same time, and wait for all commands to complete. Once all commands have completed successfully, a log message will be output. If an error occurs, the catch block will handle it.  This makes it easy to synchronize promise-based asynchronous code using the async and wait keywords, allowing you to control the order of command execution and handle errors. ","url": "http://localhost:4000/en/docs/synchronization/"
  },{
    "title": "Posts by Year",
    "excerpt":"","url": "http://localhost:4000/en/year-archive/"
  },{
    "title": "Posts by Year",
    "excerpt":"","url": "http://localhost:4000/ko/year-archive/"
  }]
